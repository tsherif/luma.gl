{"version":3,"sources":["webpack:///../modules/shadertools/src/utils/webgl-info.js","webpack:///../modules/shadertools/src/utils/is-old-ie.js","webpack:///../modules/shadertools/src/lib/platform-defines.js","webpack:///../modules/shadertools/src/lib/assemble-shaders.js","webpack:///../modules/shadertools/src/lib/shader-module-registry.js","webpack:///../modules/shadertools/src/lib/resolve-modules.js","webpack:///../modules/core/src/lib/model-utils.js","webpack:///../modules/core/src/resource-management/program-manager.js","webpack:///../modules/webgl/src/utils/format-value.js","webpack:///../modules/webgl/src/debug/debug-vertex-array.js","webpack:///../modules/webgl/src/debug/debug-uniforms.js","webpack:///../modules/webgl/src/debug/debug-program-configuration.js","webpack:///../modules/core/src/debug/seer-integration.js","webpack:///../modules/core/src/lib/base-model.js","webpack:///../modules/core/src/lib/model.js","webpack:///../modules/shadertools/src/lib/transpile-shader.js","webpack:///../modules/shadertools/src/lib/filters/prop-types.js","webpack:///../modules/shadertools/src/lib/shader-module.js","webpack:///../modules/shadertools/src/lib/inject-shader.js","webpack:///../modules/shadertools/src/modules/module-injectors.js","webpack:///../modules/shadertools/src/index.js","webpack:///../modules/shadertools/src/shaders/modular-vertex.glsl.js","webpack:///../modules/shadertools/src/shaders/modular-fragment.glsl.js","webpack:///../modules/shadertools/src/lib/constants.js","webpack:///../modules/shadertools/src/utils/assert.js","webpack:///../modules/webgl/src/classes/transform-feedback.js"],"names":["GL_VENDOR","GL_RENDERER","GL_VERSION","GL_SHADING_LANGUAGE_VERSION","WEBGL_FEATURES","GLSL_FRAG_DATA","GLSL_FRAG_DEPTH","GLSL_DERIVATIVES","GLSL_TEXTURE_LOD","FEATURES","Object","key","compiledGlslExtensions","canCompileGLGSExtension","gl","cap","opts","feature","assert","navigator","window","userAgent","isMSIE","isTrident","isOldIE","source","shader","VERTEX_SHADER","canCompile","COMPILE_STATUS","getFeature","extensionName","Boolean","isWebGL2","value","hasFeatures","features","Array","every","getPlatformShaderDefines","info","vendor","UNMASKED_VENDOR_WEBGL","renderer","UNMASKED_RENDERER_WEBGL","gpuVendor","identifyGPUVendor","version","shadingLanguageVersion","getContextInfo","debugInfo","toLowerCase","INJECT_SHADER_DECLARATIONS","inject_shader","SHADER_TYPE","_SHADER_TYPE","constants","HOOK_FUNCTIONS","_HOOK_FUNCTIONS","MODULE_INJECTIONS","_MODULE_INJECTIONS","FRAGMENT_SHADER_PROLOGUE","createShaderHook","hook","_hook$split","stage","signature","name","assign","createModuleInjection","moduleName","injection","_opts$order","order","shaderStage","moduleInjections","assembleShaders","vs","fs","modules","resolveModules","assembleShader","type","getUniforms","assembleGetUniforms","assembleModuleMap","_ref","_hookFunctions","_moduleInjections","id","_ref$defines","defines","_ref$hookFunctions","hookFunctions","_ref$moduleInjections","_ref$inject","inject","_ref$prologue","prologue","log","isVertex","sourceLines","glslVersion","versionLine","coreSource","allDefines","module","assembledSource","_ref6","getShaderName","_ref5","toUpperCase","getShaderType","isFragment","versionDefines","behavior","getVersionDefines","count","sourceText","define","Number","getApplicationDefines","injectStandardStubs","hookInjections","mainInjections","_iterator","_isArray","isArray","_i","Symbol","iterator","_ref2","length","next","done","injections","_key","result","hookName","hookFunction","header","a","b","_iterator4","_isArray4","_i4","_ref7","footer","getHookFunctions","injectShader","uniforms","_iterator2","_isArray2","_i2","_ref3","moduleUniforms","_iterator3","_isArray3","_i3","_ref4","shaderModule","getShaderModule","ShaderModuleRegistry","this","shaderModules","defaultShaderModules","setDefaultShaderModules","getDefaultShaderModules","registerShaderModules","_ref$ignoreMultipleRe","_temp","ignoreMultipleRegistrations","shaderModuleList","_registerShaderModule","moduleOrName","shader_module","_this","map","Error","shaderModuleRegistry","shader_module_registry_ShaderModuleRegistry","getShaderDependencies","resolve_modules_getShaderModule","moduleMap","moduleDepth","getDependencyGraph","level","keys","sort","dependencies","GLTF_TO_LUMA_ATTRIBUTE_MAP","POSITION","NORMAL","COLOR_0","TEXCOORD_0","TEXCOORD_1","TEXCOORD_2","mapAttributeName","options","_ref$attributeMap","attributeMap","inferAttributeAccessor","attributeName","attribute","category","size","ProgramManager","_programCache","_getUniforms","_registeredModules","_defaultModules","_hashes","_hashCounter","stateHash","_useCounts","getDefaultProgramManager","defaultProgramManager","addDefaultModule","find","m","push","removeDefaultModule","filter","addModuleInjection","addShaderHook","get","props","_props","_props$vs","_props$fs","_props$defines","_props$inject","_props$varyings","varyings","_props$bufferMode","bufferMode","_getModuleList","vsHash","_getHash","fsHash","moduleHashes","varyingHashes","v","defineKeys","injectKeys","defineHashes","hash","injectHashes","assembled","classes_program","x","program","release","delete","undefined","appModules","seen","i","len","_len","_module","_name","formatValue","_opts$isInteger","isInteger","ArrayBuffer","_opts$maxElts","maxElts","_opts$size","string","formatArrayValue","String","Math","decimal","getDebugTableRow","vertexArray","accessor","marker","verts","bytes","classes_buffer","format","buffer","_buffer$getDebugData","getDebugData","data","modified","getKey","getGLSLDeclaration","typeAndName","getCompositeGLType","getDebugTableForUniforms","_ref$header","_ref$undefinedOnly","undefinedOnly","uniformLocations","_uniformSetters","table","uniformNames","uniformName","addUniformToTable","_uniformName","_uniformName2","unusedCount","unusedTable","_unusedTable$uniformN","uniform","Type","_table$uniformName","isDefined","isUniformDefined","debug_program_configuration_getGLSLDeclaration","attributeInfo","_attributeInfo$access","models","recursiveSet","obj","path","overrides","Map","seer","payload","model","itemKey","valuePath","__SEER_INITIALIZED__","setOverride","BaseModel","isWebGL","_props$id","uid","lastLogTime","initialize","shaderCache","programManager","_programManagerState","_managedProgram","_props$program","programProps","_programDirty","userData","needsRedraw","_attributes","attributes","animatedUniforms","animated","animationLoop","timerQueryEnabled","timeElapsedQuery","lastQueryReturned","stats","accumulatedFrameTime","averageFrameTime","profileFrameCount","pickable","_checkProgram","_setBaseModelProps","setUniforms","getModuleUniforms","moduleSettings","setProps","removeModel","isAnimated","getProgram","setProgram","overs","getOverrides","_extractAnimatedUniforms","updateModuleSettings","clear","drawGeometry","_opts","_opts$moduleSettings","framebuffer","_opts$uniforms","_opts$attributes","_opts$transformFeedba","transformFeedback","_opts$parameters","parameters","_opts$vertexArray","animationProps","setAttributes","_refreshAnimationProps","logPriority","_logDrawCallStart","drawParams","getDrawParams","isInstanced","isIndexed","indexType","indexOffset","instanceCount","noop","_this$props","_this$props$onBeforeR","onBeforeRender","_this$props$onAfterRe","onAfterRender","_timerQueryStart","didDraw","draw","drawMode","getDrawMode","vertexCount","getVertexCount","offset","_timerQueryEnd","_logDrawCallEnd","Query","_setAnimationProps","_animationProps","_animationLoop","_this$programProps","_this$programProps$vs","MODULAR_SHADERS","_this$programProps$fs","vertex_array","_evaluateAnimateUniforms","valueFunction","foundAnimated","newValue","isObjectEmpty","staticUniforms","query","beginTimeElapsedQuery","end","isResultAvailable","elapsedTime","getTimerMilliseconds","lastFrameTime","logDrawTimeout","priority","Date","now","collapsed","attributeTable","configuration","elements","values","attributeLocation","rowHeader","location","getDebugTableForVertexArray","_getDebugTableForUnif","uniformTable","_getDebugTableForUnif2","missingTable","configTable","config","attributeInfos","_table","JSON","varyingInfos","_table2","varyingInfo","getDebugTableForProgramConfiguration","isReady","attributesObject","uniformsObject","logModel","message","Model","_BaseModel","call","prototype","GL","TRIANGLES","geometryBuffers","instanced","_setModelProps","geometry","_deleteGeometryBuffers","getInstanceCount","getAttributes","setDrawMode","setVertexCount","setInstanceCount","setGeometry","buffers","indices","remappedName","constant","typedArray","Uint32Array","target","ELEMENT_ARRAY_BUFFER","getBuffersFromGeometry","normalizedAttributes","transform","_Object$assign","_opts$discard","discard","feedbackBuffers","_opts$unbindModels","unbindModels","_setFeedbackBuffers","unbindBuffers","bindBuffers","render","_feedbackBuffers","transform_feedback","setBuffers","transpileShader","targetGLSLVersion","convertVertexShaderTo300","convertFragmentShaderTo300","convertVertexShaderTo100","convertFragmentShaderTo100","TYPE_DEFINITIONS","number","validate","propType","min","array","parsePropType","propDef","getTypeOf","ShaderModule","_ref$dependencies","_ref$deprecations","deprecations","vertexShader","fragmentShader","_parseDeprecationDefinitions","propDefs","propTypes","propName","parsePropTypes","getModuleSource","moduleSource","_defaultGetUniforms","getDefines","checkDeprecations","forEach","def","shaderSource","deprecated","RegExp","old","private","MODULE_INJECTORS","_MODULE_INJECTORS","DECLARATION_INJECT_MARKER","REGEX_START_OF_MAIN","REGEX_END_OF_MAIN","fragments","_loop","fragmentData","fragmentString","replace","match","combineInjects","injects","__webpack_require__","d","__webpack_exports__","FRAGMENT_SHADER","condition","TransformFeedback","assertWebGL2Context","_Resource","stubRemovedMethods","isSupported","_this2","unused","bindOnUse","bind","_unbindBuffers","_this3","bufferName","setBuffer","_this4","_getVaryingIndex","locationOrName","_this$_getBufferParam","_getBufferParams","bufferOrParams","byteSize","byteOffset","_bindBuffer","begin","primitiveMode","POINTS","bindTransformFeedback","TRANSFORM_FEEDBACK","handle","_bindBuffers","beginTransformFeedback","endTransformFeedback","_getVaryingInfo","getVaryingInfo","bufferIndex","_this$_getBufferParam2","bindBufferRange","TRANSFORM_FEEDBACK_BUFFER","index","bindBufferBase","_createHandle","createTransformFeedback","_deleteHandle","deleteTransformFeedback","_bindHandle","Resource"],"mappings":"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","file":"3-70929710183772ddb10e.js","sourcesContent":["// Feature detection for WebGL\n//\n// Provides a function that enables simple checking of which WebGL features are\n// available in an WebGL1 or WebGL2 environment.\n\n/* eslint-disable no-inline-comments, max-len */\nimport isOldIE from './is-old-ie';\nimport assert from './assert';\n\nconst GL_VENDOR = 0x1f00;\nconst GL_RENDERER = 0x1f01;\nconst GL_VERSION = 0x1f02;\nconst GL_SHADING_LANGUAGE_VERSION = 0x8b8c;\n\n// Defines luma.gl \"feature\" names and semantics\nconst WEBGL_FEATURES = {\n  // GLSL extensions\n  GLSL_FRAG_DATA: ['WEBGL_draw_buffers', true], // TODO - name makes no sense in GLSL 3.00\n  GLSL_FRAG_DEPTH: ['EXT_frag_depth', true],\n  GLSL_DERIVATIVES: ['OES_standard_derivatives', true],\n  GLSL_TEXTURE_LOD: ['EXT_shader_texture_lod', true]\n};\n\n// Create a key-mirrored FEATURES array\nconst FEATURES = {};\nObject.keys(WEBGL_FEATURES).forEach(key => {\n  FEATURES[key] = key;\n});\n\nexport {FEATURES};\n\nfunction isWebGL2(gl) {\n  return Boolean(gl && gl._version === 2);\n}\n\nexport function getContextInfo(gl) {\n  const info = gl.getExtension('WEBGL_debug_renderer_info');\n  const vendor = gl.getParameter((info && info.UNMASKED_VENDOR_WEBGL) || GL_VENDOR);\n  const renderer = gl.getParameter((info && info.UNMASKED_RENDERER_WEBGL) || GL_RENDERER);\n  const gpuVendor = identifyGPUVendor(vendor, renderer);\n  const gpuInfo = {\n    gpuVendor,\n    vendor,\n    renderer,\n    version: gl.getParameter(GL_VERSION),\n    shadingLanguageVersion: gl.getParameter(GL_SHADING_LANGUAGE_VERSION)\n  };\n  return gpuInfo;\n}\n\nfunction identifyGPUVendor(vendor, renderer) {\n  if (vendor.match(/NVIDIA/i) || renderer.match(/NVIDIA/i)) {\n    return 'NVIDIA';\n  }\n  if (vendor.match(/INTEL/i) || renderer.match(/INTEL/i)) {\n    return 'INTEL';\n  }\n  if (\n    vendor.match(/AMD/i) ||\n    renderer.match(/AMD/i) ||\n    vendor.match(/ATI/i) ||\n    renderer.match(/ATI/i)\n  ) {\n    return 'AMD';\n  }\n  return 'UNKNOWN GPU';\n}\n\nconst compiledGlslExtensions = {};\n\n// Enables feature detection in IE11 due to a bug where gl.getExtension may return true\n// but fail to compile when the extension is enabled in the shader. Specifically,\n// the OES_standard_derivatives and WEBGL_draw_buffers extensions fails to compile in IE11 even though its included\n// in the list of supported extensions.\n// opts allows user agent to be overridden for testing\n/*\n* Inputs :\n*  gl : WebGL context\n*  cap : Key of WEBGL_FEATURES object identifying the extension\n*  opts :\n*   behavior : behavor of extension to be tested, by defualt `enable` is used\n* Returns : true, if shader is compiled successfully, false otherwise\n*/\nexport function canCompileGLGSExtension(gl, cap, opts = {}) {\n  const feature = WEBGL_FEATURES[cap];\n  assert(feature, cap);\n\n  if (!isOldIE(opts)) {\n    return true;\n  }\n\n  if (cap in compiledGlslExtensions) {\n    return compiledGlslExtensions[cap];\n  }\n\n  const extensionName = feature[0];\n  const behavior = opts.behavior || 'enable';\n  const source = `#extension GL_${extensionName} : ${behavior}\\nvoid main(void) {}`;\n\n  const shader = gl.createShader(gl.VERTEX_SHADER);\n  gl.shaderSource(shader, source);\n  gl.compileShader(shader);\n  const canCompile = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\n  gl.deleteShader(shader);\n  compiledGlslExtensions[cap] = canCompile;\n  return canCompile;\n}\n\n// TODO - cache the value\nfunction getFeature(gl, cap) {\n  const feature = WEBGL_FEATURES[cap];\n  assert(feature, cap);\n\n  // Get extension name from table\n  const extensionName = isWebGL2(gl) ? feature[1] || feature[0] : feature[0];\n\n  // Check if the value is dependent on checking an extension\n  const value =\n    typeof extensionName === 'string' ? Boolean(gl.getExtension(extensionName)) : extensionName;\n\n  assert(value === false || value === true);\n\n  return value;\n}\n\nexport function hasFeatures(gl, features) {\n  features = Array.isArray(features) ? features : [features];\n  return features.every(feature => getFeature(gl, feature));\n}\n","/* global window */\n// opts allows user agent to be overridden for testing\nexport default function isOldIE(opts = {}) {\n  const navigator = typeof window !== 'undefined' ? window.navigator || {} : {};\n  const userAgent = opts.userAgent || navigator.userAgent || '';\n  // We only care about older versions of IE (IE 11 and below). Newer versions of IE (Edge)\n  // have much better web standards support.\n  const isMSIE = userAgent.indexOf('MSIE ') !== -1;\n  const isTrident = userAgent.indexOf('Trident/') !== -1;\n  return isMSIE || isTrident;\n}\n","import {getContextInfo, hasFeatures, canCompileGLGSExtension, FEATURES} from '../utils/webgl-info';\n\nexport function getPlatformShaderDefines(gl) {\n  const debugInfo = getContextInfo(gl);\n\n  switch (debugInfo.gpuVendor.toLowerCase()) {\n    case 'nvidia':\n      return `\\\n#define NVIDIA_GPU\n// Nvidia optimizes away the calculation necessary for emulated fp64\n#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1\n`;\n\n    case 'intel':\n      return `\\\n#define INTEL_GPU\n// Intel optimizes away the calculation necessary for emulated fp64\n#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1\n// Intel's built-in 'tan' function doesn't have acceptable precision\n#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1\n// Intel GPU doesn't have full 32 bits precision in same cases, causes overflow\n#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1\n`;\n\n    case 'amd':\n      // AMD Does not eliminate fp64 code\n      return `\\\n#define AMD_GPU\n`;\n\n    default:\n      // We don't know what GPU it is, could be that the GPU driver or\n      // browser is not implementing UNMASKED_RENDERER constant and not\n      // reporting a correct name\n      return `\\\n#define DEFAULT_GPU\n// Prevent driver from optimizing away the calculation necessary for emulated fp64\n#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1\n// Intel's built-in 'tan' function doesn't have acceptable precision\n#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1\n// Intel GPU doesn't have full 32 bits precision in same cases, causes overflow\n#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1\n`;\n  }\n}\n\nexport function getVersionDefines(gl, glslVersion, isFragment) {\n  // Add shadertools defines to let shaders portably v1/v3 check for features\n  let versionDefines = `\\\n#if (__VERSION__ > 120)\n\n# define FRAG_DEPTH\n# define DERIVATIVES\n# define DRAW_BUFFERS\n# define TEXTURE_LOD\n\n#endif // __VERSION\n`;\n\n  if (hasFeatures(gl, FEATURES.GLSL_FRAG_DEPTH)) {\n    versionDefines += `\\\n// FRAG_DEPTH => gl_FragDepth is available\n#ifdef GL_EXT_frag_depth\n#extension GL_EXT_frag_depth : enable\n# define FRAG_DEPTH\n# define gl_FragDepth gl_FragDepthEXT\n#endif\n`;\n  }\n  if (\n    hasFeatures(gl, FEATURES.GLSL_DERIVATIVES) &&\n    canCompileGLGSExtension(gl, FEATURES.GLSL_DERIVATIVES)\n  ) {\n    versionDefines += `\\\n// DERIVATIVES => dxdF, dxdY and fwidth are available\n#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives : enable\n# define DERIVATIVES\n#endif\n`;\n  }\n  if (\n    hasFeatures(gl, FEATURES.GLSL_FRAG_DATA) &&\n    canCompileGLGSExtension(gl, FEATURES.GLSL_FRAG_DATA, {behavior: 'require'})\n  ) {\n    versionDefines += `\\\n// DRAW_BUFFERS => gl_FragData[] is available\n#ifdef GL_EXT_draw_buffers\n#extension GL_EXT_draw_buffers : require\n#define DRAW_BUFFERS\n#endif\n`;\n  }\n  if (hasFeatures(gl, FEATURES.GLSL_TEXTURE_LOD)) {\n    versionDefines += `\\\n// TEXTURE_LOD => texture2DLod etc are available\n#ifdef GL_EXT_shader_texture_lod\n#extension GL_EXT_shader_texture_lod : enable\n# define TEXTURE_LOD\n#define texture2DLod texture2DLodEXT\n#define texture2DProjLod texture2DProjLodEXT\n#define texture2DProjLod texture2DProjLodEXT\n#define textureCubeLod textureCubeLodEXT\n#define texture2DGrad texture2DGradEXT\n#define texture2DProjGrad texture2DProjGradEXT\n#define texture2DProjGrad texture2DProjGradEXT\n#define textureCubeGrad textureCubeGradEXT\n#endif\n`;\n  }\n  return versionDefines;\n}\n","import {VERTEX_SHADER, FRAGMENT_SHADER} from './constants';\nimport {resolveModules, getShaderModule} from './resolve-modules';\nimport {getPlatformShaderDefines, getVersionDefines} from './platform-defines';\nimport injectShader, {DECLARATION_INJECT_MARKER} from './inject-shader';\nimport {assert} from '../utils';\n/* eslint-disable max-depth, complexity */\n\nconst INJECT_SHADER_DECLARATIONS = `\\n\\n${DECLARATION_INJECT_MARKER}\\n\\n`;\n\nconst SHADER_TYPE = {\n  [VERTEX_SHADER]: 'vertex',\n  [FRAGMENT_SHADER]: 'fragment'\n};\n\nconst HOOK_FUNCTIONS = {\n  [VERTEX_SHADER]: {},\n  [FRAGMENT_SHADER]: {}\n};\n\nconst MODULE_INJECTIONS = {\n  [VERTEX_SHADER]: {},\n  [FRAGMENT_SHADER]: {}\n};\n\n// Precision prologue to inject before functions are injected in shader\n// TODO - extract any existing prologue in the fragment source and move it up...\nconst FRAGMENT_SHADER_PROLOGUE = `\\\nprecision highp float;\n\n`;\n\nexport function createShaderHook(hook, opts = {}) {\n  hook = hook.trim();\n  const [stage, signature] = hook.split(':');\n  const name = hook.replace(/\\(.+/, '');\n  HOOK_FUNCTIONS[stage][name] = Object.assign(opts, {signature});\n}\n\nexport function createModuleInjection(moduleName, opts) {\n  const {hook, injection, order = 0} = opts;\n  const shaderStage = hook.slice(0, 2);\n\n  const moduleInjections = MODULE_INJECTIONS[shaderStage];\n  moduleInjections[moduleName] = moduleInjections[moduleName] || {};\n\n  assert(!moduleInjections[moduleName][hook], 'Module injection already created');\n\n  moduleInjections[moduleName][hook] = {\n    injection,\n    order\n  };\n}\n\n// Helpful for tests\nexport function resetGlobalShaderHooks() {\n  HOOK_FUNCTIONS[VERTEX_SHADER] = {};\n  HOOK_FUNCTIONS[FRAGMENT_SHADER] = {};\n\n  MODULE_INJECTIONS[VERTEX_SHADER] = {};\n  MODULE_INJECTIONS[FRAGMENT_SHADER] = {};\n}\n\n// Inject a list of modules\nexport function assembleShaders(gl, opts) {\n  const {vs, fs} = opts;\n  const modules = resolveModules(opts.modules || []);\n  return {\n    gl,\n    vs: assembleShader(gl, Object.assign({}, opts, {source: vs, type: VERTEX_SHADER, modules})),\n    fs: assembleShader(gl, Object.assign({}, opts, {source: fs, type: FRAGMENT_SHADER, modules})),\n    getUniforms: assembleGetUniforms(modules),\n    modules: assembleModuleMap(modules)\n  };\n}\n\n// Pulls together complete source code for either a vertex or a fragment shader\n// adding prologues, requested module chunks, and any final injections.\nfunction assembleShader(\n  gl,\n  {\n    id,\n    source,\n    type,\n    modules,\n    defines = {},\n    hookFunctions = HOOK_FUNCTIONS,\n    moduleInjections = MODULE_INJECTIONS,\n    inject = {},\n    prologue = true,\n    log\n  }\n) {\n  assert(typeof source === 'string', 'shader source must be a string');\n\n  // TODO(Tarek): Supporting global hooks, remove when they're removed.\n  if (hookFunctions !== HOOK_FUNCTIONS) {\n    hookFunctions = {\n      [VERTEX_SHADER]: Object.assign(\n        {},\n        HOOK_FUNCTIONS[VERTEX_SHADER],\n        hookFunctions[VERTEX_SHADER]\n      ),\n      [FRAGMENT_SHADER]: Object.assign(\n        {},\n        HOOK_FUNCTIONS[FRAGMENT_SHADER],\n        hookFunctions[FRAGMENT_SHADER]\n      )\n    };\n  }\n\n  if (moduleInjections !== MODULE_INJECTIONS) {\n    moduleInjections = {\n      [VERTEX_SHADER]: Object.assign(\n        {},\n        MODULE_INJECTIONS[VERTEX_SHADER],\n        moduleInjections[VERTEX_SHADER]\n      ),\n      [FRAGMENT_SHADER]: Object.assign(\n        {},\n        MODULE_INJECTIONS[FRAGMENT_SHADER],\n        moduleInjections[FRAGMENT_SHADER]\n      )\n    };\n  }\n\n  const isVertex = type === VERTEX_SHADER;\n\n  const sourceLines = source.split('\\n');\n  let glslVersion = 100;\n  let versionLine = '';\n  let coreSource = source;\n  // Extract any version directive string from source.\n  // TODO : keep all pre-processor statements at the begining of the shader.\n  if (sourceLines[0].indexOf('#version ') === 0) {\n    glslVersion = 300; // TODO - regexp that matches atual version number\n    versionLine = sourceLines[0];\n    coreSource = sourceLines.slice(1).join('\\n');\n  } else {\n    versionLine = `#version ${glslVersion}`;\n  }\n\n  // Combine Module and Application Defines\n  const allDefines = {};\n  modules.forEach(module => {\n    Object.assign(allDefines, module.getDefines());\n  });\n  Object.assign(allDefines, defines);\n\n  // Add platform defines (use these to work around platform-specific bugs and limitations)\n  // Add common defines (GLSL version compatibility, feature detection)\n  // Add precision declaration for fragment shaders\n  let assembledSource = prologue\n    ? `\\\n${versionLine}\n${getShaderName({id, source, type})}\n${getShaderType({type})}\n${getPlatformShaderDefines(gl)}\n${getVersionDefines(gl, glslVersion, !isVertex)}\n${getApplicationDefines(allDefines)}\n${isVertex ? '' : FRAGMENT_SHADER_PROLOGUE}\n`\n    : `${versionLine}\n`;\n\n  // Add source of dependent modules in resolved order\n  let injectStandardStubs = false;\n  const hookInjections = {};\n  const mainInjections = {};\n\n  for (const key in inject) {\n    const injection =\n      typeof inject[key] === 'string' ? {injection: inject[key], order: 0} : inject[key];\n    if (key.match(/^(v|f)s:/)) {\n      if (key[3] === '#') {\n        mainInjections[key] = [injection];\n      } else {\n        hookInjections[key] = [injection];\n      }\n    } else {\n      // Regex injection\n      mainInjections[key] = [injection];\n    }\n  }\n\n  for (const module of modules) {\n    switch (module.name) {\n      case 'inject':\n        injectStandardStubs = true;\n        break;\n\n      default:\n        if (log) {\n          module.checkDeprecations(coreSource, log);\n        }\n        const moduleSource = module.getModuleSource(type, glslVersion);\n        // Add the module source, and a #define that declares it presence\n        assembledSource += moduleSource;\n\n        if (moduleInjections[type][module.name]) {\n          const injections = moduleInjections[type][module.name];\n          for (const key in injections) {\n            if (key.match(/^(v|f)s:#/)) {\n              mainInjections[key] = mainInjections[key] || [];\n              mainInjections[key].push(injections[key]);\n            } else {\n              hookInjections[key] = hookInjections[key] || [];\n              hookInjections[key].push(injections[key]);\n            }\n          }\n        }\n    }\n  }\n\n  // For injectShader\n  assembledSource += INJECT_SHADER_DECLARATIONS;\n\n  assembledSource += getHookFunctions(hookFunctions[type], hookInjections);\n\n  // Add the version directive and actual source of this shader\n  assembledSource += coreSource;\n\n  // Apply any requested shader injections\n  assembledSource = injectShader(assembledSource, type, mainInjections, injectStandardStubs);\n\n  return assembledSource;\n}\n\n// Returns a combined `getUniforms` covering the options for all the modules,\n// the created function will pass on options to the inidividual `getUniforms`\n// function of each shader module and combine the results into one object that\n// can be passed to setUniforms.\nfunction assembleGetUniforms(modules) {\n  return function getUniforms(opts) {\n    const uniforms = {};\n    for (const module of modules) {\n      // `modules` is already sorted by dependency level. This guarantees that\n      // modules have access to the uniforms that are generated by their dependencies.\n      const moduleUniforms = module.getUniforms(opts, uniforms);\n      Object.assign(uniforms, moduleUniforms);\n    }\n    return uniforms;\n  };\n}\n\n// Returns a map with module names as keys, resolving to their module definitions\n// The presence of a key indicates that the module is available in this program,\n// whether directly included, or through a dependency of some other module\nfunction assembleModuleMap(modules) {\n  const result = {};\n  for (const moduleName of modules) {\n    const shaderModule = getShaderModule(moduleName);\n    result[moduleName] = shaderModule;\n  }\n  return result;\n}\n\nfunction getShaderType({type}) {\n  return `\n#define SHADER_TYPE_${SHADER_TYPE[type].toUpperCase()}\n`;\n}\n\n// Generate \"glslify-compatible\" SHADER_NAME defines\n// These are understood by the GLSL error parsing function\n// If id is provided and no SHADER_NAME constant is present in source, create one\nfunction getShaderName({id, source, type}) {\n  const injectShaderName = id && typeof id === 'string' && source.indexOf('SHADER_NAME') === -1;\n  return injectShaderName\n    ? `\n#define SHADER_NAME ${id}_${SHADER_TYPE[type]}\n\n`\n    : '';\n}\n\n// Generates application defines from an object\nfunction getApplicationDefines(defines = {}) {\n  let count = 0;\n  let sourceText = '';\n  for (const define in defines) {\n    if (count === 0) {\n      sourceText += '\\n// APPLICATION DEFINES\\n';\n    }\n    count++;\n\n    const value = defines[define];\n    if (value || Number.isFinite(value)) {\n      sourceText += `#define ${define.toUpperCase()} ${defines[define]}\\n`;\n    }\n  }\n  if (count === 0) {\n    sourceText += '\\n';\n  }\n  return sourceText;\n}\n\nfunction getHookFunctions(hookFunctions, hookInjections) {\n  let result = '';\n  for (const hookName in hookFunctions) {\n    const hookFunction = hookFunctions[hookName];\n    result += `void ${hookFunction.signature} {\\n`;\n    if (hookFunction.header) {\n      result += `  ${hookFunction.header}`;\n    }\n    if (hookInjections[hookName]) {\n      const injections = hookInjections[hookName];\n      injections.sort((a, b) => a.order - b.order);\n      for (const injection of injections) {\n        result += `  ${injection.injection}\\n`;\n      }\n    }\n    if (hookFunction.footer) {\n      result += `  ${hookFunction.footer}`;\n    }\n    result += '}\\n';\n  }\n\n  return result;\n}\n","import ShaderModule from './shader-module';\nimport {assert} from '../utils';\n\nexport default class ShaderModuleRegistry {\n  constructor() {\n    this.shaderModules = {};\n    this.defaultShaderModules = [];\n  }\n\n  setDefaultShaderModules(modules) {\n    this.defaultShaderModules = this.resolveModules(modules);\n  }\n\n  getDefaultShaderModules() {\n    return this.defaultShaderModules;\n  }\n\n  registerShaderModules(shaderModuleList, {ignoreMultipleRegistrations = false} = {}) {\n    for (const shaderModule of shaderModuleList) {\n      this._registerShaderModule(shaderModule, ignoreMultipleRegistrations);\n    }\n  }\n\n  getShaderModule(moduleOrName) {\n    // Check if \"inline\" module, return it\n    if (moduleOrName instanceof ShaderModule) {\n      return moduleOrName;\n    }\n\n    // Check if module descriptor\n    if (typeof moduleOrName !== 'string') {\n      return this._registerShaderModule(moduleOrName, true);\n    }\n\n    // Module name - Look up module\n    const module = this.shaderModules[moduleOrName];\n    if (!module) {\n      assert(false, `Unknown shader module ${moduleOrName}`);\n    }\n    return module;\n  }\n\n  // registers any supplied modules, resolves any names into modules\n  // returns a list of modules\n  resolveModules(modules) {\n    return modules.map(moduleOrName => this.getShaderModule(moduleOrName));\n  }\n\n  // PRIVATE API\n\n  _registerShaderModule(module, ignoreMultipleRegistrations = false) {\n    // Check if \"inline\" module, return it\n    if (module instanceof ShaderModule) {\n      return module;\n    }\n\n    assert(module.name, 'shader module has no name');\n\n    if (!this.shaderModules[module.name] || ignoreMultipleRegistrations) {\n      // if ignoreMultipleRegistrations = true, we allow module to be re-registered\n      module = new ShaderModule(module);\n      module.dependencies = this.resolveModules(module.dependencies);\n      this.shaderModules[module.name] = module;\n    } else {\n      // TODO - instead verify that definition is not changing...\n      throw new Error(`shader module ${module.name} already registered`);\n    }\n\n    return this.shaderModules[module.name];\n  }\n}\n","import ShaderModuleRegistry from './shader-module-registry';\n\nconst shaderModuleRegistry = new ShaderModuleRegistry();\n\n/**\n * Registers an array of default shader modules. These will be concatenated\n * automatically at the end of any shader module list passed to\n * `assembleShaders` (plus `resolveModules` and `getShaderDependencies`)\n * @param {Object[]} modules - Array of shader modules\n */\nexport function setDefaultShaderModules(modules) {\n  shaderModuleRegistry.setDefaultShaderModules(modules);\n}\n\nexport function getDefaultShaderModules() {\n  return shaderModuleRegistry.getDefaultShaderModules();\n}\n\n/**\n * Registers an array of shader modules\n * @param {Object[]} shaderModuleList - Array of shader modules\n */\nexport function registerShaderModules(\n  shaderModuleList,\n  {ignoreMultipleRegistrations = false} = {}\n) {\n  shaderModuleRegistry.registerShaderModules(shaderModuleList, {ignoreMultipleRegistrations});\n}\n\n// registers any supplied modules and returns a list of module names\nexport function resolveModules(modules) {\n  modules = modules.concat(shaderModuleRegistry.defaultShaderModules);\n  modules = shaderModuleRegistry.resolveModules(modules);\n  return getShaderDependencies(modules);\n}\n\n// Looks up a moduleName among registered modules and returns definition.\n// If \"inline\" module, returns it directly\nexport function getShaderModule(moduleOrName) {\n  return shaderModuleRegistry.getShaderModule(moduleOrName);\n}\n\n/**\n * Takes a list of shader module names and returns a new list of\n * shader module names that includes all dependencies, sorted so\n * that modules that are dependencies of other modules come first.\n *\n * If the shader glsl code from the returned modules is concatenated\n * in the reverse order, it is guaranteed that all functions be resolved and\n * that all function and variable definitions come before use.\n *\n * @param {String[]} modules - Array of modules (inline modules or module names)\n * @return {String[]} - Array of modules\n */\nfunction getShaderDependencies(modules) {\n  const moduleMap = {};\n  const moduleDepth = {};\n  getDependencyGraph({modules, level: 0, moduleMap, moduleDepth});\n\n  // Return a reverse sort so that dependencies come before the modules that use them\n  return Object.keys(moduleDepth)\n    .sort((a, b) => moduleDepth[b] - moduleDepth[a])\n    .map(name => moduleMap[name]);\n}\n\n/**\n * Recursively checks module dpendencies to calculate dependency\n * level of each module.\n *\n * @param {String[]} modules - Array of modules\n * @param {Number} level - Current level\n * @return {result} - Map of module name to its level\n */\n// Adds another level of dependencies to the result map\nfunction getDependencyGraph({modules, level, moduleMap, moduleDepth}) {\n  if (level >= 5) {\n    throw new Error('Possible loop in shader dependency graph');\n  }\n\n  // Update level on all current modules\n  for (const module of modules) {\n    moduleMap[module.name] = module;\n    if (moduleDepth[module.name] === undefined || moduleDepth[module.name] < level) {\n      moduleDepth[module.name] = level;\n    }\n  }\n\n  // Recurse\n  for (const module of modules) {\n    if (module.dependencies) {\n      getDependencyGraph({modules: module.dependencies, level: level + 1, moduleMap, moduleDepth});\n    }\n  }\n}\n\nexport const TEST_EXPORTS = {\n  getShaderDependencies,\n  getDependencyGraph\n};\n","import GL from '@luma.gl/constants';\nimport {Buffer} from '@luma.gl/webgl';\nimport {assert} from '../utils';\n\n// Support for mapping new geometries with glTF attribute names to \"classic\" luma.gl shader names\nconst GLTF_TO_LUMA_ATTRIBUTE_MAP = {\n  POSITION: 'positions',\n  NORMAL: 'normals',\n  COLOR_0: 'colors',\n  TEXCOORD_0: 'texCoords',\n  TEXCOORD_1: 'texCoords1',\n  TEXCOORD_2: 'texCoords2'\n};\n\nexport function getBuffersFromGeometry(gl, geometry, options) {\n  const buffers = {};\n  let indices = geometry.indices;\n\n  for (const name in geometry.attributes) {\n    const attribute = geometry.attributes[name];\n    const remappedName = mapAttributeName(name, options);\n\n    if (name === 'indices') {\n      indices = attribute;\n    } else if (attribute.constant) {\n      buffers[remappedName] = attribute.value;\n    } else {\n      const typedArray = attribute.value;\n      // Create accessor by copying the attribute and removing `value``\n      const accessor = {...attribute};\n      delete accessor.value;\n      buffers[remappedName] = [new Buffer(gl, typedArray), accessor];\n\n      inferAttributeAccessor(name, accessor);\n    }\n  }\n\n  if (indices) {\n    const data = indices.value || indices;\n    assert(\n      data instanceof Uint16Array || data instanceof Uint32Array,\n      'attribute array for \"indices\" must be of integer type'\n    );\n    const accessor = {\n      size: 1,\n      isIndexed: indices.isIndexed === undefined ? true : indices.isIndexed\n    };\n    buffers.indices = [\n      new Buffer(gl, {\n        data,\n        target: GL.ELEMENT_ARRAY_BUFFER\n      }),\n      accessor\n    ];\n  }\n\n  return buffers;\n}\n\nfunction mapAttributeName(name, options) {\n  const {attributeMap = GLTF_TO_LUMA_ATTRIBUTE_MAP} = options || {};\n  return (attributeMap && attributeMap[name]) || name;\n}\n\n// Check for well known attribute names\n// eslint-disable-next-line complexity\nexport function inferAttributeAccessor(attributeName, attribute) {\n  let category;\n  switch (attributeName) {\n    case 'texCoords':\n    case 'texCoord1':\n    case 'texCoord2':\n    case 'texCoord3':\n      category = 'uvs';\n      break;\n    case 'vertices':\n    case 'positions':\n    case 'normals':\n    case 'pickingColors':\n      category = 'vectors';\n      break;\n    default:\n  }\n\n  // Check for categorys\n  switch (category) {\n    case 'vectors':\n      attribute.size = attribute.size || 3;\n      break;\n    case 'uvs':\n      attribute.size = attribute.size || 2;\n      break;\n    default:\n  }\n\n  assert(Number.isFinite(attribute.size), `attribute ${attributeName} needs size`);\n}\n","import {assembleShaders} from '@luma.gl/shadertools';\nimport {Program} from '@luma.gl/webgl';\n\nexport default class ProgramManager {\n  static getDefaultProgramManager(gl) {\n    gl.luma = gl.luma || {};\n    gl.luma.defaultProgramManager = gl.luma.defaultProgramManager || new ProgramManager(gl);\n\n    return gl.luma.defaultProgramManager;\n  }\n\n  constructor(gl) {\n    this.gl = gl;\n\n    this._programCache = {};\n    this._getUniforms = {};\n    this._registeredModules = {};\n    this._moduleInjections = {\n      vs: {},\n      fs: {}\n    };\n    this._hookFunctions = {\n      vs: {},\n      fs: {}\n    };\n    this._defaultModules = [];\n\n    this._hashes = {};\n    this._hashCounter = 0;\n    this.stateHash = 0; // Used change hashing if hooks are modified\n    this._useCounts = {};\n  }\n\n  addDefaultModule(module) {\n    if (!this._defaultModules.find(m => m.name === module.name)) {\n      this._defaultModules.push(module);\n    }\n\n    this.stateHash++;\n  }\n\n  removeDefaultModule(module) {\n    const moduleName = typeof module === 'string' ? module : module.name;\n    this._defaultModules = this._defaultModules.filter(m => m.name !== moduleName);\n    this.stateHash++;\n  }\n\n  addModuleInjection(module, opts) {\n    const moduleName = typeof module === 'string' ? module : module.name;\n    const {hook, injection, order = 0} = opts;\n    const shaderStage = hook.slice(0, 2);\n\n    const moduleInjections = this._moduleInjections[shaderStage];\n    moduleInjections[moduleName] = moduleInjections[moduleName] || {};\n\n    moduleInjections[moduleName][hook] = {\n      injection,\n      order\n    };\n\n    this.stateHash++;\n  }\n\n  addShaderHook(hook, opts = {}) {\n    hook = hook.trim();\n    const [stage, signature] = hook.split(':');\n    const name = hook.replace(/\\(.+/, '');\n    this._hookFunctions[stage][name] = Object.assign(opts, {signature});\n\n    this.stateHash++;\n  }\n\n  get(props = {}) {\n    const {vs = '', fs = '', defines = {}, inject = {}, varyings = [], bufferMode = 0x8c8d} = props; // varyings/bufferMode for xform feedback, 0x8c8d = SEPARATE_ATTRIBS\n\n    const modules = this._getModuleList(props.modules); // Combine with default modules\n\n    const vsHash = this._getHash(vs);\n    const fsHash = this._getHash(fs);\n    const moduleHashes = modules.map(m => this._getHash(typeof m === 'string' ? m : m.name)).sort();\n    const varyingHashes = varyings.map(v => this._getHash(v));\n\n    const defineKeys = Object.keys(defines).sort();\n    const injectKeys = Object.keys(inject).sort();\n    const defineHashes = [];\n    const injectHashes = [];\n\n    for (const key of defineKeys) {\n      defineHashes.push(this._getHash(key));\n      defineHashes.push(this._getHash(defines[key]));\n    }\n\n    for (const key of injectKeys) {\n      defineHashes.push(this._getHash(key));\n      defineHashes.push(this._getHash(inject[key]));\n    }\n\n    const hash = `${vsHash}/${fsHash}D${defineHashes.join('/')}M${moduleHashes.join(\n      '/'\n    )}I${injectHashes.join('/')}V${varyingHashes.join('/')}H${this.stateHash}B${bufferMode}`;\n\n    if (!this._programCache[hash]) {\n      const assembled = assembleShaders(this.gl, {\n        vs,\n        fs,\n        modules,\n        inject,\n        defines,\n        hookFunctions: this._hookFunctions,\n        moduleInjections: this._moduleInjections\n      });\n\n      this._programCache[hash] = new Program(this.gl, {\n        hash,\n        vs: assembled.vs,\n        fs: assembled.fs,\n        varyings,\n        bufferMode\n      });\n\n      this._getUniforms[hash] = assembled.getUniforms || (x => {});\n      this._useCounts[hash] = 0;\n    }\n\n    this._useCounts[hash]++;\n\n    return this._programCache[hash];\n  }\n\n  getUniforms(program) {\n    return this._getUniforms[program.hash] || null;\n  }\n\n  release(program) {\n    const hash = program.hash;\n    this._useCounts[hash]--;\n\n    if (this._useCounts[hash] === 0) {\n      this._programCache[hash].delete();\n      delete this._programCache[hash];\n      delete this._getUniforms[hash];\n      delete this._useCounts[hash];\n    }\n  }\n\n  _getHash(key) {\n    if (this._hashes[key] === undefined) {\n      this._hashes[key] = this._hashCounter++;\n    }\n\n    return this._hashes[key];\n  }\n\n  // Dedup and combine with default modules\n  _getModuleList(appModules = []) {\n    const modules = new Array(this._defaultModules.length + appModules.length);\n    const seen = {};\n    let count = 0;\n\n    for (let i = 0, len = this._defaultModules.length; i < len; ++i) {\n      const module = this._defaultModules[i];\n      const name = typeof module === 'string' ? module : module.name;\n      modules[count++] = module;\n      seen[name] = true;\n    }\n\n    for (let i = 0, len = appModules.length; i < len; ++i) {\n      const module = appModules[i];\n      const name = typeof module === 'string' ? module : module.name;\n      if (!seen[name]) {\n        modules[count++] = module;\n        seen[name] = true;\n      }\n    }\n\n    modules.length = count;\n\n    return modules;\n  }\n}\n","// TODO / DEPRECATED - delete when confident that probe.gl logging implements all opts\n/* eslint-disable no-console */\nfunction formatArrayValue(v, opts) {\n  const {maxElts = 16, size = 1} = opts;\n  let string = '[';\n  for (let i = 0; i < v.length && i < maxElts; ++i) {\n    if (i > 0) {\n      string += `,${i % size === 0 ? ' ' : ''}`;\n    }\n    string += formatValue(v[i], opts);\n  }\n  const terminator = v.length > maxElts ? '...' : ']';\n  return `${string}${terminator}`;\n}\n\nexport function formatValue(v, opts = {}) {\n  const EPSILON = 1e-16;\n  const {isInteger = false} = opts;\n  if (Array.isArray(v) || ArrayBuffer.isView(v)) {\n    return formatArrayValue(v, opts);\n  }\n  if (!Number.isFinite(v)) {\n    return String(v);\n  }\n  if (Math.abs(v) < EPSILON) {\n    return isInteger ? '0' : '0.';\n  }\n  if (isInteger) {\n    return v.toFixed(0);\n  }\n  if (Math.abs(v) > 100 && Math.abs(v) < 10000) {\n    return v.toFixed(0);\n  }\n  const string = v.toPrecision(2);\n  const decimal = string.indexOf('.0');\n  return decimal === string.length - 2 ? string.slice(0, -1) : string;\n}\n","import Buffer from '../classes/buffer';\nimport {getKey} from '../webgl-utils';\nimport {getCompositeGLType} from '../webgl-utils/attribute-utils';\nimport {formatValue} from '../utils';\n\n// Creates object suitable as input for console.table\nexport function getDebugTableForVertexArray({vertexArray, header = 'Attributes'} = {}) {\n  if (!vertexArray.configuration) {\n    return {};\n  }\n\n  const table = {}; // {[header]: {}};\n\n  // Add index (elements) if available\n  if (vertexArray.elements) {\n    // const elements = Object.assign({size: 1}, vertexArray.elements);\n    table.ELEMENT_ARRAY_BUFFER = getDebugTableRow(vertexArray, vertexArray.elements, null, header);\n  }\n\n  // Add used attributes\n  const attributes = vertexArray.values;\n\n  for (const attributeLocation in attributes) {\n    const info = vertexArray._getAttributeInfo(attributeLocation);\n    if (info) {\n      let rowHeader = `${attributeLocation}: ${info.name}`;\n      const accessor = vertexArray.accessors[info.location];\n      if (accessor) {\n        rowHeader = `${attributeLocation}: ${getGLSLDeclaration(info.name, accessor)}`;\n      }\n      table[rowHeader] = getDebugTableRow(\n        vertexArray,\n        attributes[attributeLocation],\n        accessor,\n        header\n      );\n    }\n  }\n\n  return table;\n}\n\n/* eslint-disable max-statements */\nfunction getDebugTableRow(vertexArray, attribute, accessor, header) {\n  const {gl} = vertexArray;\n\n  if (!attribute) {\n    return {\n      [header]: 'null',\n      'Format ': 'N/A'\n    };\n  }\n\n  let type = 'NOT PROVIDED';\n  let size = 'N/A';\n  let verts = 'N/A';\n  let bytes = 'N/A';\n\n  let isInteger;\n  let marker;\n  let value;\n\n  if (accessor) {\n    type = accessor.type;\n    size = accessor.size;\n\n    // Generate a type name by dropping Array from Float32Array etc.\n    type = String(type).replace('Array', '');\n\n    // Look for 'nt' to detect integer types, e.g. Int32Array, Uint32Array\n    isInteger = type.indexOf('nt') !== -1;\n  }\n\n  if (attribute instanceof Buffer) {\n    const buffer = attribute;\n\n    const {data, modified} = buffer.getDebugData();\n    marker = modified ? '*' : '';\n\n    value = data;\n    bytes = buffer.byteLength;\n    verts = bytes / data.BYTES_PER_ELEMENT / size;\n\n    let format;\n\n    if (accessor) {\n      const instanced = accessor.divisor > 0;\n      format = `${instanced ? 'I ' : 'P '} ${verts} (x${size}=${bytes} bytes ${getKey(gl, type)})`;\n    } else {\n      // element buffer\n      isInteger = true;\n      format = `${bytes} bytes`;\n    }\n\n    return {\n      [header]: `${marker}${formatValue(value, {size, isInteger})}`,\n      'Format ': format\n    };\n  }\n\n  // CONSTANT VALUE\n  value = attribute;\n  size = attribute.length;\n  // Generate a type name by dropping Array from Float32Array etc.\n  type = String(attribute.constructor.name).replace('Array', '');\n  // Look for 'nt' to detect integer types, e.g. Int32Array, Uint32Array\n  isInteger = type.indexOf('nt') !== -1;\n\n  return {\n    [header]: `${formatValue(value, {size, isInteger})} (constant)`,\n    'Format ': `${size}x${type} (constant)`\n  };\n}\n/* eslint-ensable max-statements */\n\nfunction getGLSLDeclaration(name, accessor) {\n  const {type, size} = accessor;\n  const typeAndName = getCompositeGLType(type, size);\n  return typeAndName ? `${name} (${typeAndName.name})` : name;\n}\n","import {formatValue, assert} from '../utils';\n\n// Prepares a table suitable for console.table\n/* eslint-disable max-statements, complexity */\nexport function getDebugTableForUniforms({\n  header = 'Uniforms',\n  program,\n  uniforms,\n  undefinedOnly = false\n} = {}) {\n  assert(program);\n\n  const SHADER_MODULE_UNIFORM_REGEXP = '.*_.*';\n  const PROJECT_MODULE_UNIFORM_REGEXP = '.*Matrix'; // TODO - Use explicit list\n\n  const uniformLocations = program._uniformSetters;\n  const table = {}; // {[header]: {}};\n\n  // Add program's provided uniforms (in alphabetical order)\n  const uniformNames = Object.keys(uniformLocations).sort();\n\n  let count = 0;\n\n  // First add non-underscored uniforms (assumed not coming from shader modules)\n  for (const uniformName of uniformNames) {\n    if (\n      !uniformName.match(SHADER_MODULE_UNIFORM_REGEXP) &&\n      !uniformName.match(PROJECT_MODULE_UNIFORM_REGEXP)\n    ) {\n      if (addUniformToTable({table, header, uniforms, uniformName, undefinedOnly})) {\n        count++;\n      }\n    }\n  }\n\n  // add underscored uniforms (assumed from shader modules)\n  for (const uniformName of uniformNames) {\n    if (uniformName.match(PROJECT_MODULE_UNIFORM_REGEXP)) {\n      if (addUniformToTable({table, header, uniforms, uniformName, undefinedOnly})) {\n        count++;\n      }\n    }\n  }\n\n  for (const uniformName of uniformNames) {\n    if (!table[uniformName]) {\n      if (addUniformToTable({table, header, uniforms, uniformName, undefinedOnly})) {\n        count++;\n      }\n    }\n  }\n\n  // Create a table of unused uniforms\n  let unusedCount = 0;\n  const unusedTable = {};\n  if (!undefinedOnly) {\n    for (const uniformName in uniforms) {\n      const uniform = uniforms[uniformName];\n      if (!table[uniformName]) {\n        unusedCount++;\n        unusedTable[uniformName] = {\n          Type: `NOT USED: ${uniform}`,\n          [header]: formatValue(uniform)\n        };\n      }\n    }\n  }\n\n  return {table, count, unusedTable, unusedCount};\n}\n\n// Helper\nfunction addUniformToTable({table, header, uniforms, uniformName, undefinedOnly}) {\n  const value = uniforms[uniformName];\n  const isDefined = isUniformDefined(value);\n  if (!undefinedOnly || !isDefined) {\n    table[uniformName] = {\n      // Add program's unprovided uniforms\n      [header]: isDefined ? formatValue(value) : 'N/A',\n      'Uniform Type': isDefined ? value : 'NOT PROVIDED'\n    };\n    return true;\n  }\n  return false;\n}\n\nfunction isUniformDefined(value) {\n  return value !== undefined && value !== null;\n}\n","import {getCompositeGLType} from '../webgl-utils/attribute-utils';\n\nexport function getDebugTableForProgramConfiguration(config) {\n  const table = {};\n\n  const header = `Accessors for ${config.id}`;\n\n  for (const attributeInfo of config.attributeInfos) {\n    if (attributeInfo) {\n      const glslDeclaration = getGLSLDeclaration(attributeInfo);\n      table[`in ${glslDeclaration}`] = {[header]: JSON.stringify(attributeInfo.accessor)};\n    }\n  }\n\n  for (const varyingInfo of config.varyingInfos) {\n    if (varyingInfo) {\n      const glslDeclaration = getGLSLDeclaration(varyingInfo);\n      table[`out ${glslDeclaration}`] = {[header]: JSON.stringify(varyingInfo.accessor)};\n    }\n  }\n\n  return table;\n}\n\nfunction getGLSLDeclaration(attributeInfo) {\n  const {type, size} = attributeInfo.accessor;\n  const typeAndName = getCompositeGLType(type, size);\n  if (typeAndName) {\n    return `${typeAndName.name} ${attributeInfo.name}`;\n  }\n  return attributeInfo.name;\n}\n","import seer from 'seer';\n\nimport {window} from '../utils';\n\nconst models = {};\n\n/**\n * Add a model to our cache indexed by id\n */\nexport const addModel = model => {\n  if (models[model.id]) {\n    return;\n  }\n  models[model.id] = model;\n\n  seer.listItem('luma.gl', model.id);\n};\n\n/**\n * Log a model uniforms and attributes.\n */\nexport const logModel = (model, uniforms) => {\n  if (!seer.isReady() || seer.throttle(`luma.gl:${model.id}`, 1e3)) {\n    return;\n  }\n\n  const attributesObject = model.geometry\n    ? Object.assign({}, model.geometry.attributes, model.attributes)\n    : model.attributes;\n  const uniformsObject = Object.assign({}, model.uniforms, uniforms);\n\n  seer.multiUpdate('luma.gl', model.id, [\n    {path: 'objects.uniforms', data: uniformsObject},\n    {path: 'objects.attributes', data: attributesObject}\n  ]);\n};\n\n/**\n * Remove a previously set model from the cache\n */\nexport const removeModel = id => {\n  delete models[id];\n  seer.deleteItem('luma.gl', id);\n};\n\n/**\n * Recursively traverse an object given a path of properties and set the given value\n */\nconst recursiveSet = (obj, path, value) => {\n  if (!obj) {\n    return;\n  }\n\n  if (path.length > 1) {\n    recursiveSet(obj[path[0]], path.slice(1), value);\n  } else {\n    obj[path[0]] = value;\n  }\n};\n\nconst overrides = new Map();\n\n/**\n * Create an override on the specify layer, indexed by a valuePath array.\n * Do nothing in case Seer as not been initialized to prevent any preformance drawback.\n */\nexport const setOverride = (id, valuePath, value) => {\n  if (!window.__SEER_INITIALIZED__) {\n    return;\n  }\n\n  if (!overrides.has(id)) {\n    overrides.set(id, new Map());\n  }\n\n  const uniforms = overrides.get(id);\n  uniforms.set(valuePath, value);\n};\n\n/**\n * Apply overrides to a specific model's uniforms\n */\nexport const getOverrides = (id, uniforms) => {\n  if (!window.__SEER_INITIALIZED__ || !id) {\n    return;\n  }\n\n  const overs = overrides.get(id);\n  if (!overs) {\n    return;\n  }\n\n  overs.forEach((value, valuePath) => {\n    recursiveSet(uniforms, valuePath, value);\n  });\n};\n\n/**\n * Listen for luma.gl edit events\n */\nseer.listenFor('luma.gl', payload => {\n  const model = models[payload.itemKey];\n  if (!model || payload.type !== 'edit' || payload.valuePath[0] !== 'uniforms') {\n    return;\n  }\n\n  const valuePath = payload.valuePath.slice(1);\n  setOverride(payload.itemKey, valuePath, payload.value);\n\n  const uniforms = model.getUniforms();\n  recursiveSet(uniforms, valuePath, payload.value);\n  model.setUniforms(uniforms);\n});\n","/* eslint-disable complexity */\n// Shared code between Model and MeshModel\nimport ProgramManager from '../resource-management/program-manager';\nimport {isWebGL, Query, Program, VertexArray, clear} from '@luma.gl/webgl';\nimport {MODULAR_SHADERS} from '@luma.gl/shadertools';\nimport {\n  getDebugTableForUniforms,\n  getDebugTableForVertexArray,\n  getDebugTableForProgramConfiguration\n} from '@luma.gl/webgl';\nimport {addModel, removeModel, logModel, getOverrides} from '../debug/seer-integration';\nimport {log, isObjectEmpty, uid, assert} from '../utils';\n\nconst LOG_DRAW_PRIORITY = 2;\nconst LOG_DRAW_TIMEOUT = 10000;\n\n// Model abstract O3D Class\nexport default class BaseModel {\n  constructor(gl, props = {}) {\n    assert(isWebGL(gl));\n    const {id = uid('base-model')} = props;\n    this.id = id;\n    this.gl = gl;\n    this.id = props.id || uid('Model');\n    this.lastLogTime = 0; // TODO - move to probe.gl\n    this.initialize(props);\n  }\n\n  initialize(props) {\n    this.props = {};\n\n    if (props.shaderCache) {\n      log.warn('ShaderCache property is deprecated')();\n    }\n\n    this.programManager = props.programManager || ProgramManager.getDefaultProgramManager(this.gl);\n    this._programManagerState = -1;\n    this._managedProgram = false;\n\n    const {program = null, vs, fs, modules, defines, inject, varyings, bufferMode} = props;\n\n    this.programProps = {program, vs, fs, modules, defines, inject, varyings, bufferMode};\n    this.program = null;\n    this.vertexArray = null;\n    this._programDirty = true;\n\n    // Initialize state\n    this.userData = {};\n    this.needsRedraw = true;\n\n    // Attributes and buffers\n    // Model manages auto Buffer creation from typed arrays\n    this._attributes = {}; // All attributes\n    this.attributes = {}; // User defined attributes\n\n    // Model manages uniform animation\n    this.uniforms = {};\n    this.animatedUniforms = {};\n    this.animated = false;\n    this.animationLoop = null; // if set, used as source for animationProps\n\n    this.timerQueryEnabled = false;\n    this.timeElapsedQuery = undefined;\n    this.lastQueryReturned = true;\n\n    this.stats = {\n      accumulatedFrameTime: 0,\n      averageFrameTime: 0,\n      profileFrameCount: 0\n    };\n\n    // picking options\n    this.pickable = true;\n\n    this._checkProgram();\n\n    this._setBaseModelProps(props);\n\n    this.setUniforms(\n      Object.assign(\n        {},\n        this.getModuleUniforms(props.moduleSettings) // Get unforms for supplied parameters\n      )\n    );\n  }\n\n  setProps(props) {\n    this._setBaseModelProps(props);\n  }\n\n  delete() {\n    // delete all attributes created by this model\n    // TODO - should buffer deletes be handled by vertex array?\n    for (const key in this._attributes) {\n      if (this._attributes[key] !== this.attributes[key]) {\n        this._attributes[key].delete();\n      }\n    }\n\n    if (this._managedProgram) {\n      this.programManager.release(this.program);\n    }\n\n    this.vertexArray.delete();\n\n    removeModel(this.id);\n  }\n\n  // GETTERS\n\n  isAnimated() {\n    return this.animated;\n  }\n\n  getProgram() {\n    return this.program;\n  }\n\n  setProgram(props) {\n    this.programProps = Object.assign({}, props);\n    this._programDirty = true;\n  }\n\n  getUniforms() {\n    return this.uniforms;\n  }\n\n  // SETTERS\n\n  // TODO - should actually set the uniforms\n  setUniforms(uniforms = {}) {\n    // Let Seer override edited uniforms\n    uniforms = Object.assign({}, uniforms);\n    getOverrides(this.id, uniforms);\n\n    // Resolve any animated uniforms so that we have an initial value\n    uniforms = this._extractAnimatedUniforms(uniforms);\n\n    Object.assign(this.uniforms, uniforms);\n\n    return this;\n  }\n\n  getModuleUniforms(opts) {\n    this._checkProgram();\n\n    const getUniforms = this.programManager.getUniforms(this.program);\n\n    if (getUniforms) {\n      return getUniforms(opts);\n    }\n\n    return {};\n  }\n\n  updateModuleSettings(opts) {\n    const uniforms = this.getModuleUniforms(opts || {});\n    return this.setUniforms(uniforms);\n  }\n\n  // DRAW CALLS\n\n  clear(opts) {\n    clear(this.program.gl, opts);\n    return this;\n  }\n\n  /* eslint-disable max-statements  */\n  drawGeometry(opts = {}) {\n    // Lazy update program and vertex array\n    this._checkProgram();\n\n    const {\n      moduleSettings = null,\n      framebuffer,\n      uniforms = {},\n      attributes = {},\n      transformFeedback = this.transformFeedback,\n      parameters = {},\n      vertexArray = this.vertexArray,\n      animationProps\n    } = opts;\n\n    addModel(this);\n\n    // Update model with any just provided attributes, settings or uniforms\n    this.setAttributes(attributes);\n    this.updateModuleSettings(moduleSettings);\n    this.setUniforms(uniforms);\n\n    // Animate any function valued uniforms\n    this._refreshAnimationProps(animationProps);\n\n    const logPriority = this._logDrawCallStart(2);\n\n    const drawParams = this.vertexArray.getDrawParams(this.props);\n    if (drawParams.isInstanced && !this.isInstanced) {\n      log.warn('Found instanced attributes on non-instanced model', this.id)();\n    }\n\n    const {isIndexed, indexType, indexOffset} = drawParams;\n    const {isInstanced, instanceCount} = this;\n\n    const noop = () => {};\n    const {onBeforeRender = noop, onAfterRender = noop} = this.props;\n\n    onBeforeRender();\n\n    this._timerQueryStart();\n\n    this.program.setUniforms(this.uniforms);\n\n    const didDraw = this.program.draw(\n      Object.assign({}, opts, {\n        logPriority,\n        uniforms: null, // Already set (may contain \"function values\" not understood by Program)\n        framebuffer,\n        parameters,\n        drawMode: this.getDrawMode(),\n        vertexCount: this.getVertexCount(),\n        vertexArray,\n        transformFeedback,\n        isIndexed,\n        indexType,\n        isInstanced,\n        instanceCount,\n        offset: isIndexed ? indexOffset : 0\n      })\n    );\n\n    this._timerQueryEnd();\n\n    onAfterRender();\n\n    this._logDrawCallEnd(logPriority, vertexArray, framebuffer);\n\n    return didDraw;\n  }\n  /* eslint-enable max-statements  */\n\n  // PRIVATE METHODS\n\n  // eslint-disable-next-line max-statements, complexity\n  _setBaseModelProps(props) {\n    Object.assign(this.props, props);\n\n    if ('uniforms' in props) {\n      this.setUniforms(props.uniforms);\n    }\n\n    if ('pickable' in props) {\n      this.pickable = props.pickable;\n    }\n\n    // if ('onBeforeRender' in props) {}\n    // if ('onAfterRender' in props) {}\n\n    // Experimental props\n    if ('timerQueryEnabled' in props) {\n      this.timerQueryEnabled = props.timerQueryEnabled && Query.isSupported(this.gl, ['timers']);\n      if (props.timerQueryEnabled && !this.timerQueryEnabled) {\n        log.warn('GPU timer not supported')();\n      }\n    }\n\n    if ('_animationProps' in props) {\n      this._setAnimationProps(props._animationProps);\n    }\n\n    if ('_animationLoop' in props) {\n      this.animationLoop = props._animationLoop;\n    }\n  }\n\n  _checkProgram(shaderCache = null) {\n    const needsUpdate =\n      this._programDirty || this.programManager.stateHash !== this._programManagerState;\n\n    if (!needsUpdate) {\n      return;\n    }\n\n    let {program} = this.programProps;\n\n    if (program) {\n      this._managedProgram = false;\n    } else {\n      const {\n        // TODO(Tarek): Are these actually used anywhere?\n        vs = MODULAR_SHADERS.vs,\n        fs = MODULAR_SHADERS.fs,\n        modules,\n        inject,\n        defines,\n        varyings,\n        bufferMode\n      } = this.programProps;\n      program = this.programManager.get({vs, fs, modules, inject, defines, varyings, bufferMode});\n      if (this.program && this._managedProgram) {\n        this.programManager.release(this.program);\n      }\n      this._programManagerState = this.programManager.stateHash;\n      this._managedProgram = true;\n    }\n\n    assert(program instanceof Program, 'Model needs a program');\n\n    this._programDirty = false;\n\n    if (program === this.program) {\n      return;\n    }\n\n    this.program = program;\n\n    if (this.vertexArray) {\n      this.vertexArray.setProps({program: this.program, attributes: this.vertexArray.attributes});\n    } else {\n      this.vertexArray = new VertexArray(this.gl, {program: this.program});\n    }\n\n    // Make sure we have some reasonable default uniforms in place\n    this.setUniforms(\n      Object.assign(\n        {},\n        this.getModuleUniforms() // Get all default uniforms,\n      )\n    );\n  }\n\n  // Refreshes animated uniforms, attempting to get animated props from animationLoop if registered\n  _refreshAnimationProps(animationProps) {\n    // Try to read animationProps\n    animationProps = animationProps || (this.animationLoop && this.animationLoop.animationProps);\n    if (animationProps) {\n      this._setAnimationProps(animationProps);\n    }\n  }\n\n  // Calculate new values for any function uniforms based on supplied animationProps\n  _evaluateAnimateUniforms(animationProps) {\n    if (!this.animated) {\n      return {};\n    }\n    const animatedUniforms = {};\n    for (const uniformName in this.animatedUniforms) {\n      const valueFunction = this.animatedUniforms[uniformName];\n      animatedUniforms[uniformName] = valueFunction(animationProps);\n    }\n    return animatedUniforms;\n  }\n\n  // Extracts a list of function valued uniforms, so we can update them before each draw call\n  // Also removes such uniforms from the returned list\n  _extractAnimatedUniforms(uniforms) {\n    let foundAnimated = false;\n\n    // Keep our animatedUniforms map up-to-date\n    for (const uniformName in uniforms) {\n      const newValue = uniforms[uniformName];\n      if (typeof newValue === 'function') {\n        this.animatedUniforms[uniformName] = newValue;\n        foundAnimated = true;\n      } else {\n        delete this.animatedUniforms[uniformName];\n      }\n    }\n\n    // Update animated flag: `Model` is animated if any uniforms are animated (i.e. functions)\n    this.animated = !isObjectEmpty(this.animatedUniforms);\n\n    if (!foundAnimated) {\n      return uniforms;\n    }\n\n    // If animated uniforms were found, remove them from ordinary uniform list\n    // `Program` class can't (and shouldn't) handle function valued uniforms\n    const staticUniforms = {};\n    for (const uniformName in uniforms) {\n      if (!this.animatedUniforms[uniformName]) {\n        staticUniforms[uniformName] = uniforms[uniformName];\n      }\n    }\n    return staticUniforms;\n  }\n\n  // Timer Queries\n\n  _timerQueryStart() {\n    if (this.timerQueryEnabled === true) {\n      if (!this.timeElapsedQuery) {\n        this.timeElapsedQuery = new Query(this.gl);\n      }\n      if (this.lastQueryReturned) {\n        this.lastQueryReturned = false;\n        this.timeElapsedQuery.beginTimeElapsedQuery();\n      }\n    }\n  }\n\n  _timerQueryEnd() {\n    if (this.timerQueryEnabled === true) {\n      this.timeElapsedQuery.end();\n      // TODO: Skip results if 'gl.getParameter(this.ext.GPU_DISJOINT_EXT)' returns false\n      // should this be incorporated into Query object?\n      if (this.timeElapsedQuery.isResultAvailable()) {\n        this.lastQueryReturned = true;\n        const elapsedTime = this.timeElapsedQuery.getTimerMilliseconds();\n\n        // Update stats (e.g. for seer)\n        this.stats.lastFrameTime = elapsedTime;\n        this.stats.accumulatedFrameTime += elapsedTime;\n        this.stats.profileFrameCount++;\n        this.stats.averageFrameTime =\n          this.stats.accumulatedFrameTime / this.stats.profileFrameCount;\n\n        // Log stats\n        log.log(\n          LOG_DRAW_PRIORITY,\n          `\\\nGPU time ${this.program.id}: ${this.stats.lastFrameTime}ms \\\naverage ${this.stats.averageFrameTime}ms \\\naccumulated: ${this.stats.accumulatedFrameTime}ms \\\ncount: ${this.stats.profileFrameCount}`\n        )();\n      }\n    }\n  }\n\n  _logDrawCallStart(priority) {\n    const logDrawTimeout = priority > 3 ? 0 : LOG_DRAW_TIMEOUT;\n    if (log.priority < priority || Date.now() - this.lastLogTime < logDrawTimeout) {\n      return undefined;\n    }\n\n    this.lastLogTime = Date.now();\n\n    log.group(LOG_DRAW_PRIORITY, `>>> DRAWING MODEL ${this.id}`, {collapsed: log.priority <= 2})();\n\n    return priority;\n  }\n\n  _logDrawCallEnd(priority, vertexArray, uniforms, framebuffer) {\n    // HACK: priority === undefined means logDrawCallStart didn't run\n    if (priority === undefined) {\n      return;\n    }\n\n    const attributeTable = getDebugTableForVertexArray({\n      vertexArray,\n      header: `${this.id} attributes`,\n      attributes: this._attributes\n    });\n\n    const {table: uniformTable, unusedTable, unusedCount} = getDebugTableForUniforms({\n      header: `${this.id} uniforms`,\n      program: this.program,\n      uniforms: Object.assign({}, this.program.uniforms, uniforms)\n    });\n\n    // log missing uniforms\n    const {table: missingTable, count: missingCount} = getDebugTableForUniforms({\n      header: `${this.id} uniforms`,\n      program: this.program,\n      uniforms: Object.assign({}, this.program.uniforms, uniforms),\n      undefinedOnly: true\n    });\n\n    if (missingCount > 0) {\n      log.log('MISSING UNIFORMS', Object.keys(missingTable))();\n      // log.table(priority, missingTable)();\n    }\n    if (unusedCount > 0) {\n      log.log('UNUSED UNIFORMS', Object.keys(unusedTable))();\n      // log.log(priority, 'Unused uniforms ', unusedTable)();\n    }\n\n    const configTable = getDebugTableForProgramConfiguration(this.vertexArray.configuration);\n\n    log.table(priority, attributeTable)();\n\n    log.table(priority, uniformTable)();\n\n    log.table(priority + 1, configTable)();\n\n    logModel(this, uniforms);\n\n    if (framebuffer) {\n      framebuffer.log({priority: LOG_DRAW_PRIORITY, message: `Rendered to ${framebuffer.id}`});\n    }\n\n    log.groupEnd(LOG_DRAW_PRIORITY, `>>> DRAWING MODEL ${this.id}`)();\n  }\n}\n","import GL from '@luma.gl/constants';\nimport {TransformFeedback, Buffer} from '@luma.gl/webgl';\nimport {getBuffersFromGeometry} from './model-utils';\nimport BaseModel from './base-model';\nimport {log, isObjectEmpty, uid, assert} from '../utils';\n\nconst ERR_MODEL_PARAMS = 'Model needs drawMode and vertexCount';\n\nexport default class Model extends BaseModel {\n  constructor(gl, props = {}) {\n    // Deduce a helpful id\n    const {id = uid('model')} = props;\n    super(gl, {...props, id});\n  }\n\n  initialize(props) {\n    super.initialize(props);\n\n    this.drawMode = props.drawMode !== undefined ? props.drawMode : GL.TRIANGLES;\n    this.vertexCount = props.vertexCount || 0;\n\n    // Track buffers created by setGeometry\n    this.geometryBuffers = {};\n\n    // geometry might have set drawMode and vertexCount\n    this.isInstanced = props.isInstanced || props.instanced;\n\n    this._setModelProps(props);\n\n    // TODO - just to unbreak deck.gl 7.0-beta, remove as soon as updated\n    this.geometry = {};\n\n    // assert(program || program instanceof Program);\n    assert(this.drawMode !== undefined && Number.isFinite(this.vertexCount), ERR_MODEL_PARAMS);\n  }\n\n  setProps(props) {\n    super.setProps(props);\n    this._setModelProps(props);\n  }\n\n  delete() {\n    super.delete();\n\n    this._deleteGeometryBuffers();\n  }\n\n  // GETTERS\n\n  getDrawMode() {\n    return this.drawMode;\n  }\n\n  getVertexCount() {\n    return this.vertexCount;\n  }\n\n  getInstanceCount() {\n    return this.instanceCount;\n  }\n\n  getAttributes() {\n    return this.attributes;\n  }\n\n  // SETTERS\n\n  setDrawMode(drawMode) {\n    this.drawMode = drawMode;\n    return this;\n  }\n\n  setVertexCount(vertexCount) {\n    assert(Number.isFinite(vertexCount));\n    this.vertexCount = vertexCount;\n    return this;\n  }\n\n  setInstanceCount(instanceCount) {\n    assert(Number.isFinite(instanceCount));\n    this.instanceCount = instanceCount;\n    return this;\n  }\n\n  setGeometry(geometry) {\n    this.drawMode = geometry.drawMode;\n    this.vertexCount = geometry.getVertexCount();\n\n    this._deleteGeometryBuffers();\n\n    this.geometryBuffers = getBuffersFromGeometry(this.gl, geometry);\n    this.vertexArray.setAttributes(this.geometryBuffers);\n    return this;\n  }\n\n  setAttributes(attributes = {}) {\n    // Avoid setting needsRedraw if no attributes\n    if (isObjectEmpty(attributes)) {\n      return this;\n    }\n\n    const normalizedAttributes = {};\n    for (const name in attributes) {\n      const attribute = attributes[name];\n      // The `getValue` call provides support for deck.gl `Attribute` class\n      // TODO - remove once deck refactoring completes\n      normalizedAttributes[name] = attribute.getValue ? attribute.getValue() : attribute;\n    }\n\n    this.vertexArray.setAttributes(normalizedAttributes);\n    return this;\n  }\n\n  // DRAW CALLS\n\n  draw(options = {}) {\n    return this.drawGeometry(options);\n  }\n\n  // Draw call for transform feedback\n  transform(opts = {}) {\n    const {discard = true, feedbackBuffers, unbindModels = []} = opts;\n\n    let {parameters} = opts;\n\n    if (feedbackBuffers) {\n      this._setFeedbackBuffers(feedbackBuffers);\n    }\n\n    if (discard) {\n      parameters = Object.assign({}, parameters, {[GL.RASTERIZER_DISCARD]: discard});\n    }\n\n    unbindModels.forEach(model => model.vertexArray.unbindBuffers());\n    try {\n      this.draw(Object.assign({}, opts, {parameters}));\n    } finally {\n      unbindModels.forEach(model => model.vertexArray.bindBuffers());\n    }\n\n    return this;\n  }\n\n  // DEPRECATED METHODS\n\n  render(uniforms = {}) {\n    log.warn('Model.render() is deprecated. Use Model.setUniforms() and Model.draw()')();\n    return this.setUniforms(uniforms).draw();\n  }\n\n  // PRIVATE METHODS\n\n  _setModelProps(props) {\n    // params\n    // if ('drawMode' in props) {\n    //   this.drawMode = getDrawMode(props.drawMode);\n    // }\n    // if ('vertexCount' in props) {\n    //   this.vertexCount = props.vertexCount;\n    // }\n    if ('instanceCount' in props) {\n      this.instanceCount = props.instanceCount;\n    }\n    if ('geometry' in props) {\n      this.setGeometry(props.geometry);\n    }\n\n    // webgl settings\n    if ('attributes' in props) {\n      this.setAttributes(props.attributes);\n    }\n    if ('_feedbackBuffers' in props) {\n      this._setFeedbackBuffers(props._feedbackBuffers);\n    }\n  }\n\n  _deleteGeometryBuffers() {\n    for (const name in this.geometryBuffers) {\n      // Buffer is raw value (for indices) or first element of [buffer, accessor] pair\n      const buffer = this.geometryBuffers[name][0] || this.geometryBuffers[name];\n      if (buffer instanceof Buffer) {\n        buffer.delete();\n      }\n    }\n  }\n\n  // Updates (evaluates) all function valued uniforms based on a new set of animationProps\n  // experimental\n  _setAnimationProps(animationProps) {\n    if (this.animated) {\n      assert(animationProps, 'Model.draw(): animated uniforms but no animationProps');\n      const animatedUniforms = this._evaluateAnimateUniforms(animationProps);\n      Object.assign(this.uniforms, animatedUniforms);\n    }\n  }\n\n  // Transform Feedback\n\n  _setFeedbackBuffers(feedbackBuffers = {}) {\n    // Avoid setting needsRedraw if no feedbackBuffers\n    if (isObjectEmpty(feedbackBuffers)) {\n      return this;\n    }\n\n    const {gl} = this.program;\n    this.transformFeedback =\n      this.transformFeedback ||\n      new TransformFeedback(gl, {\n        program: this.program\n      });\n\n    this.transformFeedback.setBuffers(feedbackBuffers);\n    return this;\n  }\n}\n","// Transpiles shader source code to target GLSL version\n// Note: We always run transpiler even if same version e.g. 3.00 => 3.00\n// RFC: https://github.com/uber/luma.gl/blob/7.0-release/dev-docs/RFCs/v6.0/portable-glsl-300-rfc.md\nexport default function transpileShader(source, targetGLSLVersion, isVertex) {\n  switch (targetGLSLVersion) {\n    case 300:\n      return isVertex ? convertVertexShaderTo300(source) : convertFragmentShaderTo300(source);\n    case 100:\n      return isVertex ? convertVertexShaderTo100(source) : convertFragmentShaderTo100(source);\n    default:\n      throw new Error(`unknown GLSL version ${targetGLSLVersion}`);\n  }\n}\n\nfunction convertVertexShaderTo300(source) {\n  return source\n    .replace(/attribute\\s+/g, 'in ')\n    .replace(/varying\\s+/g, 'out ')\n    .replace(/texture2D\\(/g, 'texture(')\n    .replace(/textureCube\\(+/g, 'texture(')\n    .replace(/texture2DLodEXT\\(/g, 'textureLod(')\n    .replace(/textureCubeLodEXT\\(/g, 'textureLod(');\n}\n\nfunction convertFragmentShaderTo300(source) {\n  return source\n    .replace(/varying\\s+/g, 'in ')\n    .replace(/texture2D\\(/g, 'texture(')\n    .replace(/textureCube\\(/g, 'texture(')\n    .replace(/texture2DLodEXT\\(/g, 'textureLod(')\n    .replace(/textureCubeLodEXT\\(/g, 'textureLod(');\n\n  // Deal with fragColor\n  // .replace(/gl_fragColor/g, 'fragColor ');\n}\n\nfunction convertVertexShaderTo100(source) {\n  // /gm - treats each line as a string, so that ^ matches after newlines\n  return source\n    .replace(/^in\\s+/gm, 'attribute ')\n    .replace(/^out\\s+/gm, 'varying ')\n    .replace(/texture\\(/g, 'texture2D(');\n}\n\nfunction convertFragmentShaderTo100(source) {\n  // /gm - treats each line as a string, so that ^ matches after newlines\n  return source.replace(/^in\\s+/gm, 'varying ').replace(/texture\\(/g, 'texture2D(');\n\n  // Deal with fragColor\n  // .replace(/^out\\s+/g, 'varying ')\n}\n","const TYPE_DEFINITIONS = {\n  number: {\n    validate(value, propType) {\n      return (\n        Number.isFinite(value) &&\n        (!('max' in propType) || value <= propType.max) &&\n        (!('min' in propType) || value >= propType.min)\n      );\n    }\n  },\n  array: {\n    validate(value, propType) {\n      return Array.isArray(value) || ArrayBuffer.isView(value);\n    }\n  }\n};\n\nexport function parsePropTypes(propDefs) {\n  const propTypes = {};\n  for (const propName in propDefs) {\n    const propDef = propDefs[propName];\n    const propType = parsePropType(propDef);\n    propTypes[propName] = propType;\n  }\n  return propTypes;\n}\n\n// Parses one property definition entry. Either contains:\n// * a valid prop type object ({type, ...})\n// * or just a default value, in which case type and name inference is used\nfunction parsePropType(propDef) {\n  let type = getTypeOf(propDef);\n  if (type === 'object') {\n    if (!propDef) {\n      return {type: 'object', value: null};\n    }\n    if ('type' in propDef) {\n      return Object.assign({}, propDef, TYPE_DEFINITIONS[propDef.type]);\n    }\n    if (!('value' in propDef)) {\n      // If no type and value this object is likely the value\n      return {type: 'object', value: propDef};\n    }\n    type = getTypeOf(propDef.value);\n    return Object.assign({type}, propDef, TYPE_DEFINITIONS[type]);\n  }\n  return Object.assign({type, value: propDef}, TYPE_DEFINITIONS[type]);\n}\n\n// improved version of javascript typeof that can distinguish arrays and null values\nfunction getTypeOf(value) {\n  if (Array.isArray(value) || ArrayBuffer.isView(value)) {\n    return 'array';\n  }\n  return typeof value;\n}\n","import transpileShader from './transpile-shader';\nimport {assert} from '../utils';\nimport {parsePropTypes} from './filters/prop-types';\n\nconst VERTEX_SHADER = 'vs';\nconst FRAGMENT_SHADER = 'fs';\n\nexport default class ShaderModule {\n  constructor({\n    name,\n    vs,\n    fs,\n    dependencies = [],\n    uniforms,\n    getUniforms,\n    deprecations = [],\n    defines = {},\n    // DEPRECATED\n    vertexShader,\n    fragmentShader\n  }) {\n    assert(typeof name === 'string');\n    this.name = name;\n    this.vs = vs || vertexShader;\n    this.fs = fs || fragmentShader;\n    this.getModuleUniforms = getUniforms;\n    this.dependencies = dependencies;\n    this.deprecations = this._parseDeprecationDefinitions(deprecations);\n    this.defines = defines;\n\n    if (uniforms) {\n      this.uniforms = parsePropTypes(uniforms);\n    }\n  }\n\n  // Extracts the source code chunk for the specified shader type from the named shader module\n  getModuleSource(type, targetGLSLVersion) {\n    let moduleSource;\n    switch (type) {\n      case VERTEX_SHADER:\n        moduleSource = transpileShader(this.vs || '', targetGLSLVersion, true);\n        break;\n      case FRAGMENT_SHADER:\n        moduleSource = transpileShader(this.fs || '', targetGLSLVersion, false);\n        break;\n      default:\n        assert(false);\n    }\n\n    return `\\\n#define MODULE_${this.name.toUpperCase()}\n${moduleSource}\\\n// END MODULE_${this.name}\n\n`;\n  }\n\n  getUniforms(opts, uniforms) {\n    if (this.getModuleUniforms) {\n      return this.getModuleUniforms(opts, uniforms);\n    }\n    // Build uniforms from the uniforms array\n    if (this.uniforms) {\n      return this._defaultGetUniforms(opts);\n    }\n    return {};\n  }\n\n  getDefines() {\n    return this.defines;\n  }\n\n  // Warn about deprecated uniforms or functions\n  checkDeprecations(shaderSource, log) {\n    this.deprecations.forEach(def => {\n      if (def.regex.test(shaderSource)) {\n        if (def.deprecated) {\n          log.deprecated(def.old, def.new)();\n        } else {\n          log.removed(def.old, def.new)();\n        }\n      }\n    });\n  }\n\n  _parseDeprecationDefinitions(deprecations) {\n    deprecations.forEach(def => {\n      switch (def.type) {\n        case 'function':\n          def.regex = new RegExp(`\\\\b${def.old}\\\\(`);\n          break;\n        default:\n          def.regex = new RegExp(`${def.type} ${def.old};`);\n      }\n    });\n\n    return deprecations;\n  }\n\n  _defaultGetUniforms(opts = {}) {\n    const uniforms = {};\n    const propTypes = this.uniforms;\n\n    for (const key in propTypes) {\n      const propDef = propTypes[key];\n      if (key in opts && !propDef.private) {\n        if (propDef.validate) {\n          assert(propDef.validate(opts[key], propDef), `${this.name}: invalid ${key}`);\n        }\n        uniforms[key] = opts[key];\n      } else {\n        uniforms[key] = propDef.value;\n      }\n    }\n\n    return uniforms;\n  }\n}\n\n// This utility mutates the original module\n// Keeping for backward compatibility\n// TODO - remove in v8\nexport function normalizeShaderModule(module) {\n  if (!module.normalized) {\n    module.normalized = true;\n    if (module.uniforms && !module.getUniforms) {\n      const shaderModule = new ShaderModule(module);\n      module.getUniforms = shaderModule.getUniforms.bind(shaderModule);\n    }\n  }\n  return module;\n}\n","import {MODULE_INJECTORS_VS, MODULE_INJECTORS_FS} from '../modules/module-injectors';\nimport {VERTEX_SHADER, FRAGMENT_SHADER} from './constants';\nimport {assert} from '../utils';\n\n// TODO - experimental\nconst MODULE_INJECTORS = {\n  [VERTEX_SHADER]: MODULE_INJECTORS_VS,\n  [FRAGMENT_SHADER]: MODULE_INJECTORS_FS\n};\n\nexport const DECLARATION_INJECT_MARKER = '__LUMA_INJECT_DECLARATIONS__'; // Uniform/attribute declarations\n\nconst REGEX_START_OF_MAIN = /void main\\s*\\([^)]*\\)\\s*\\{\\n?/; // Beginning of main\nconst REGEX_END_OF_MAIN = /}\\n?[^{}]*$/; // End of main, assumes main is last function\nconst fragments = [];\n\n// A minimal shader injection/templating system.\n// RFC: https://github.com/uber/luma.gl/blob/7.0-release/dev-docs/RFCs/v6.0/shader-injection-rfc.md\n/* eslint-disable complexity */\nexport default function injectShader(source, type, inject, injectStandardStubs) {\n  const isVertex = type === VERTEX_SHADER;\n\n  for (const key in inject) {\n    const fragmentData = inject[key];\n    fragmentData.sort((a, b) => a.order - b.order);\n    fragments.length = fragmentData.length;\n    for (let i = 0, len = fragmentData.length; i < len; ++i) {\n      fragments[i] = fragmentData[i].injection;\n    }\n    const fragmentString = `${fragments.join('\\n')}\\n`;\n    switch (key) {\n      // declarations are injected before the main function\n      case 'vs:#decl':\n        if (isVertex) {\n          source = source.replace(DECLARATION_INJECT_MARKER, fragmentString);\n        }\n        break;\n      // main code is injected at the end of main function\n      case 'vs:#main-start':\n        if (isVertex) {\n          source = source.replace(REGEX_START_OF_MAIN, match => match + fragmentString);\n        }\n        break;\n      case 'vs:#main-end':\n        if (isVertex) {\n          source = source.replace(REGEX_END_OF_MAIN, match => fragmentString + match);\n        }\n        break;\n      case 'fs:#decl':\n        if (!isVertex) {\n          source = source.replace(DECLARATION_INJECT_MARKER, fragmentString);\n        }\n        break;\n      case 'fs:#main-start':\n        if (!isVertex) {\n          source = source.replace(REGEX_START_OF_MAIN, match => match + fragmentString);\n        }\n        break;\n      case 'fs:#main-end':\n        if (!isVertex) {\n          source = source.replace(REGEX_END_OF_MAIN, match => fragmentString + match);\n        }\n        break;\n\n      default:\n        // TODO(Tarek): I think this usage should be deprecated.\n\n        // inject code after key, leaving key in place\n        source = source.replace(key, match => match + fragmentString);\n    }\n  }\n\n  // Remove if it hasn't already been replaced\n  source = source.replace(DECLARATION_INJECT_MARKER, '');\n\n  // Finally, if requested, insert an automatic module injector chunk\n  if (injectStandardStubs) {\n    source = source.replace(/\\}\\s*$/, match => match + MODULE_INJECTORS[type]);\n  }\n\n  return source;\n}\n\n/* eslint-enable complexity */\n\n// Takes an array of inject objects and combines them into one\nexport function combineInjects(injects) {\n  const result = {};\n  assert(Array.isArray(injects) && injects.length > 1);\n  injects.forEach(inject => {\n    for (const key in inject) {\n      result[key] = result[key] ? `${result[key]}\\n${inject[key]}` : inject[key];\n    }\n  });\n  return result;\n}\n","export const MODULE_INJECTORS_VS = `\\\n#ifdef MODULE_LOGDEPTH\n  logdepth_adjustPosition(gl_Position);\n#endif\n`;\n\nexport const MODULE_INJECTORS_FS = `\\\n#ifdef MODULE_MATERIAL\n  gl_FragColor = material_filterColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_LIGHTING\n  gl_FragColor = lighting_filterColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_FOG\n  gl_FragColor = fog_filterColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_PICKING\n  gl_FragColor = picking_filterHighlightColor(gl_FragColor);\n  gl_FragColor = picking_filterPickingColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_LOGDEPTH\n  logdepth_setFragDepth();\n#endif\n`;\n","// shadertools exports\n\n// DEFAULT SHADERS\n// A set of base shaders that leverage the shader module system,\n// dynamically enabling features depending on which modules are included\nimport MODULAR_VS from './shaders/modular-vertex.glsl';\nimport MODULAR_FS from './shaders/modular-fragment.glsl';\n\n// DOCUMENTED APIS\nexport {\n  registerShaderModules,\n  setDefaultShaderModules,\n  getDefaultShaderModules\n} from './lib/resolve-modules';\nexport {\n  assembleShaders,\n  createShaderHook,\n  createModuleInjection,\n  resetGlobalShaderHooks\n} from './lib/assemble-shaders';\n\n// HELPERS\nexport {combineInjects} from './lib/inject-shader';\nexport {normalizeShaderModule} from './lib/shader-module';\n\n// UTILS\nexport {\n  getQualifierDetails,\n  getPassthroughFS,\n  typeToChannelSuffix,\n  typeToChannelCount,\n  convertToVec4\n} from './utils/shader-utils';\n\n// SHADER MODULES\nexport * from './modules';\n\nexport const MODULAR_SHADERS = {\n  vs: MODULAR_VS,\n  fs: MODULAR_FS,\n  uniforms: {}\n};\n","export default `\\\n#define SHADER_NAME luma_modular_vertex\n\n// object attributes\nattribute vec3 positions;\nattribute vec3 normals;\nattribute vec4 colors;\nattribute vec2 texCoords;\nattribute vec3 pickingColors;\n\nvoid main(void) {\n\n  // Set up position\n#ifdef MODULE_GEOMETRY\n  geometry_setPosition(positions);\n  geometry_setNormal(normals);\n#endif\n\n#ifdef MODULE_PROJECT\n  project_setPositionAndNormal_Model(positions, normals);\n  gl_Position = project_model_to_clipspace(positions);\n#endif\n\n  // Set up depth\n#ifdef MODULE_LOGDEPTH\n  logdepth_adjustPosition(gl_Position);\n#endif\n\n#ifdef MODULE_DIFFUSE\n  diffuse_setTextureCoordinate(texCoords);\n#endif\n\n  // Set up color calculations\n#ifdef MODULE_MATERIAL\n  material_setDiffuseColor(colors);\n  material_setDiffuseTextureCoordinates(texCoords);\n#endif\n\n#ifdef MODULE_LIGHTING\n  lighting_setPositionAndNormal(positions, normals);\n  lighting_apply_light(positions);\n  lighting_apply_reflection(positions);\n#endif\n\n#ifdef MODULE_PICKING\n  picking_setPickingColor(pickingColors);\n#endif\n\n}\n`;\n","export default `\\\n#define SHADER_NAME luma-modular-fragment\n\nprecision highp float;\n\n// varyings\nvarying vec4 vColor;\n\nvoid main(){\n  gl_FragColor = vec4(1., 0., 1., 1.);\n\n#ifdef MODULE_DIFFUSE\n  gl_FragColor = diffuse_filterColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_MATERIAL\n  gl_FragColor = material_filterColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_LIGHTING\n  gl_FragColor = lighting_filterColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_FOG\n  gl_FragColor = fog_filterColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_PICKING\n  gl_FragColor = picking_filterHighlightColor(gl_FragColor);\n  gl_FragColor = picking_filterPickingColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_LOGDEPTH\n  logdepth_setFragDepth(gl_Position);\n#endif\n}\n`;\n","export const VERTEX_SHADER = 'vs';\nexport const FRAGMENT_SHADER = 'fs';\n","// Recommendation is to ignore message but current test suite checks agains the\n// message so keep it for now.\nexport default function assert(condition, message) {\n  if (!condition) {\n    throw new Error(message || 'shadertools: assertion failed.');\n  }\n}\n","import GL from '@luma.gl/constants';\nimport Resource from './resource';\nimport Buffer from './buffer';\nimport {isWebGL2, assertWebGL2Context} from '../webgl-utils';\nimport {log, isObjectEmpty} from '../utils';\n\n// NOTE: The `bindOnUse` flag is a major workaround:\n// See https://github.com/KhronosGroup/WebGL/issues/2346\n\nexport default class TransformFeedback extends Resource {\n  static isSupported(gl) {\n    return isWebGL2(gl);\n  }\n\n  constructor(gl, props = {}) {\n    assertWebGL2Context(gl);\n    super(gl, props);\n\n    this.initialize(props);\n    this.stubRemovedMethods('TransformFeedback', 'v6.0', ['pause', 'resume']);\n    Object.seal(this);\n  }\n\n  initialize(props = {}) {\n    this.buffers = {};\n    this.unused = {};\n    this.configuration = null;\n    this.bindOnUse = true;\n\n    // Unbind any currently bound buffers\n    if (!isObjectEmpty(this.buffers)) {\n      this.bind(() => this._unbindBuffers());\n    }\n\n    this.setProps(props);\n    return this;\n  }\n\n  setProps(props) {\n    if ('program' in props) {\n      this.configuration = props.program && props.program.configuration;\n    }\n    if ('configuration' in props) {\n      this.configuration = props.configuration;\n    }\n    if ('bindOnUse' in props) {\n      props = props.bindOnUse;\n    }\n    if ('buffers' in props) {\n      this.setBuffers(props.buffers);\n    }\n  }\n\n  setBuffers(buffers = {}) {\n    this.bind(() => {\n      for (const bufferName in buffers) {\n        this.setBuffer(bufferName, buffers[bufferName]);\n      }\n    });\n    return this;\n  }\n\n  setBuffer(locationOrName, bufferOrParams) {\n    const location = this._getVaryingIndex(locationOrName);\n    const {buffer, byteSize, byteOffset} = this._getBufferParams(bufferOrParams);\n\n    if (location < 0) {\n      this.unused[locationOrName] = buffer;\n      log.warn(() => `${this.id} unused varying buffer ${locationOrName}`)();\n      return this;\n    }\n\n    this.buffers[location] = bufferOrParams;\n\n    // Need to avoid chrome bug where buffer that is already bound to a different target\n    // cannot be bound to 'TRANSFORM_FEEDBACK_BUFFER' target.\n    if (!this.bindOnUse) {\n      this._bindBuffer(location, buffer, byteOffset, byteSize);\n    }\n\n    return this;\n  }\n\n  begin(primitiveMode = GL.POINTS) {\n    this.gl.bindTransformFeedback(GL.TRANSFORM_FEEDBACK, this.handle);\n    this._bindBuffers();\n    this.gl.beginTransformFeedback(primitiveMode);\n    return this;\n  }\n\n  end() {\n    this.gl.endTransformFeedback();\n    this._unbindBuffers();\n    this.gl.bindTransformFeedback(GL.TRANSFORM_FEEDBACK, null);\n    return this;\n  }\n\n  // PRIVATE METHODS\n\n  _getBufferParams(bufferOrParams) {\n    let byteOffset;\n    let byteSize;\n    let buffer;\n    if (bufferOrParams instanceof Buffer === false) {\n      buffer = bufferOrParams.buffer;\n      byteSize = bufferOrParams.byteSize;\n      byteOffset = bufferOrParams.byteOffset;\n    } else {\n      buffer = bufferOrParams;\n    }\n    // to use bindBufferRange, either offset or size must be specified, use default value for the other.\n    if (byteOffset !== undefined || byteSize !== undefined) {\n      byteOffset = byteOffset || 0;\n      byteSize = byteSize || buffer.byteLength - byteOffset;\n    }\n    return {buffer, byteOffset, byteSize};\n  }\n\n  _getVaryingInfo(locationOrName) {\n    return this.configuration && this.configuration.getVaryingInfo(locationOrName);\n  }\n\n  _getVaryingIndex(locationOrName) {\n    if (this.configuration) {\n      return this.configuration.getVaryingInfo(locationOrName).location;\n    }\n    const location = Number(locationOrName);\n    return Number.isFinite(location) ? location : -1;\n  }\n\n  // Need to avoid chrome bug where buffer that is already bound to a different target\n  // cannot be bound to 'TRANSFORM_FEEDBACK_BUFFER' target.\n  _bindBuffers() {\n    if (this.bindOnUse) {\n      for (const bufferIndex in this.buffers) {\n        const {buffer, byteSize, byteOffset} = this._getBufferParams(this.buffers[bufferIndex]);\n        this._bindBuffer(bufferIndex, buffer, byteOffset, byteSize);\n      }\n    }\n  }\n\n  _unbindBuffers() {\n    if (this.bindOnUse) {\n      for (const bufferIndex in this.buffers) {\n        this._bindBuffer(bufferIndex, null);\n      }\n    }\n  }\n\n  _bindBuffer(index, buffer, byteOffset = 0, byteSize) {\n    const handle = buffer && buffer.handle;\n    if (!handle || byteSize === undefined) {\n      this.gl.bindBufferBase(GL.TRANSFORM_FEEDBACK_BUFFER, index, handle);\n    } else {\n      this.gl.bindBufferRange(GL.TRANSFORM_FEEDBACK_BUFFER, index, handle, byteOffset, byteSize);\n    }\n    return this;\n  }\n\n  // RESOURCE METHODS\n\n  _createHandle() {\n    return this.gl.createTransformFeedback();\n  }\n\n  _deleteHandle() {\n    this.gl.deleteTransformFeedback(this.handle);\n  }\n\n  _bindHandle(handle) {\n    this.gl.bindTransformFeedback(GL.TRANSFORM_FEEDBACK, this.handle);\n  }\n}\n"],"sourceRoot":""}