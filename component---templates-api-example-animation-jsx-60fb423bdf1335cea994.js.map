{"version":3,"sources":["webpack:///../modules/engine/src/animation/key-frames.js","webpack:///../examples/api/animation/app.js","webpack:///./templates/api/example-animation.jsx","webpack:///../examples/utils/index.js","webpack:///../modules/engine/src/geometry/geometry.js","webpack:///../modules/engine/src/geometries/cube-geometry.js","webpack:///../modules/shadertools/src/modules/project/project.js","webpack:///../modules/shadertools/src/modules/dirlight/dirlight.js","webpack:///../modules/engine/src/animation/timeline.js"],"names":["KeyFrames","this","_lastTime","startIndex","endIndex","factor","times","values","setKeyFrames","keyFrames","setTime","numKeys","length","i","_calculateKeys","time","Math","getStartTime","getEndTime","getStartData","getEndData","index","startTime","endTime","random","getRandom","AppAnimationLoop","debug","getInfo","onInitialize","gl","aspect","_animationLoop","setParameters","clearColor","clearDepth","depthTest","depthFunc","LEQUAL","playButton","document","pauseButton","timeSlider","event","parseFloat","translations","rotations","colors","attachTimeline","timeline","play","channels","addChannel","delay","rate","duration","repeat","Number","POSITIVE_INFINITY","keyFrameData","cubes","Array","attachAnimation","translation","rotation","model","vs","fs","modules","geometry","uniforms","uProjection","fov","radians","near","far","uView","center","eye","uColor","onRender","animationProps","modelMatrix","cube","startRotation","endRotation","rotationX","rotationY","rotationZ","uModel","onFinalize","delete","AnimationLoop","window","animationLoop","Example","render","exampleConfig","props","pageContext","React","Component","MiniAnimationLoop","start","stop","_setDisplay","_getCanvas","canvas","dpr","s","c","n","DRAW_MODE","POINTS","LINES","LINE_LOOP","LINE_STRIP","TRIANGLES","TRIANGLE_STRIP","TRIANGLE_FAN","Geometry","id","uid","drawMode","attributes","indices","vertexCount","userData","_setAttributes","_calculateVertexCount","getVertexCount","getAttributes","_print","ArrayBuffer","value","size","attribute","assert","attributeName","isIndexed","Object","CUBE_INDICES","Uint16Array","CUBE_POSITIONS","Float32Array","CUBE_NORMALS","CUBE_TEX_COORDS","ATTRIBUTES","POSITION","NORMAL","TEXCOORD_0","CubeGeometry","IDENTITY_MATRIX","DEFAULT_MODULE_OPTIONS","viewMatrix","projectionMatrix","cameraPositionWorld","name","getUniforms","opts","prevUniforms","common","lightDirection","dependencies","project","channelHandles","animationHandles","Timeline","animations","playing","lastEngineTime","handle","channel","_setChannelTime","set","removeChannel","animationHandle","animation","detachAnimation","isFinished","get","getTime","animationData","pause","reset","channelHandle","update","engineTime","offsetTime"],"mappings":"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","file":"component---templates-api-example-animation-jsx-60fb423bdf1335cea994.js","sourcesContent":["export class KeyFrames {\n  constructor(keyFrames) {\n    this._lastTime = -1;\n    this.startIndex = -1;\n    this.endIndex = -1;\n    this.factor = 0;\n    this.times = [];\n    this.values = [];\n    this.setKeyFrames(keyFrames);\n    this.setTime(0);\n  }\n\n  setKeyFrames(keyFrames) {\n    const numKeys = keyFrames.length;\n    this.times.length = numKeys;\n    this.values.length = numKeys;\n\n    for (let i = 0; i < numKeys; ++i) {\n      this.times[i] = keyFrames[i][0];\n      this.values[i] = keyFrames[i][1];\n    }\n\n    this._calculateKeys(this._lastTime);\n  }\n\n  setTime(time) {\n    time = Math.max(0, time);\n\n    if (time !== this._lastTime) {\n      this._calculateKeys(time);\n      this._lastTime = time;\n    }\n  }\n\n  getStartTime() {\n    return this.times[this.startIndex];\n  }\n\n  getEndTime() {\n    return this.times[this.endIndex];\n  }\n\n  getStartData() {\n    return this.values[this.startIndex];\n  }\n\n  getEndData() {\n    return this.values[this.endIndex];\n  }\n\n  _calculateKeys(time) {\n    let index = 0;\n    const numKeys = this.times.length;\n\n    for (index = 0; index < numKeys - 2; ++index) {\n      if (this.times[index + 1] > time) {\n        break;\n      }\n    }\n\n    this.startIndex = index;\n    this.endIndex = index + 1;\n\n    const startTime = this.times[this.startIndex];\n    const endTime = this.times[this.endIndex];\n    this.factor = Math.min(Math.max(0, (time - startTime) / (endTime - startTime)), 1);\n  }\n}\n","/* global document */\n\nimport {AnimationLoop, CubeGeometry, Timeline, KeyFrames, Model} from '@luma.gl/engine';\nimport {setParameters} from '@luma.gl/gltools';\nimport {dirlight} from '@luma.gl/shadertools';\nimport {Matrix4, radians} from 'math.gl';\nimport {getRandom} from '../../utils';\n\nconst random = getRandom();\n\nconst INFO_HTML = `\nKey frame animation based on multiple hierarchical timelines.\n<button id=\"play\">Play</button>\n<button id=\"pause\">Pause</button><BR>\nTime: <input type=\"range\" id=\"time\" min=\"0\" max=\"30000\" step=\"1\"><BR>\n`;\n\nconst vs = `\\\nattribute vec3 positions;\nattribute vec3 normals;\n\nuniform vec3 uColor;\nuniform mat4 uModel;\nuniform mat4 uView;\nuniform mat4 uProjection;\n\nvarying vec3 color;\n\nvoid main(void) {\n  vec3 normal = vec3(uModel * vec4(normals, 0.0));\n\n  // Set up data for modules\n  color = uColor;\n  project_setNormal(normal);\n  gl_Position = uProjection * uView * uModel * vec4(positions, 1.0);\n}\n`;\n\nconst fs = `\\\nprecision highp float;\n\nvarying vec3 color;\n\nvoid main(void) {\n  gl_FragColor = vec4(color, 1.);\n  gl_FragColor = dirlight_filterColor(gl_FragColor);\n}\n`;\n\nexport default class AppAnimationLoop extends AnimationLoop {\n  constructor() {\n    super({debug: true});\n  }\n\n  static getInfo() {\n    return INFO_HTML;\n  }\n\n  onInitialize({gl, _animationLoop, aspect}) {\n    setParameters(gl, {\n      clearColor: [0, 0, 0, 1],\n      clearDepth: 1,\n      depthTest: true,\n      depthFunc: gl.LEQUAL\n    });\n\n    const playButton = document.getElementById('play');\n    const pauseButton = document.getElementById('pause');\n    const timeSlider = document.getElementById('time');\n\n    if (playButton) {\n      playButton.addEventListener('click', () => {\n        this.timeline.play();\n      });\n\n      pauseButton.addEventListener('click', () => {\n        this.timeline.pause();\n      });\n\n      timeSlider.addEventListener('input', event => {\n        this.timeline.setTime(parseFloat(event.target.value));\n      });\n    }\n\n    const translations = [[2, -2, 0], [2, 2, 0], [-2, 2, 0], [-2, -2, 0]];\n\n    const rotations = [\n      [random(), random(), random()],\n      [random(), random(), random()],\n      [random(), random(), random()],\n      [random(), random(), random()]\n    ];\n\n    const colors = [[1, 0, 0], [0, 1, 0], [0, 0, 1], [1, 1, 0]];\n\n    this.attachTimeline(new Timeline());\n    this.timeline.play();\n\n    const channels = [\n      this.timeline.addChannel({\n        delay: 2000,\n        rate: 0.5,\n        duration: 8000,\n        repeat: 2\n      }),\n      this.timeline.addChannel({\n        delay: 10000,\n        rate: 0.2,\n        duration: 20000,\n        repeat: 1\n      }),\n      this.timeline.addChannel({\n        delay: 7000,\n        rate: 1,\n        duration: 4000,\n        repeat: 8\n      }),\n      this.timeline.addChannel({\n        delay: 0,\n        rate: 0.8,\n        duration: 5000,\n        repeat: Number.POSITIVE_INFINITY\n      })\n    ];\n\n    const keyFrameData = [\n      [0, 0],\n      [1000, 2 * Math.PI],\n      [2000, Math.PI],\n      [3000, 2 * Math.PI],\n      [4000, 0]\n    ];\n\n    const keyFrames = [\n      new KeyFrames(keyFrameData),\n      new KeyFrames(keyFrameData),\n      new KeyFrames(keyFrameData),\n      new KeyFrames(keyFrameData)\n    ];\n\n    this.cubes = new Array(4);\n\n    for (let i = 0; i < 4; ++i) {\n      this.timeline.attachAnimation(keyFrames[i], channels[i]);\n\n      this.cubes[i] = {\n        translation: translations[i],\n        rotation: rotations[i],\n        keyFrames: keyFrames[i],\n        model: new Model(gl, {\n          vs,\n          fs,\n          modules: [dirlight],\n          geometry: new CubeGeometry(),\n          uniforms: {\n            uProjection: new Matrix4().perspective({fov: radians(60), aspect, near: 1, far: 20.0}),\n            uView: new Matrix4().lookAt({\n              center: [0, 0, 0],\n              eye: [0, 0, -8]\n            }),\n            uColor: colors[i]\n          }\n        })\n      };\n    }\n\n    return {timeSlider};\n  }\n\n  onRender(animationProps) {\n    const {gl, timeSlider} = animationProps;\n\n    if (timeSlider) {\n      timeSlider.value = this.timeline.getTime();\n    }\n\n    const modelMatrix = new Matrix4();\n\n    // Draw the cubes\n    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n\n    for (let i = 0; i < 4; ++i) {\n      const cube = this.cubes[i];\n      const startRotation = cube.keyFrames.getStartData();\n      const endRotation = cube.keyFrames.getEndData();\n      const rotation = startRotation + cube.keyFrames.factor * (endRotation - startRotation);\n      const rotationX = cube.rotation[0] + rotation;\n      const rotationY = cube.rotation[1] + rotation;\n      const rotationZ = cube.rotation[2];\n      modelMatrix\n        .identity()\n        .translate(cube.translation)\n        .rotateXYZ([rotationX, rotationY, rotationZ]);\n      cube.model\n        .setUniforms({\n          uModel: modelMatrix\n        })\n        .draw();\n    }\n  }\n\n  onFinalize({gl}) {\n    for (let i = 0; i < 4; ++i) {\n      this.cubes[i].model.delete();\n    }\n  }\n}\n\n/* global window */\nif (typeof window !== 'undefined' && !window.website) {\n  const animationLoop = new AppAnimationLoop();\n  animationLoop.start();\n}\n","import React from 'react';\nimport AnimationLoopExamplePage from '../../src/components/animation-loop-example-page';\nimport AnimationLoop from '../../../examples/api/animation/app';\n\nexport default class Example extends React.Component {\n  render() {\n    return (\n      <AnimationLoopExamplePage AnimationLoop={AnimationLoop} exampleConfig={this.props.pageContext.exampleConfig} />\n    );\n  }\n}\n","/* global window, document */\n\n// Light class implementing the AnimationLoop interface\n// use by examples w/o creating a gl context\nexport class MiniAnimationLoop {\n  static getInfo() {\n    return '';\n  }\n\n  start() {}\n\n  stop() {}\n\n  delete() {}\n\n  _setDisplay() {}\n\n  _getCanvas(props = {}) {\n    let canvas;\n    if (props.canvas) {\n      canvas = document.getElementById(props.canvas);\n      const dpr = window.devicePixelRatio || 1;\n      canvas.height = canvas.clientHeight * dpr;\n      canvas.width = canvas.clientWidth * dpr;\n    } else {\n      canvas = document.createElement('canvas');\n      canvas.width = 800;\n      canvas.height = 600;\n      document.body.appendChild(canvas);\n    }\n\n    return canvas;\n  }\n}\n\n// Create a deterministic pseudorandom number generator\nexport function getRandom() {\n  let s = 1;\n  let c = 1;\n  return () => {\n    s = Math.sin(c * 17.23);\n    c = Math.cos(s * 27.92);\n    return fract(Math.abs(s * c) * 1432.71);\n  };\n}\n\nfunction fract(n) {\n  return n - Math.floor(n);\n}\n","import {uid, assert} from '@luma.gl/webgl';\n\n// Rendering primitives - specify how to extract primitives from vertices.\n// NOTE: These are numerically identical to the corresponding WebGL/OpenGL constants\nexport const DRAW_MODE = {\n  POINTS: 0x0000, // draw single points.\n  LINES: 0x0001, // draw lines. Each vertex connects to the one after it.\n  LINE_LOOP: 0x0002, // draw lines. Each set of two vertices is treated as a separate line segment.\n  LINE_STRIP: 0x0003, // draw a connected group of line segments from the first vertex to the last\n  TRIANGLES: 0x0004, // draw triangles. Each set of three vertices creates a separate triangle.\n  TRIANGLE_STRIP: 0x0005, // draw a connected group of triangles.\n  TRIANGLE_FAN: 0x0006 // draw a connected group of triangles.\n  // Each vertex connects to the previous and the first vertex in the fan.\n};\n\nexport default class Geometry {\n  static get DRAW_MODE() {\n    return DRAW_MODE;\n  }\n\n  constructor(props = {}) {\n    const {\n      id = uid('geometry'),\n      drawMode = DRAW_MODE.TRIANGLES,\n      attributes = {},\n      indices = null,\n      vertexCount = null\n    } = props;\n\n    this.id = id;\n    this.drawMode = drawMode | 0;\n    this.attributes = {};\n    this.userData = {};\n\n    this._setAttributes(attributes, indices);\n\n    this.vertexCount = vertexCount || this._calculateVertexCount(this.attributes, this.indices);\n\n    // stubRemovedMethods(this, [\n    //   'setNeedsRedraw', 'needsRedraw', 'setAttributes'\n    // ], 'Immutable');\n\n    // stubRemovedMethods(this, [\n    //   'hasAttribute', 'getAttribute', 'getArray'\n    // ], 'Use geometry.attributes and geometry.indices');\n\n    // deprecateMethods(this, ['getAttributes'])\n  }\n\n  get mode() {\n    return this.drawMode;\n  }\n\n  getVertexCount() {\n    return this.vertexCount;\n  }\n\n  // Return an object with all attributes plus indices added as a field.\n  getAttributes() {\n    return this.indices ? {indices: this.indices, ...this.attributes} : this.attributes;\n  }\n\n  // PRIVATE\n\n  _print(attributeName) {\n    return `Geometry ${this.id} attribute ${attributeName}`;\n  }\n\n  // Attribute\n  // value: typed array\n  // type: indices, vertices, uvs\n  // size: elements per vertex\n  // target: WebGL buffer type (string or constant)\n  _setAttributes(attributes, indices) {\n    if (indices) {\n      this.indices = ArrayBuffer.isView(indices) ? {value: indices, size: 1} : indices;\n    }\n\n    for (const attributeName in attributes) {\n      let attribute = attributes[attributeName];\n\n      // Wrap \"unwrapped\" arrays and try to autodetect their type\n      attribute = ArrayBuffer.isView(attribute) ? {value: attribute} : attribute;\n\n      assert(\n        ArrayBuffer.isView(attribute.value),\n        `${this._print(attributeName)}: must be typed array or object with value as typed array`\n      );\n\n      if ((attributeName === 'POSITION' || attributeName === 'positions') && !attribute.size) {\n        attribute.size = 3;\n      }\n\n      // Move indices to separate field\n      if (attributeName === 'indices') {\n        assert(!this.indices);\n        this.indices = attribute;\n      } else {\n        this.attributes[attributeName] = attribute;\n      }\n    }\n\n    if (this.indices && this.indices.isIndexed !== undefined) {\n      this.indices = Object.assign({}, this.indices);\n      delete this.indices.isIndexed;\n    }\n\n    return this;\n  }\n\n  _calculateVertexCount(attributes, indices) {\n    if (indices) {\n      return indices.value.length;\n    }\n    let vertexCount = Infinity;\n    for (const attributeName in attributes) {\n      const attribute = attributes[attributeName];\n      const {value, size, constant} = attribute;\n      if (!constant && value && size >= 1) {\n        vertexCount = Math.min(vertexCount, value.length / size);\n      }\n    }\n\n    assert(Number.isFinite(vertexCount));\n    return vertexCount;\n  }\n}\n","import Geometry from '../geometry/geometry';\nimport {uid} from '@luma.gl/webgl';\n\n// prettier-ignore\nconst CUBE_INDICES = new Uint16Array([\n  0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13,\n  14, 12, 14, 15, 16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23\n]);\n\n// prettier-ignore\nconst CUBE_POSITIONS = new Float32Array([\n  -1,  -1,  1, 1,  -1,  1,  1,  1,  1,  -1,  1,  1,\n  -1,  -1,  -1,  -1,  1,  -1,  1,  1,  -1,  1,  -1,  -1,\n  -1,  1,  -1,  -1,  1,  1,  1,  1,  1,  1,  1,  -1,\n  -1,  -1,  -1,  1,  -1,  -1,  1,  -1,  1,  -1,  -1,  1,\n  1,  -1,  -1,  1,  1,  -1,  1,  1,  1,  1,  -1,  1,\n  -1,  -1,  -1,  -1,  -1,  1,  -1,  1,  1,  -1,  1,  -1\n]);\n\n// TODO - could be Uint8\n// prettier-ignore\nconst CUBE_NORMALS = new Float32Array([\n  // Front face\n  0,  0,  1,  0,  0,  1,  0,  0,  1,  0,  0,  1,\n  // Back face\n  0,  0,  -1,  0,  0,  -1,  0,  0,  -1,  0,  0,  -1,\n  // Top face\n  0,  1,  0,  0,  1,  0,  0,  1,  0,  0,  1,  0,\n  // Bottom face\n  0,  -1,  0,  0,  -1,  0,  0,  -1,  0,  0,  -1,  0,\n  // Right face\n  1,  0,  0,  1,  0,  0,  1,  0,  0,  1,  0,  0,\n  // Left face\n  -1,  0,  0,  -1,  0,  0,  -1,  0,  0,  -1,  0,  0\n]);\n\n// prettier-ignore\nconst CUBE_TEX_COORDS = new Float32Array([\n  // Front face\n  0,  0,  1,  0,  1,  1,  0,  1,\n  // Back face\n  1,  0,  1,  1,  0,  1,  0,  0,\n  // Top face\n  0,  1,  0,  0,  1,  0,  1,  1,\n  // Bottom face\n  1,  1,  0,  1,  0,  0,  1,  0,\n  // Right face\n  1,  0,  1,  1,  0,  1,  0,  0,\n  // Left face\n  0,  0,  1,  0,  1,  1,  0,  1\n]);\n\nconst ATTRIBUTES = {\n  POSITION: {size: 3, value: new Float32Array(CUBE_POSITIONS)},\n  NORMAL: {size: 3, value: new Float32Array(CUBE_NORMALS)},\n  TEXCOORD_0: {size: 2, value: new Float32Array(CUBE_TEX_COORDS)}\n};\n\nexport default class CubeGeometry extends Geometry {\n  constructor(props = {}) {\n    const {id = uid('cube-geometry')} = props;\n    super({\n      ...props,\n      id,\n      indices: {size: 1, value: new Uint16Array(CUBE_INDICES)},\n      attributes: {...ATTRIBUTES, ...props.attributes}\n    });\n  }\n}\n","import {Matrix4} from 'math.gl';\n\nconst IDENTITY_MATRIX = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\n\nconst DEFAULT_MODULE_OPTIONS = {\n  modelMatrix: IDENTITY_MATRIX,\n  viewMatrix: IDENTITY_MATRIX,\n  projectionMatrix: IDENTITY_MATRIX,\n  cameraPositionWorld: [0, 0, 0]\n};\n\nfunction getUniforms(opts = DEFAULT_MODULE_OPTIONS, prevUniforms = {}) {\n  // const viewProjectionInverse = viewProjection.invert();\n  // viewInverseMatrix: view.invert(),\n  // viewProjectionInverseMatrix: viewProjectionInverse\n\n  const uniforms = {};\n  if (opts.modelMatrix !== undefined) {\n    uniforms.modelMatrix = opts.modelMatrix;\n  }\n  if (opts.viewMatrix !== undefined) {\n    uniforms.viewMatrix = opts.viewMatrix;\n  }\n  if (opts.projectionMatrix !== undefined) {\n    uniforms.projectionMatrix = opts.projectionMatrix;\n  }\n  if (opts.cameraPositionWorld !== undefined) {\n    uniforms.cameraPositionWorld = opts.cameraPositionWorld;\n  }\n\n  // COMPOSITE UNIFORMS\n  if (opts.projectionMatrix !== undefined || opts.viewMatrix !== undefined) {\n    uniforms.viewProjectionMatrix = new Matrix4(opts.projectionMatrix).multiplyRight(\n      opts.viewMatrix\n    );\n  }\n\n  return uniforms;\n}\n\nconst common = `\\\nvarying vec4 project_vPositionWorld;\nvarying vec3 project_vNormalWorld;\n\nvec4 project_getPosition_World() {\n  return project_vPositionWorld;\n}\n\nvec3 project_getNormal_World() {\n  return project_vNormalWorld;\n}\n`;\n\nconst vs = `\\\n${common}\n\n// Unprefixed uniforms\nuniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 viewProjectionMatrix;\nuniform vec3 cameraPositionWorld;\n\nstruct World {\n  vec3 position;\n  vec3 normal;\n};\n\nWorld world;\n\nvoid project_setPosition(vec4 position) {\n  project_vPositionWorld = position;\n}\n\nvoid project_setNormal(vec3 normal) {\n  project_vNormalWorld = normal;\n}\n\nvoid project_setPositionAndNormal_World(vec3 position, vec3 normal) {\n  world.position = position;\n  world.normal = normal;\n}\n\nvoid project_setPositionAndNormal_Model(vec3 position, vec3 normal) {\n  world.position = (modelMatrix * vec4(position, 1.)).xyz;\n  world.normal = mat3(modelMatrix) * normal;\n}\n\nvec4 project_model_to_clipspace(vec4 position) {\n  return viewProjectionMatrix * modelMatrix * position;\n}\n\nvec4 project_model_to_clipspace(vec3 position) {\n  return viewProjectionMatrix * modelMatrix * vec4(position, 1.);\n}\n\nvec4 project_world_to_clipspace(vec3 position) {\n  return viewProjectionMatrix * vec4(position, 1.);\n}\n\nvec4 project_view_to_clipspace(vec3 position) {\n  return projectionMatrix * vec4(position, 1.);\n}\n\nvec4 project_to_clipspace(vec3 position) {\n  return viewProjectionMatrix * vec4(position, 1.);\n}\n`;\n\nconst fs = `\n${common}\\\n`;\n\nexport default {\n  name: 'project',\n  getUniforms,\n  vs,\n  fs\n};\n","// Cheap lighting - single directional light, single dot product, one uniform\n\nimport project from '../project/project';\n\n/* eslint-disable camelcase */\nconst DEFAULT_LIGHT_DIRECTION = new Float32Array([1, 1, 2]);\n\nconst DEFAULT_MODULE_OPTIONS = {\n  lightDirection: DEFAULT_LIGHT_DIRECTION\n};\n\nfunction getUniforms(opts = DEFAULT_MODULE_OPTIONS) {\n  const uniforms = {};\n  if (opts.lightDirection) {\n    uniforms.dirlight_uLightDirection = opts.lightDirection;\n  }\n  return uniforms;\n}\n\n// TODO - reuse normal from geometry module\nconst vs = null;\n\nconst fs = `\\\nuniform vec3 dirlight_uLightDirection;\n\n/*\n * Returns color attenuated by angle from light source\n */\nvec4 dirlight_filterColor(vec4 color) {\n  vec3 normal = project_getNormal_World();\n  float d = abs(dot(normalize(normal), normalize(dirlight_uLightDirection)));\n  return vec4(color.rgb * d, color.a);\n}\n`;\n\nexport default {\n  name: 'dirlight',\n  vs,\n  fs,\n  getUniforms,\n  dependencies: [project]\n};\n","let channelHandles = 1;\nlet animationHandles = 1;\n\nexport class Timeline {\n  constructor() {\n    this.time = 0;\n    this.channels = new Map();\n    this.animations = new Map();\n    this.playing = false;\n    this.lastEngineTime = -1;\n  }\n\n  addChannel(props) {\n    const {delay = 0, duration = Number.POSITIVE_INFINITY, rate = 1, repeat = 1} = props;\n\n    const handle = channelHandles++;\n    const channel = {\n      time: 0,\n      delay,\n      duration,\n      rate,\n      repeat\n    };\n    this._setChannelTime(channel, this.time);\n    this.channels.set(handle, channel);\n\n    return handle;\n  }\n\n  removeChannel(handle) {\n    this.channels.delete(handle);\n\n    for (const [animationHandle, animation] of this.animations) {\n      if (animation.channel === handle) {\n        this.detachAnimation(animationHandle);\n      }\n    }\n  }\n\n  isFinished(handle) {\n    const channel = this.channels.get(handle);\n    if (channel === undefined) {\n      return false;\n    }\n\n    return this.time >= channel.delay + channel.duration * channel.repeat;\n  }\n\n  getTime(handle) {\n    if (handle === undefined) {\n      return this.time;\n    }\n\n    const channel = this.channels.get(handle);\n\n    if (channel === undefined) {\n      return -1;\n    }\n\n    return channel.time;\n  }\n\n  setTime(time) {\n    this.time = Math.max(0, time);\n\n    const channels = this.channels.values();\n    for (const channel of channels) {\n      this._setChannelTime(channel, this.time);\n    }\n\n    const animations = this.animations.values();\n    for (const animationData of animations) {\n      const {animation, channel} = animationData;\n      animation.setTime(this.getTime(channel));\n    }\n  }\n\n  play() {\n    this.playing = true;\n  }\n\n  pause() {\n    this.playing = false;\n    this.lastEngineTime = -1;\n  }\n\n  reset() {\n    this.setTime(0);\n  }\n\n  attachAnimation(animation, channelHandle) {\n    const animationHandle = animationHandles++;\n\n    this.animations.set(animationHandle, {\n      animation,\n      channel: channelHandle\n    });\n\n    animation.setTime(this.getTime(channelHandle));\n\n    return animationHandle;\n  }\n\n  detachAnimation(handle) {\n    this.animations.delete(handle);\n  }\n\n  update(engineTime) {\n    if (this.playing) {\n      if (this.lastEngineTime === -1) {\n        this.lastEngineTime = engineTime;\n      }\n      this.setTime(this.time + (engineTime - this.lastEngineTime));\n      this.lastEngineTime = engineTime;\n    }\n  }\n\n  _setChannelTime(channel, time) {\n    const offsetTime = time - channel.delay;\n    const totalDuration = channel.duration * channel.repeat;\n    // Note(Tarek): Don't loop on final repeat.\n    if (offsetTime >= totalDuration) {\n      channel.time = channel.duration * channel.rate;\n    } else {\n      channel.time = Math.max(0, offsetTime) % channel.duration;\n      channel.time *= channel.rate;\n    }\n  }\n}\n"],"sourceRoot":""}