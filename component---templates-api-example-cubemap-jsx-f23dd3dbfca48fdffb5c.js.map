{"version":3,"sources":["webpack:///../modules/engine/src/geometries/cube-geometry.js","webpack:///../modules/engine/src/geometry/geometry.js","webpack:///../examples/api/cubemap/app.js","webpack:///./templates/api/example-cubemap.jsx"],"names":["CUBE_INDICES","Uint16Array","CUBE_POSITIONS","Float32Array","CUBE_NORMALS","CUBE_TEX_COORDS","ATTRIBUTES","POSITION","size","value","NORMAL","TEXCOORD_0","CubeGeometry","props","id","uid","indices","attributes","Geometry","DRAW_MODE","POINTS","LINES","LINE_LOOP","LINE_STRIP","TRIANGLES","TRIANGLE_STRIP","TRIANGLE_FAN","drawMode","vertexCount","this","userData","_setAttributes","_calculateVertexCount","getVertexCount","getAttributes","_print","ArrayBuffer","attribute","assert","attributeName","isIndexed","Object","Math","Number","RoomCube","geometry","fs","vs","Model","Prism","AppAnimationLoop","getInfo","onInitialize","gl","canvas","setParameters","clearColor","clearDepth","depthTest","depthFunc","GL","LEQUAL","cubemap","data","loadImage","texture","mipmaps","parameters","cube","uniforms","uTextureCube","uModel","prism","uTexture","onRender","animationProps","aspect","tick","eyePosition","view","eye","projection","fov","radians","uView","uProjection","uEyePosition","AnimationLoop","window","animationLoop","Example","render","exampleConfig","pageContext","React","Component"],"mappings":"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","file":"component---templates-api-example-cubemap-jsx-f23dd3dbfca48fdffb5c.js","sourcesContent":["import Geometry from '../geometry/geometry';\nimport {uid} from '@luma.gl/webgl';\n\n// prettier-ignore\nconst CUBE_INDICES = new Uint16Array([\n  0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13,\n  14, 12, 14, 15, 16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23\n]);\n\n// prettier-ignore\nconst CUBE_POSITIONS = new Float32Array([\n  -1,  -1,  1, 1,  -1,  1,  1,  1,  1,  -1,  1,  1,\n  -1,  -1,  -1,  -1,  1,  -1,  1,  1,  -1,  1,  -1,  -1,\n  -1,  1,  -1,  -1,  1,  1,  1,  1,  1,  1,  1,  -1,\n  -1,  -1,  -1,  1,  -1,  -1,  1,  -1,  1,  -1,  -1,  1,\n  1,  -1,  -1,  1,  1,  -1,  1,  1,  1,  1,  -1,  1,\n  -1,  -1,  -1,  -1,  -1,  1,  -1,  1,  1,  -1,  1,  -1\n]);\n\n// TODO - could be Uint8\n// prettier-ignore\nconst CUBE_NORMALS = new Float32Array([\n  // Front face\n  0,  0,  1,  0,  0,  1,  0,  0,  1,  0,  0,  1,\n  // Back face\n  0,  0,  -1,  0,  0,  -1,  0,  0,  -1,  0,  0,  -1,\n  // Top face\n  0,  1,  0,  0,  1,  0,  0,  1,  0,  0,  1,  0,\n  // Bottom face\n  0,  -1,  0,  0,  -1,  0,  0,  -1,  0,  0,  -1,  0,\n  // Right face\n  1,  0,  0,  1,  0,  0,  1,  0,  0,  1,  0,  0,\n  // Left face\n  -1,  0,  0,  -1,  0,  0,  -1,  0,  0,  -1,  0,  0\n]);\n\n// prettier-ignore\nconst CUBE_TEX_COORDS = new Float32Array([\n  // Front face\n  0,  0,  1,  0,  1,  1,  0,  1,\n  // Back face\n  1,  0,  1,  1,  0,  1,  0,  0,\n  // Top face\n  0,  1,  0,  0,  1,  0,  1,  1,\n  // Bottom face\n  1,  1,  0,  1,  0,  0,  1,  0,\n  // Right face\n  1,  0,  1,  1,  0,  1,  0,  0,\n  // Left face\n  0,  0,  1,  0,  1,  1,  0,  1\n]);\n\nconst ATTRIBUTES = {\n  POSITION: {size: 3, value: new Float32Array(CUBE_POSITIONS)},\n  NORMAL: {size: 3, value: new Float32Array(CUBE_NORMALS)},\n  TEXCOORD_0: {size: 2, value: new Float32Array(CUBE_TEX_COORDS)}\n};\n\nexport default class CubeGeometry extends Geometry {\n  constructor(props = {}) {\n    const {id = uid('cube-geometry')} = props;\n    super({\n      ...props,\n      id,\n      indices: {size: 1, value: new Uint16Array(CUBE_INDICES)},\n      attributes: {...ATTRIBUTES, ...props.attributes}\n    });\n  }\n}\n","import {uid, assert} from '@luma.gl/webgl';\n\n// Rendering primitives - specify how to extract primitives from vertices.\n// NOTE: These are numerically identical to the corresponding WebGL/OpenGL constants\nexport const DRAW_MODE = {\n  POINTS: 0x0000, // draw single points.\n  LINES: 0x0001, // draw lines. Each vertex connects to the one after it.\n  LINE_LOOP: 0x0002, // draw lines. Each set of two vertices is treated as a separate line segment.\n  LINE_STRIP: 0x0003, // draw a connected group of line segments from the first vertex to the last\n  TRIANGLES: 0x0004, // draw triangles. Each set of three vertices creates a separate triangle.\n  TRIANGLE_STRIP: 0x0005, // draw a connected group of triangles.\n  TRIANGLE_FAN: 0x0006 // draw a connected group of triangles.\n  // Each vertex connects to the previous and the first vertex in the fan.\n};\n\nexport default class Geometry {\n  static get DRAW_MODE() {\n    return DRAW_MODE;\n  }\n\n  constructor(props = {}) {\n    const {\n      id = uid('geometry'),\n      drawMode = DRAW_MODE.TRIANGLES,\n      attributes = {},\n      indices = null,\n      vertexCount = null\n    } = props;\n\n    this.id = id;\n    this.drawMode = drawMode | 0;\n    this.attributes = {};\n    this.userData = {};\n\n    this._setAttributes(attributes, indices);\n\n    this.vertexCount = vertexCount || this._calculateVertexCount(this.attributes, this.indices);\n\n    // stubRemovedMethods(this, [\n    //   'setNeedsRedraw', 'needsRedraw', 'setAttributes'\n    // ], 'Immutable');\n\n    // stubRemovedMethods(this, [\n    //   'hasAttribute', 'getAttribute', 'getArray'\n    // ], 'Use geometry.attributes and geometry.indices');\n\n    // deprecateMethods(this, ['getAttributes'])\n  }\n\n  get mode() {\n    return this.drawMode;\n  }\n\n  getVertexCount() {\n    return this.vertexCount;\n  }\n\n  // Return an object with all attributes plus indices added as a field.\n  getAttributes() {\n    return this.indices ? {indices: this.indices, ...this.attributes} : this.attributes;\n  }\n\n  // PRIVATE\n\n  _print(attributeName) {\n    return `Geometry ${this.id} attribute ${attributeName}`;\n  }\n\n  // Attribute\n  // value: typed array\n  // type: indices, vertices, uvs\n  // size: elements per vertex\n  // target: WebGL buffer type (string or constant)\n  _setAttributes(attributes, indices) {\n    if (indices) {\n      this.indices = ArrayBuffer.isView(indices) ? {value: indices, size: 1} : indices;\n    }\n\n    for (const attributeName in attributes) {\n      let attribute = attributes[attributeName];\n\n      // Wrap \"unwrapped\" arrays and try to autodetect their type\n      attribute = ArrayBuffer.isView(attribute) ? {value: attribute} : attribute;\n\n      assert(\n        ArrayBuffer.isView(attribute.value),\n        `${this._print(attributeName)}: must be typed array or object with value as typed array`\n      );\n\n      if ((attributeName === 'POSITION' || attributeName === 'positions') && !attribute.size) {\n        attribute.size = 3;\n      }\n\n      // Move indices to separate field\n      if (attributeName === 'indices') {\n        assert(!this.indices);\n        this.indices = attribute;\n      } else {\n        this.attributes[attributeName] = attribute;\n      }\n    }\n\n    if (this.indices && this.indices.isIndexed !== undefined) {\n      this.indices = Object.assign({}, this.indices);\n      delete this.indices.isIndexed;\n    }\n\n    return this;\n  }\n\n  _calculateVertexCount(attributes, indices) {\n    if (indices) {\n      return indices.value.length;\n    }\n    let vertexCount = Infinity;\n    for (const attributeName in attributes) {\n      const attribute = attributes[attributeName];\n      const {value, size, constant} = attribute;\n      if (!constant && value && size >= 1) {\n        vertexCount = Math.min(vertexCount, value.length / size);\n      }\n    }\n\n    assert(Number.isFinite(vertexCount));\n    return vertexCount;\n  }\n}\n","import GL from '@luma.gl/constants';\nimport {AnimationLoop, Model, CubeGeometry} from '@luma.gl/engine';\nimport {Texture2D, TextureCube, loadImage} from '@luma.gl/webgl';\nimport {setParameters} from '@luma.gl/gltools';\nimport {Matrix4, radians} from 'math.gl';\n\nconst INFO_HTML = `\n<p>\nUses a luma.gl <code>TextureCube</code> to simulate a reflective\nsurface\n</p>\n`;\n\nclass RoomCube extends Model {\n  constructor(gl, props) {\n    const vs = `\\\nattribute vec3 positions;\n\nuniform mat4 uModel;\nuniform mat4 uView;\nuniform mat4 uProjection;\n\nvarying vec3 vPosition;\n\nvoid main(void) {\n  gl_Position = uProjection * uView * uModel * vec4(positions, 1.0);\n  vPosition = positions;\n}\n`;\n    const fs = `\\\nprecision highp float;\n\nuniform samplerCube uTextureCube;\nvarying vec3 vPosition;\n\nvoid main(void) {\n  // The outer cube just samples the texture cube directly\n  gl_FragColor = textureCube(uTextureCube, normalize(vPosition));\n}\n`;\n\n    super(gl, Object.assign({geometry: new CubeGeometry()}, props, {fs, vs}));\n  }\n}\n\nclass Prism extends Model {\n  constructor(gl, props) {\n    const vs = `\\\nattribute vec3 positions;\nattribute vec3 normals;\nattribute vec2 texCoords;\n\nuniform mat4 uModel;\nuniform mat4 uView;\nuniform mat4 uProjection;\n\nvarying vec3 vPosition;\nvarying vec3 vNormal;\nvarying vec2 vUV;\n\nvoid main(void) {\n  gl_Position = uProjection * uView * uModel * vec4(positions, 1.0);\n  vPosition = vec3(uModel * vec4(positions,1));\n  vNormal = vec3(uModel * vec4(normals, 0));\n  vUV = texCoords;\n}\n`;\n    const fs = `\\\nprecision highp float;\n\nuniform sampler2D uTexture;\nuniform samplerCube uTextureCube;\nuniform vec3 uEyePosition;\n\nvarying vec3 vPosition;\nvarying vec3 vNormal;\nvarying vec2 vUV;\n\nvoid main(void) {\n  vec4 color = texture2D(uTexture, vec2(vUV.x, 1.0 - vUV.y));\n  vec3 reflectedDir = reflect(normalize(vPosition - uEyePosition), vNormal);\n  vec4 reflectedColor = textureCube(uTextureCube, reflectedDir);\n\n  gl_FragColor = color * reflectedColor;\n}\n`;\n    super(gl, Object.assign({geometry: new CubeGeometry()}, props, {vs, fs}));\n  }\n}\n\nexport default class AppAnimationLoop extends AnimationLoop {\n  static getInfo() {\n    return INFO_HTML;\n  }\n\n  onInitialize({gl, canvas}) {\n    setParameters(gl, {\n      clearColor: [0, 0, 0, 1],\n      clearDepth: 1,\n      depthTest: true,\n      depthFunc: GL.LEQUAL\n    });\n\n    const cubemap = new TextureCube(gl, {\n      data: {\n        [gl.TEXTURE_CUBE_MAP_POSITIVE_X]: loadImage('sky-posx.png'),\n        [gl.TEXTURE_CUBE_MAP_NEGATIVE_X]: loadImage('sky-negx.png'),\n        [gl.TEXTURE_CUBE_MAP_POSITIVE_Y]: loadImage('sky-posy.png'),\n        [gl.TEXTURE_CUBE_MAP_NEGATIVE_Y]: loadImage('sky-negy.png'),\n        [gl.TEXTURE_CUBE_MAP_POSITIVE_Z]: loadImage('sky-posz.png'),\n        [gl.TEXTURE_CUBE_MAP_NEGATIVE_Z]: loadImage('sky-negz.png')\n      }\n    });\n\n    const texture = new Texture2D(gl, {\n      data: 'vis-logo.png',\n      mipmaps: true,\n      parameters: {\n        [gl.TEXTURE_MAG_FILTER]: gl.LINEAR,\n        [gl.TEXTURE_MIN_FILTER]: gl.LINEAR_MIPMAP_NEAREST\n      }\n    });\n\n    return {\n      cube: new RoomCube(gl, {\n        uniforms: {\n          uTextureCube: cubemap,\n          uModel: new Matrix4().scale([20, 20, 20])\n        }\n      }),\n      prism: new Prism(gl, {\n        uniforms: {\n          uTextureCube: cubemap,\n          uTexture: texture\n        }\n      })\n    };\n  }\n\n  onRender(animationProps) {\n    const {gl, aspect, cube, prism, tick} = animationProps;\n\n    const eyePosition = [5, -3, 5];\n    const view = new Matrix4().lookAt({eye: eyePosition});\n    const projection = new Matrix4().perspective({fov: radians(75), aspect});\n\n    gl.clear(GL.COLOR_BUFFER_BIT | GL.DEPTH_BUFFER_BIT);\n\n    cube.draw({\n      uniforms: {\n        uView: view,\n        uProjection: projection\n      }\n    });\n\n    prism.draw({\n      uniforms: {\n        uEyePosition: eyePosition,\n        uView: view,\n        uProjection: projection,\n        uModel: new Matrix4().rotateX(tick * 0.01).rotateY(tick * 0.013)\n      }\n    });\n  }\n}\n\n/* global window */\nif (typeof window !== 'undefined' && !window.website) {\n  const animationLoop = new AppAnimationLoop();\n  animationLoop.start();\n}\n","import React from 'react';\nimport AnimationLoopExamplePage from '../../src/components/animation-loop-example-page';\nimport AnimationLoop from '../../../examples/api/cubemap/app';\n\nexport default class Example extends React.Component {\n  render() {\n    return (\n      <AnimationLoopExamplePage AnimationLoop={AnimationLoop} exampleConfig={this.props.pageContext.exampleConfig} />\n    );\n  }\n}\n"],"sourceRoot":""}