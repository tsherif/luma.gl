{"version":3,"sources":["webpack:///../modules/webgl/src/classes/uniform-buffer-layout.js","webpack:///../examples/core/dof/app.js","webpack:///./templates/core/example-dof.jsx","webpack:///../modules/core/src/geometries/cube-geometry.js"],"names":["GL_FLOAT","GL_INT","GL_UNSIGNED_INT","UniformBufferLayout","this","layout","size","_addUniform","key","data","Float32Array","typedArray","Int32Array","Uint32Array","getBytes","getData","getSubData","index","offset","begin","offsets","end","sizes","subarray","setUniforms","_setValue","values","assert","typeAndComponents","decomposeCompositeGLType","type","count","_alignTo","QUAD_VERTS","focalLength","focusDistance","fStop","texelOffset","InstancedCube","props","xforms","Array","matrices","matrixBuffer","Object","geometry","vs","fs","isInstanced","instanceCount","uniforms","uTexture","attributes","modelMatCol1","buffer","stride","divisor","modelMatCol2","modelMatCol3","modelMatCol4","updateMatrixBuffer","setData","Model","AppAnimationLoop","getInfo","onInitialize","gl","_animationLoop","isDemoSupported","isWebGL2","setParameters","depthTest","depthFunc","GL","LEQUAL","projMat","viewMat","eye","dofUniformsLayout","uDepthRange","uFocusDistance","uBlurCoefficient","uPPM","FLOAT","dofUniforms","target","accessor","dofProgram","id","sceneFramebuffer","width","height","attachments","format","mipmaps","parameters","dataFormat","dofFramebuffer","depth","focalLengthInput","document","focusDistanceInput","fStopInput","parseFloat","texture","instancedCubes","CUBES_PER_ROW","cubeI","j","rowOffset","Math","NUM_ROWS","i","scale","rotate","translate","matrix","quadVertexArray","program","aPosition","onRender","aspect","tick","magnification","blurCoefficient","ppm","clear","color","framebuffer","fov","radians","near","far","center","up","box","uProjection","uView","uTexelOffset","uColor","uDepth","vertexArray","drawMode","vertexCount","isSupported","getAltText","AnimationLoop","window","animationLoop","Example","render","exampleConfig","pageContext","React","Component","CUBE_INDICES","Uint16Array","CUBE_POSITIONS","CUBE_NORMALS","CUBE_TEX_COORDS","ATTRIBUTES","POSITION","value","NORMAL","TEXCOORD_0","CubeGeometry","uid","indices","Geometry"],"mappings":"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","file":"component---templates-core-example-dof-jsx-d4ba5339e393965d01a5.js","sourcesContent":["/* eslint-disable camelcase */\nimport {decomposeCompositeGLType} from '../webgl-utils/attribute-utils';\nimport {assert} from '../utils';\n\nconst ERR_ARGUMENT = 'UniformBufferLayout illegal argument';\n\n// Local constants - these will \"collapse\" during minification\nconst GL_FLOAT = 0x1406;\nconst GL_INT = 0x1404;\nconst GL_UNSIGNED_INT = 0x1405;\n\n// Std140 layout for uniforms\nexport default class UniformBufferLayout {\n  constructor(layout) {\n    this.layout = {};\n    this.size = 0;\n\n    // Add layout (type, size and offset) definitions for each uniform in the layout\n    for (const key in layout) {\n      this._addUniform(key, layout[key]);\n    }\n\n    this.size += (4 - (this.size % 4)) % 4;\n\n    // Allocate three typed arrays pointing at same memory\n    const data = new Float32Array(this.size);\n    this.typedArray = {\n      [GL_FLOAT]: data,\n      [GL_INT]: new Int32Array(data.buffer),\n      [GL_UNSIGNED_INT]: new Uint32Array(data.buffer)\n    };\n  }\n\n  // Get number of bytes needed for buffer allocation\n  getBytes() {\n    return this.size * 4;\n  }\n\n  // Get the current data as Float32Array, for bufferSubData\n  getData() {\n    return this.typedArray[GL_FLOAT];\n  }\n\n  // Get offset and data for one object (for bufferSubData)\n  getSubData(index) {\n    let data;\n    let offset;\n    if (index === undefined) {\n      data = this.data;\n      offset = 0;\n    } else {\n      const begin = this.offsets[index];\n      const end = begin + this.sizes[index];\n      data = this.data.subarray(begin, end);\n      offset = begin * 4;\n    }\n    return {data, offset};\n  }\n\n  // Set a map of values\n  setUniforms(values) {\n    for (const key in values) {\n      this._setValue(key, values[key]);\n    }\n    return this;\n  }\n\n  _setValue(key, value) {\n    const layout = this.layout[key];\n    assert(layout, 'UniformLayoutStd140 illegal argument');\n    const typedArray = this.typedArray[layout.type];\n    if (layout.size === 1) {\n      // single value -> just set it\n      typedArray[layout.offset] = value;\n    } else {\n      // vector/matrix -> copy the supplied (typed) array, starting from offset\n      typedArray.set(value, layout.offset);\n    }\n  }\n\n  _addUniform(key, uniformType) {\n    const typeAndComponents = decomposeCompositeGLType(uniformType);\n    assert(typeAndComponents, ERR_ARGUMENT);\n    const {type, components: count} = typeAndComponents;\n\n    // First, align (bump) current offset to an even multiple of current object (1, 2, 4)\n    this.size = this._alignTo(this.size, count);\n    // Use the aligned size as the offset of the current uniform.\n    const offset = this.size;\n    // Then, add our object's padded size ((1, 2, multiple of 4) to the current offset\n    this.size += count;\n\n    this.layout[key] = {type, size: count, offset};\n  }\n\n  // Align offset to 1, 2 or 4 elements (4, 8 or 16 bytes)\n  _alignTo(size, count) {\n    switch (count) {\n      case 1:\n        return size; // Pad upwards to even multiple of 2\n      case 2:\n        return size + (size % 2); // Pad upwards to even multiple of 2\n      default:\n        return size + ((4 - (size % 4)) % 4); // Pad upwards to even multiple of 4\n    }\n  }\n}\n","import GL from '@luma.gl/constants';\nimport {\n  AnimationLoop,\n  Framebuffer,\n  setParameters,\n  clear,\n  Program,\n  Texture2D,\n  VertexArray,\n  UniformBufferLayout,\n  Buffer,\n  isWebGL2,\n  Model,\n  CubeGeometry\n} from '@luma.gl/core';\nimport {Matrix4, radians} from 'math.gl';\n/* eslint-disable spaced-comment */\n/* global document */\n\n/*\n  Based on: https://github.com/tsherif/picogl.js/blob/master/examples/dof.html\n  Original algorithm: http://www.nutty.ca/?page_id=352&link=depth_of_field\n*/\n\nconst INFO_HTML = `\n<p>\n  <b>Depth of Field</b>.\n<p>\nSeveral instanced luma.gl <code>Cubes</code> rendered with a Depth of Field\npost-processing effect.\n\n<div>\n  Focal Length: <input type=\"range\" id=\"focal-length\" min=\"0.1\" max=\"10.0\" step=\"0.1\">\n</div>\n<div>\n  Focus Distance: <input type=\"range\" id=\"focus-distance\" min=\"0.1\" max=\"10.0\" step=\"0.1\">\n</div>\n<div>\n  F-Stop: <input type=\"range\" id=\"f-stop\" min=\"0.1\" max=\"10.0\" step=\"0.1\">\n</div>\n\n`;\n\nconst ALT_TEXT = \"THIS DEMO REQUIRES WEBLG2, BUT YOUR BROWSER DOESN'T SUPPORT IT\";\n\nconst QUAD_VERTS = [1, 1, 0, -1, 1, 0, 1, -1, 0, -1, -1, 0]; // eslint-disable-line\nconst NUM_ROWS = 5;\nconst CUBES_PER_ROW = 20;\nconst NUM_CUBES = CUBES_PER_ROW * NUM_ROWS;\nconst NEAR = 0.1;\nconst FAR = 30.0;\n\nlet focalLength = 2.0;\nlet focusDistance = 3.0;\nlet fStop = 2.8;\nconst texelOffset = new Float32Array(2);\n\nclass InstancedCube extends Model {\n  constructor(gl, props) {\n    const count = props.count;\n    const xforms = new Array(count);\n    const matrices = new Float32Array(count * 16);\n    const matrixBuffer = new Buffer(gl, matrices.byteLength);\n\n    const vs = `\\\n#version 300 es\n#define SHADER_NAME scene.vs\n\nin vec3 positions;\nin vec3 normals;\nin vec2 texCoords;\nin vec4 modelMatCol1;\nin vec4 modelMatCol2;\nin vec4 modelMatCol3;\nin vec4 modelMatCol4;\n\nuniform mat4 uView;\nuniform mat4 uProjection;\nout vec3 vNormal;\nout vec2 vUV;\n\nvoid main(void) {\n  mat4 modelMat = mat4(\n    modelMatCol1,\n    modelMatCol2,\n    modelMatCol3,\n    modelMatCol4\n  );\n  gl_Position = uProjection * uView * modelMat * vec4(positions, 1.0);\n  vNormal = vec3(modelMat * vec4(normals, 0.0));\n  vUV = texCoords;\n}\n`;\n    const fs = `\\\n#version 300 es\nprecision highp float;\n#define SHADER_NAME scene.fs\n\nin vec3 vNormal;\nin vec2 vUV;\nuniform sampler2D uTexture;\n\nout vec4 fragColor;\nvoid main(void) {\n  float d = clamp(dot(normalize(vNormal), normalize(vec3(1.0, 1.0, 0.2))), 0.0, 1.0);\n  fragColor.rgb = texture(uTexture, vUV).rgb * (d + 0.1);\n  fragColor.a = 1.0;\n}\n`;\n\n    super(\n      gl,\n      Object.assign({geometry: new CubeGeometry()}, props, {\n        vs,\n        fs,\n        isInstanced: 1,\n        instanceCount: count,\n        uniforms: {\n          uTexture: props.uniforms.uTexture\n        },\n        attributes: {\n          // Attributes are limited to 4 components,\n          // So we have to split the matrices across\n          // 4 attributes. They're reconstructed in\n          // the vertex shader.\n          modelMatCol1: {\n            buffer: matrixBuffer,\n            size: 4,\n            stride: 64,\n            offset: 0,\n            divisor: 1\n          },\n          modelMatCol2: {\n            buffer: matrixBuffer,\n            size: 4,\n            stride: 64,\n            offset: 16,\n            divisor: 1\n          },\n          modelMatCol3: {\n            buffer: matrixBuffer,\n            size: 4,\n            stride: 64,\n            offset: 32,\n            divisor: 1\n          },\n          modelMatCol4: {\n            buffer: matrixBuffer,\n            size: 4,\n            stride: 64,\n            offset: 48,\n            divisor: 1\n          }\n        }\n      })\n    );\n\n    this.count = count;\n    this.xforms = xforms;\n    this.matrices = matrices;\n    this.matrixBuffer = matrixBuffer;\n  }\n\n  updateMatrixBuffer() {\n    this.matrixBuffer.setData(this.matrices);\n  }\n}\n\nconst DOF_VERTEX = `\\\n#version 300 es\n#define SHADER_NAME quad.vs\n\nlayout(location=0) in vec3 aPosition;\n\nvoid main() {\n    gl_Position = vec4(aPosition, 1.0);\n}\n`;\n\nconst DOF_FRAGMENT = `\\\n#version 300 es\nprecision highp float;\n#define SHADER_NAME dof.fs\n\n#define MAX_BLUR 20.0\n\nuniform DOFUniforms {\n  vec2  uDepthRange;\n  float uFocusDistance;\n  float uBlurCoefficient;\n  float uPPM;\n};\n\nuniform vec2 uTexelOffset;\n\nuniform sampler2D uColor;\nuniform sampler2D uDepth;\n\nout vec4 fragColor;\n\nvoid main() {\n    ivec2 fragCoord = ivec2(gl_FragCoord.xy);\n    ivec2 resolution = textureSize(uColor, 0) - 1;\n\n    // Convert to linear depth\n    float ndc = 2.0 * texelFetch(uDepth, fragCoord, 0).r - 1.0;\n    float depth = -(2.0 * uDepthRange.y * uDepthRange.x) / (ndc * (uDepthRange.y - uDepthRange.x) - uDepthRange.y - uDepthRange.x);\n    float deltaDepth = abs(uFocusDistance - depth);\n\n    // Blur more quickly in the foreground.\n    float xdd = depth < uFocusDistance ? abs(uFocusDistance - deltaDepth) : abs(uFocusDistance + deltaDepth);\n    float blurRadius = min(floor(uBlurCoefficient * (deltaDepth / xdd) * uPPM), MAX_BLUR);\n\n    vec4 color = vec4(0.0);\n    if (blurRadius > 1.0) {\n        float halfBlur = blurRadius * 0.5;\n\n        float count = 0.0;\n\n        for (float i = 0.0; i <= MAX_BLUR; ++i) {\n            if (i > blurRadius) {\n                break;\n            }\n\n            // texelFetch outside texture gives vec4(0.0) (undefined in ES 3)\n            ivec2 sampleCoord = clamp(fragCoord + ivec2(((i - halfBlur) * uTexelOffset)), ivec2(0), resolution);\n            color += texelFetch(uColor, sampleCoord, 0);\n\n            ++count;\n        }\n\n        color /= count;\n    } else {\n        color = texelFetch(uColor, fragCoord, 0);\n    }\n\n    fragColor = color;\n}\n`;\n\nexport default class AppAnimationLoop extends AnimationLoop {\n  static getInfo() {\n    return INFO_HTML;\n  }\n\n  constructor(props = {}) {\n    super(props);\n    // Default value is true, so GL context is always created to verify wheter it is WebGL2 or not.\n    this.isDemoSupported = true;\n  }\n\n  onInitialize({gl, _animationLoop}) {\n    this.isDemoSupported = isWebGL2(gl);\n    if (!this.isDemoSupported) {\n      return {};\n    }\n\n    setParameters(gl, {\n      depthTest: true,\n      depthFunc: GL.LEQUAL\n    });\n\n    const projMat = new Matrix4();\n    const viewMat = new Matrix4().lookAt({eye: [0, 0, 8]});\n\n    ///////////////////////////////////////\n    // Create postprocessing pass program.\n    ///////////////////////////////////////\n\n    const dofUniformsLayout = new UniformBufferLayout({\n      uDepthRange: gl.FLOAT_VEC2,\n      uFocusDistance: gl.FLOAT,\n      uBlurCoefficient: gl.FLOAT,\n      uPPM: gl.FLOAT\n    }).setUniforms({\n      uDepthRange: [NEAR, FAR]\n    });\n\n    const dofUniforms = new Buffer(gl, {\n      target: GL.UNIFORM_BUFFER,\n      data: dofUniformsLayout.getData(),\n      accessor: {\n        index: 0\n      }\n    });\n\n    const dofProgram = new Program(gl, {\n      id: 'DOF_PROGRAM',\n      vs: DOF_VERTEX,\n      fs: DOF_FRAGMENT\n    });\n\n    dofProgram.uniformBlockBinding(dofProgram.getUniformBlockIndex('DOFUniforms'), 0);\n\n    //////////////////////\n    // Set up frambuffers.\n    //////////////////////\n\n    // Need to ensure both color and depth targets can be sampled.\n    const sceneFramebuffer = new Framebuffer(gl, {\n      width: gl.drawingBufferWidth,\n      height: gl.drawingBufferHeight,\n      attachments: {\n        [GL.COLOR_ATTACHMENT0]: new Texture2D(gl, {\n          format: GL.RGBA,\n          type: GL.UNSIGNED_BYTE,\n          width: gl.drawingBufferWidth,\n          height: gl.drawingBufferHeight,\n          mipmaps: false,\n          parameters: {\n            [GL.TEXTURE_MIN_FILTER]: GL.LINEAR,\n            [GL.TEXTURE_MAG_FILTER]: GL.LINEAR,\n            [GL.TEXTURE_WRAP_S]: GL.CLAMP_TO_EDGE,\n            [GL.TEXTURE_WRAP_T]: GL.CLAMP_TO_EDGE\n          }\n        }),\n        [GL.DEPTH_ATTACHMENT]: new Texture2D(gl, {\n          format: GL.DEPTH_COMPONENT16,\n          type: GL.UNSIGNED_SHORT,\n          dataFormat: GL.DEPTH_COMPONENT,\n          width: gl.drawingBufferWidth,\n          height: gl.drawingBufferHeight,\n          mipmaps: false,\n          parameters: {\n            [GL.TEXTURE_MIN_FILTER]: GL.NEAREST,\n            [GL.TEXTURE_MAG_FILTER]: GL.NEAREST,\n            [GL.TEXTURE_WRAP_S]: GL.CLAMP_TO_EDGE,\n            [GL.TEXTURE_WRAP_T]: GL.CLAMP_TO_EDGE\n          }\n        })\n      }\n    });\n\n    // Postprocessing FBO doesn't need a depth attachment.\n    const dofFramebuffer = new Framebuffer(gl, {\n      width: gl.drawingBufferWidth,\n      height: gl.drawingBufferHeight,\n      depth: false\n    });\n\n    /////////////////////\n    // Input handlers.\n    /////////////////////\n\n    const focalLengthInput = document.getElementById('focal-length');\n    const focusDistanceInput = document.getElementById('focus-distance');\n    const fStopInput = document.getElementById('f-stop');\n\n    if (focalLengthInput) {\n      focalLengthInput.value = focalLength;\n      focalLengthInput.addEventListener('input', () => {\n        focalLength = parseFloat(focalLengthInput.value);\n      });\n\n      focusDistanceInput.value = focusDistance;\n      focusDistanceInput.addEventListener('input', () => {\n        focusDistance = parseFloat(focusDistanceInput.value);\n      });\n\n      fStopInput.value = fStop;\n      fStopInput.addEventListener('input', () => {\n        fStop = parseFloat(fStopInput.value);\n      });\n    }\n\n    const texture = new Texture2D(gl, {\n      data: 'webgl-logo.png',\n      mipmaps: true,\n      parameters: {\n        [gl.TEXTURE_MAG_FILTER]: gl.LINEAR,\n        [gl.TEXTURE_MIN_FILTER]: gl.LINEAR_MIPMAP_NEAREST\n      }\n    });\n\n    /////////////////////////////////////////////////////\n    // Create instanced model and initialize transform matrices.\n    /////////////////////////////////////////////////////\n\n    const instancedCubes = new InstancedCube(gl, {\n      count: NUM_CUBES,\n      uniforms: {\n        uTexture: texture\n      }\n    });\n\n    let cubeI = 0;\n    for (let j = 0; j < NUM_ROWS; ++j) {\n      const rowOffset = j - Math.floor(NUM_ROWS / 2);\n      for (let i = 0; i < CUBES_PER_ROW; ++i) {\n        const scale = [0.4, 0.4, 0.4];\n        const rotate = [-Math.random() * Math.PI, 0, Math.random() * Math.PI];\n        const translate = [-i + 2 - rowOffset, 0, -i + 2 + rowOffset];\n        instancedCubes.xforms[cubeI] = {\n          scale,\n          translate,\n          rotate,\n          matrix: new Matrix4()\n            .translate(translate)\n            .rotateXYZ(rotate)\n            .scale(scale)\n        };\n\n        instancedCubes.matrices.set(instancedCubes.xforms[cubeI].matrix, cubeI * 16);\n        ++cubeI;\n      }\n    }\n\n    instancedCubes.updateMatrixBuffer();\n\n    /////////////////////////////////////////////\n    // Full-screen quad VAO for postprocessing\n    // passes.\n    /////////////////////////////////////////////\n\n    const quadVertexArray = new VertexArray(gl, {\n      program: dofProgram,\n      attributes: {\n        aPosition: new Buffer(gl, new Float32Array(QUAD_VERTS))\n      }\n    });\n\n    return {\n      projMat,\n      viewMat,\n      instancedCubes,\n      sceneFramebuffer,\n      dofFramebuffer,\n      quadVertexArray,\n      dofProgram,\n      dofUniforms,\n      dofUniformsLayout\n    };\n  }\n\n  onRender({\n    gl,\n    tick,\n    width,\n    height,\n    aspect,\n    projMat,\n    viewMat,\n    instancedCubes,\n    sceneFramebuffer,\n    dofFramebuffer,\n    quadVertexArray,\n    dofProgram,\n    dofUniforms,\n    dofUniformsLayout\n  }) {\n    if (!this.isDemoSupported) {\n      return;\n    }\n\n    sceneFramebuffer.resize(gl.drawingBufferWidth, gl.drawingBufferHeight);\n    dofFramebuffer.resize(gl.drawingBufferWidth, gl.drawingBufferHeight);\n\n    const magnification = focalLength / Math.max(0.1, Math.abs(focusDistance - focalLength));\n    const blurCoefficient = (focalLength * magnification) / fStop;\n    const ppm =\n      Math.sqrt(\n        gl.drawingBufferWidth * gl.drawingBufferWidth +\n          gl.drawingBufferHeight * gl.drawingBufferHeight\n      ) / 35;\n\n    clear(gl, {color: [0, 0, 0, 1], depth: true, framebuffer: sceneFramebuffer});\n\n    projMat.perspective({fov: radians(75), aspect, near: NEAR, far: FAR});\n    viewMat.lookAt({eye: [3, 1.5, 3], center: [0, 0, 0], up: [0, 1, 0]});\n\n    ////////////////////////////////////////\n    // Update model matrix data and then\n    // update the attribute buffer.\n    ////////////////////////////////////////\n\n    for (let i = 0; i < NUM_CUBES; ++i) {\n      const box = instancedCubes.xforms[i];\n      box.rotate[0] += 0.01;\n      box.rotate[1] += 0.02;\n      box.matrix\n        .identity()\n        .translate(box.translate)\n        .rotateXYZ(box.rotate)\n        .scale(box.scale);\n      instancedCubes.matrices.set(box.matrix, i * 16);\n    }\n\n    instancedCubes.updateMatrixBuffer();\n\n    ////////////////////////////////////\n    // Draw cubes to scene framebuffer.\n    ////////////////////////////////////\n\n    instancedCubes.draw({\n      uniforms: {\n        uProjection: projMat,\n        uView: viewMat\n      },\n      framebuffer: sceneFramebuffer\n    });\n\n    /////////////////\n    // Apply DOF\n    /////////////////\n\n    // Horizontal DOF blur\n    clear(gl, {color: [0, 0, 0, 1], framebuffer: dofFramebuffer});\n\n    // texelOffset determines the direction of the blur\n    texelOffset[0] = 1;\n    texelOffset[1] = 0;\n\n    dofUniformsLayout.setUniforms({\n      uFocusDistance: focusDistance,\n      uBlurCoefficient: blurCoefficient,\n      uPPM: ppm\n    });\n\n    dofUniforms.setData(dofUniformsLayout.getData());\n\n    dofUniforms.bind();\n\n    dofProgram.setUniforms({\n      uTexelOffset: texelOffset,\n      uColor: sceneFramebuffer.color,\n      uDepth: sceneFramebuffer.depth\n    });\n\n    dofProgram.draw({\n      vertexArray: quadVertexArray,\n      drawMode: gl.TRIANGLE_STRIP,\n      vertexCount: 4,\n      framebuffer: dofFramebuffer\n    });\n\n    // Vertical DOF blur\n    clear(gl, {color: [0, 0, 0, 1]});\n\n    texelOffset[0] = 0;\n    texelOffset[1] = 1;\n\n    dofProgram.setUniforms({\n      uTexelOffset: texelOffset,\n      uColor: sceneFramebuffer.color,\n      uDepth: sceneFramebuffer.depth\n    });\n\n    dofProgram.draw({\n      vertexArray: quadVertexArray,\n      drawMode: gl.TRIANGLE_STRIP,\n      vertexCount: 4\n    });\n\n    dofUniforms.unbind();\n  }\n\n  isSupported() {\n    return this.isDemoSupported;\n  }\n\n  getAltText() {\n    return ALT_TEXT;\n  }\n}\n\n/* global window */\nif (typeof window !== 'undefined' && !window.website) {\n  const animationLoop = new AppAnimationLoop();\n  animationLoop.start();\n}\n","import React from 'react';\nimport AnimationLoopExamplePage from '../../src/components/animation-loop-example-page';\nimport AnimationLoop from '../../../examples/core/dof/app';\n\nexport default class Example extends React.Component {\n\n  render() {\n    return (\n      <AnimationLoopExamplePage AnimationLoop={AnimationLoop} exampleConfig={this.props.pageContext.exampleConfig} />\n    );\n  }\n}\n","import Geometry from '../geometry/geometry';\nimport {uid} from '../utils';\n\n// prettier-ignore\nconst CUBE_INDICES = new Uint16Array([\n  0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13,\n  14, 12, 14, 15, 16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23\n]);\n\n// prettier-ignore\nconst CUBE_POSITIONS = new Float32Array([\n  -1,  -1,  1, 1,  -1,  1,  1,  1,  1,  -1,  1,  1,\n  -1,  -1,  -1,  -1,  1,  -1,  1,  1,  -1,  1,  -1,  -1,\n  -1,  1,  -1,  -1,  1,  1,  1,  1,  1,  1,  1,  -1,\n  -1,  -1,  -1,  1,  -1,  -1,  1,  -1,  1,  -1,  -1,  1,\n  1,  -1,  -1,  1,  1,  -1,  1,  1,  1,  1,  -1,  1,\n  -1,  -1,  -1,  -1,  -1,  1,  -1,  1,  1,  -1,  1,  -1\n]);\n\n// TODO - could be Uint8\n// prettier-ignore\nconst CUBE_NORMALS = new Float32Array([\n  // Front face\n  0,  0,  1,  0,  0,  1,  0,  0,  1,  0,  0,  1,\n  // Back face\n  0,  0,  -1,  0,  0,  -1,  0,  0,  -1,  0,  0,  -1,\n  // Top face\n  0,  1,  0,  0,  1,  0,  0,  1,  0,  0,  1,  0,\n  // Bottom face\n  0,  -1,  0,  0,  -1,  0,  0,  -1,  0,  0,  -1,  0,\n  // Right face\n  1,  0,  0,  1,  0,  0,  1,  0,  0,  1,  0,  0,\n  // Left face\n  -1,  0,  0,  -1,  0,  0,  -1,  0,  0,  -1,  0,  0\n]);\n\n// prettier-ignore\nconst CUBE_TEX_COORDS = new Float32Array([\n  // Front face\n  0,  0,  1,  0,  1,  1,  0,  1,\n  // Back face\n  1,  0,  1,  1,  0,  1,  0,  0,\n  // Top face\n  0,  1,  0,  0,  1,  0,  1,  1,\n  // Bottom face\n  1,  1,  0,  1,  0,  0,  1,  0,\n  // Right face\n  1,  0,  1,  1,  0,  1,  0,  0,\n  // Left face\n  0,  0,  1,  0,  1,  1,  0,  1\n]);\n\nconst ATTRIBUTES = {\n  POSITION: {size: 3, value: new Float32Array(CUBE_POSITIONS)},\n  NORMAL: {size: 3, value: new Float32Array(CUBE_NORMALS)},\n  TEXCOORD_0: {size: 2, value: new Float32Array(CUBE_TEX_COORDS)}\n};\n\nexport default class CubeGeometry extends Geometry {\n  constructor(props = {}) {\n    const {id = uid('cube-geometry')} = props;\n    super({\n      ...props,\n      id,\n      indices: {size: 1, value: new Uint16Array(CUBE_INDICES)},\n      attributes: {...ATTRIBUTES, ...props.attributes}\n    });\n  }\n}\n"],"sourceRoot":""}