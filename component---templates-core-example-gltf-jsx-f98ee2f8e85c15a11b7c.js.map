{"version":3,"sources":["webpack:///../modules/core/src/scenegraph/nodes/group-node.js","webpack:///../modules/addons/src/gltf/gltf-animator.js","webpack:///../modules/shadertools/src/modules/project2/project2.vertex.glsl.js","webpack:///../modules/shadertools/src/modules/lights/lights.glsl.js","webpack:///../modules/shadertools/src/modules/lights/lights.js","webpack:///../modules/shadertools/src/modules/pbr/pbr-vertex.glsl.js","webpack:///../modules/shadertools/src/modules/pbr/pbr.js","webpack:///../modules/shadertools/src/modules/pbr/pbr-fragment.glsl.js","webpack:///../modules/shadertools/src/modules/project2/project2.js","webpack:///../modules/addons/src/gltf/gltf-material-parser.js","webpack:///../modules/addons/src/gltf/create-gltf-model.js","webpack:///../modules/addons/src/gltf/gltf-instantiator.js","webpack:///../modules/addons/src/gltf/create-gltf-objects.js","webpack:///../modules/addons/src/gltf/gltf-scenegraph-loader.js","webpack:///../modules/addons/src/gltf/gltf-environment.js","webpack:///../examples/core/gltf/app.js","webpack:///./templates/core/example-gltf.jsx","webpack:///../modules/shadertools/src/utils/webgl-info.js","webpack:///../modules/shadertools/src/utils/is-old-ie.js","webpack:///../modules/shadertools/src/lib/platform-defines.js","webpack:///../modules/shadertools/src/lib/assemble-shaders.js","webpack:///../modules/shadertools/src/lib/shader-module-registry.js","webpack:///../modules/shadertools/src/lib/resolve-modules.js","webpack:///../modules/core/src/scenegraph/nodes/scenegraph-node.js","webpack:///../modules/core/src/lib/model-utils.js","webpack:///../modules/core/src/resource-management/program-manager.js","webpack:///../modules/webgl/src/utils/format-value.js","webpack:///../modules/webgl/src/debug/debug-vertex-array.js","webpack:///../modules/webgl/src/debug/debug-uniforms.js","webpack:///../modules/webgl/src/debug/debug-program-configuration.js","webpack:///../modules/core/src/debug/seer-integration.js","webpack:///../modules/core/src/lib/base-model.js","webpack:///../modules/core/src/lib/model.js","webpack:///../modules/shadertools/src/lib/transpile-shader.js","webpack:///../modules/shadertools/src/lib/filters/prop-types.js","webpack:///../modules/shadertools/src/lib/shader-module.js","webpack:///../modules/shadertools/src/lib/inject-shader.js","webpack:///../modules/shadertools/src/modules/module-injectors.js","webpack:///../modules/shadertools/src/index.js","webpack:///../modules/shadertools/src/shaders/modular-vertex.glsl.js","webpack:///../modules/shadertools/src/shaders/modular-fragment.glsl.js","webpack:///../modules/shadertools/src/lib/constants.js","webpack:///../modules/core/src/scenegraph/nodes/model-node.js","webpack:///../modules/shadertools/src/utils/assert.js","webpack:///../modules/webgl/src/classes/transform-feedback.js","webpack:///../modules/addons/src/animation/timeline.js"],"names":["GroupNode","props","_this","_props$children","Array","isArray","children","log","every","child","scenegraph_node","_ScenegraphNode","call","this","add","_len","arguments","length","_key","_i","_children","apply","_toConsumableArray","push","remove","indexOf","removeAll","delete","forEach","prototype","traverse","_ref$worldMatrix","_temp","worldMatrix","matrix4","modelMatrix","multiplyRight","matrix","_iterator","_isArray","_i2","Symbol","iterator","_ref2","next","done","value","visitor","traverseReverse","opts","ScenegraphNode","ATTRIBUTE_TYPE_TO_COMPONENTS","SCALAR","VEC2","VEC3","VEC4","MAT2","MAT3","MAT4","ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY","5120","Int8Array","5121","Uint8Array","5122","Int16Array","5123","Uint16Array","5125","Uint32Array","5126","Float32Array","accessorToJsArray","accessor","_animation","ArrayType","componentType","components","type","count","_accessor$bufferView$","data","array","buffer","byteOffset","slicedArray","i","helperMatrix","quaternion","interpolate","time","target","path","input","interpolation","output","animationTime","nextIndex","findIndex","t","previousIndex","Math","assert","previousTime","nextTime","stepInterpolate","ratio","start","stop","linearInterpolate","tDiff","_ref","p0","outTangent0","inTangent1","p1","m0","m1","cubicsplineInterpolate","GLTFAnimation","startTime","playing","speed","Object","animate","timeMs","channels","_ref3","sampler","gltfNode","node","translation","rotation","rotationMatrix","scale","applyTranslationRotationScale","GLTFAnimator","gltf","animations","map","animation","index","name","samplers","_ref4","_ref4$interpolation","_ref5","setTime","getAnimations","project2_vertex_glsl","lights_glsl","lights","vs","fs","getUniforms","INITIAL_MODULE_OPTIONS","ambientLight","pointLights","directionalLights","hasLights","assign","_ref2$pointLights","_ref2$directionalLigh","lightSourceUniforms","convertColor","pointLight","directionalLight","getLightSourceUniforms","lighting_uEnabled","lightSources","light","defines","MAX_LIGHTS","_ref$color","color","_ref$intensity","intensity","component","pbr","LIGHTING_FRAGMENT","dependencies","GLTFMaterialParser","gl","attributes","material","pbrDebug","imageBasedLightingEnvironment","useTangents","USE_TEX_LOD","MANUAL_SRGB","SRGB_FAST_APPROXIMATION","uniforms","u_Camera","u_MetallicRoughnessValues","parameters","generatedTextures","u_DiffuseEnvSampler","getDiffuseEnvSampler","u_SpecularEnvSampler","getSpecularEnvSampler","u_brdfLUT","getBrdfTexture","u_ScaleIBLAmbient","u_ScaleDiffBaseMR","u_ScaleFGDSpec","defineIfPresent","NORMAL","TEXCOORD_0","parseMaterial","parseTexture","_pixelStore","define","gltfTexture","texture","texture_2d","id","pixelStore","UNPACK_FLIP_Y_WEBGL","parsePbrMetallicRoughness","pbrMetallicRoughness","baseColorTexture","u_BaseColorFactor","metallicRoughnessTexture","_pbrMetallicRoughness","metallicFactor","_pbrMetallicRoughness2","roughnessFactor","normalTexture","_material$normalTextu","u_NormalScale","occlusionTexture","_material$occlusionTe","strength","u_OcclusionStrength","emissiveTexture","u_EmissiveFactor","_material$alphaCutoff","alphaCutoff","ALPHA_CUTOFF","u_AlphaCutoff","blend","blendEquation","FUNC_ADD","blendFunc","SRC_ALPHA","ONE_MINUS_SRC_ALPHA","ONE","addVersionToShader","source","isWebGL2","DEFAULT_OPTIONS","modelOptions","GLTFInstantiator","options","instantiate","scene","createScene","createAnimator","_this2","nodes","gltfScene","createNode","group_node_GroupNode","_this3","_node","mesh","createMesh","fromQuaternion","_this4","gltfMesh","_mesh","primitives","gltfPrimitive","createPrimitive","getVertexCount","drawMode","vertexCount","materialParser","gltf_material_parser_GLTFMaterialParser","managedResources","create_gltf_model_toConsumableArray","values","attribute","model","model_node","modules","createGLTFModel","createAttributes","indices","_this5","loadedAttributes","attrName","createAccessor","createBuffer","generated","bufferView","lumaBuffers","classes_buffer","classes_accessor","offset","stride","size","createSampler","gltfSampler","needsPOT","createGLTFObjects","instantiator","gltf_instantiator_GLTFInstantiator","scenes","animator","_callee","uri","loader","gltfObjects","regenerator_default","a","wrap","_context","prev","gltf_loader","parse","decompress","sent","waitForFullLoad","waitForGLTFAssets","abrupt","_callee2","remaining","_context2","uniform","waitWhileCondition","some","loaded","_callee3","condition","_context3","Promise","resolve","window","gltf_scenegraph_loader","extensions","GLTFEnvironment","brdfLutUrl","getTexUrl","_ref$specularMipLevel","specularMipLevels","makeCube","getTextureForFace","pixels","TextureCube","face","texture_cube","mipmaps","_parameters","_DiffuseEnvSampler","dir","loadImage","GL","TEXTURE_WRAP_S","CLAMP_TO_EDGE","TEXTURE_WRAP_T","TEXTURE_MIN_FILTER","LINEAR","TEXTURE_MAG_FILTER","_parameters2","_SpecularEnvSampler","imageArray","lod","LINEAR_MIPMAP_LINEAR","_parameters3","_BrdfTexture","CUBE_FACE_TO_DIRECTION","_CUBE_FACE_TO_DIRECTI","TEXTURE_CUBE_MAP_POSITIVE_X","TEXTURE_CUBE_MAP_NEGATIVE_X","TEXTURE_CUBE_MAP_POSITIVE_Y","TEXTURE_CUBE_MAP_NEGATIVE_Y","TEXTURE_CUBE_MAP_POSITIVE_Z","TEXTURE_CUBE_MAP_NEGATIVE_Z","GLTF_BASE_URL","LIGHT_SOURCES","default","direction","ambient","directional1","directional3","point1far","position","attenuation","point1near","loadGLTF","urlOrPromise","DracoLoader","_ref6","AppAnimationLoop","_AnimationLoop","glOptions","webgl1","webgl2","alpha","_opts","_opts$modelFile","modelFile","_opts$initialZoom","initialZoom","mouse","lastX","lastY","translate","rotationStart","attachTimeline","timeline","play","timelineChannel","addChannel","rate","animationHandle","onInitialize","bind","_assertThisInitialized","onRender","_setDisplay","vr_display","getInfo","initalizeEventHandling","pointerIsDown","pointerDown","x","y","pointerMove","dX","dY","canvas","e","clientX","_deleteScenes","reader","FileReader","ev","result","_fileLoaded","detachAnimation","attachAnimation","setParameters","depthTest","loadOptions","app_DEFAULT_OPTIONS","environment","gltf_environment_GLTFEnvironment","mipLevel","showSelector","document","event","split","parseFloat","lightSelector","iblSelector","_updateLightSettings","_rebuildModel","meshes","bufferViews","lumaStats","applyLight","aspect","viewMatrix","projectionMatrix","clear","depth","_this$rotation","pitch","roll","cameraPos","uView","rotateX","rotateY","uProjection","perspective","fov","radians","near","far","success","u_MVPMatrix","draw","u_ModelMatrix","u_NormalMatrix","invert","transpose","AnimationLoop","website","app_AppAnimationLoop","animationLoop","infoDiv","Example","render","react_default","createElement","animation_loop_example_page","exampleConfig","pageContext","React","Component","GL_VENDOR","GL_RENDERER","GL_VERSION","GL_SHADING_LANGUAGE_VERSION","WEBGL_FEATURES","GLSL_FRAG_DATA","GLSL_FRAG_DEPTH","GLSL_DERIVATIVES","GLSL_TEXTURE_LOD","FEATURES","key","compiledGlslExtensions","canCompileGLGSExtension","cap","feature","navigator","userAgent","isMSIE","isTrident","isOldIE","shader","VERTEX_SHADER","canCompile","COMPILE_STATUS","getFeature","extensionName","Boolean","hasFeatures","features","getPlatformShaderDefines","info","vendor","UNMASKED_VENDOR_WEBGL","renderer","UNMASKED_RENDERER_WEBGL","gpuVendor","identifyGPUVendor","version","shadingLanguageVersion","getContextInfo","debugInfo","toLowerCase","INJECT_SHADER_DECLARATIONS","inject_shader","SHADER_TYPE","_SHADER_TYPE","constants","HOOK_FUNCTIONS","_HOOK_FUNCTIONS","MODULE_INJECTIONS","_MODULE_INJECTIONS","FRAGMENT_SHADER_PROLOGUE","createShaderHook","hook","_hook$split","stage","signature","createModuleInjection","moduleName","injection","_opts$order","order","shaderStage","moduleInjections","assembleShaders","resolveModules","assembleShader","assembleGetUniforms","assembleModuleMap","_hookFunctions","_moduleInjections","_ref$defines","_ref$hookFunctions","hookFunctions","_ref$moduleInjections","_ref$inject","inject","_ref$prologue","prologue","isVertex","sourceLines","glslVersion","versionLine","coreSource","allDefines","module","assembledSource","getShaderName","toUpperCase","getShaderType","isFragment","versionDefines","behavior","getVersionDefines","sourceText","Number","getApplicationDefines","injectStandardStubs","hookInjections","mainInjections","injections","hookName","hookFunction","header","b","_iterator4","_isArray4","_i4","_ref7","footer","getHookFunctions","injectShader","_iterator2","_isArray2","moduleUniforms","_iterator3","_isArray3","_i3","shaderModule","getShaderModule","ShaderModuleRegistry","shaderModules","defaultShaderModules","setDefaultShaderModules","getDefaultShaderModules","registerShaderModules","_ref$ignoreMultipleRe","ignoreMultipleRegistrations","shaderModuleList","_registerShaderModule","moduleOrName","shader_module","Error","shaderModuleRegistry","shader_module_registry_ShaderModuleRegistry","getShaderDependencies","resolve_modules_getShaderModule","moduleMap","moduleDepth","getDependencyGraph","level","keys","sort","uid","constructor","display","math_gl__WEBPACK_IMPORTED_MODULE_4__","math_gl__WEBPACK_IMPORTED_MODULE_5__","userData","_setScenegraphNodeProps","setProps","toString","setPosition","setRotation","setScale","setMatrix","copyMatrix","copy","setMatrixComponents","_ref$update","update","updateMatrix","pos","rot","identity","rotateXYZ","getCoordinateUniforms","worldInverse","worldInverseTranspose","objectMatrix","worldInverseMatrix","worldInverseTransposeMatrix","GLTF_TO_LUMA_ATTRIBUTE_MAP","POSITION","COLOR_0","TEXCOORD_1","TEXCOORD_2","mapAttributeName","_ref$attributeMap","attributeMap","inferAttributeAccessor","attributeName","category","ProgramManager","_programCache","_getUniforms","_registeredModules","_defaultModules","_hashes","_hashCounter","stateHash","_useCounts","getDefaultProgramManager","defaultProgramManager","addDefaultModule","find","m","removeDefaultModule","filter","addModuleInjection","addShaderHook","get","_props","_props$vs","_props$fs","_props$defines","_props$inject","_props$varyings","varyings","_props$bufferMode","bufferMode","_getModuleList","vsHash","_getHash","fsHash","moduleHashes","varyingHashes","v","defineKeys","injectKeys","defineHashes","hash","injectHashes","assembled","classes_program","program","release","undefined","appModules","seen","len","_module","_name","formatValue","_opts$isInteger","isInteger","ArrayBuffer","_opts$maxElts","maxElts","_opts$size","string","formatArrayValue","String","decimal","getDebugTableRow","vertexArray","marker","verts","bytes","format","_buffer$getDebugData","getDebugData","modified","getKey","getGLSLDeclaration","typeAndName","getCompositeGLType","getDebugTableForUniforms","_ref$header","_ref$undefinedOnly","undefinedOnly","uniformLocations","_uniformSetters","table","uniformNames","uniformName","addUniformToTable","_uniformName","_uniformName2","unusedCount","unusedTable","_unusedTable$uniformN","Type","_table$uniformName","isDefined","isUniformDefined","debug_program_configuration_getGLSLDeclaration","attributeInfo","_attributeInfo$access","models","recursiveSet","obj","overrides","Map","seer","payload","itemKey","valuePath","__SEER_INITIALIZED__","setOverride","BaseModel","isWebGL","_props$id","lastLogTime","initialize","shaderCache","programManager","_programManagerState","_managedProgram","_props$program","programProps","_programDirty","needsRedraw","_attributes","animatedUniforms","animated","timerQueryEnabled","timeElapsedQuery","lastQueryReturned","stats","accumulatedFrameTime","averageFrameTime","profileFrameCount","pickable","_checkProgram","_setBaseModelProps","setUniforms","getModuleUniforms","moduleSettings","removeModel","isAnimated","getProgram","setProgram","overs","getOverrides","_extractAnimatedUniforms","updateModuleSettings","drawGeometry","_opts$moduleSettings","framebuffer","_opts$uniforms","_opts$attributes","_opts$transformFeedba","transformFeedback","_opts$parameters","_opts$vertexArray","animationProps","setAttributes","_refreshAnimationProps","logPriority","_logDrawCallStart","drawParams","getDrawParams","isInstanced","isIndexed","indexType","indexOffset","instanceCount","noop","_this$props","_this$props$onBeforeR","onBeforeRender","_this$props$onAfterRe","onAfterRender","_timerQueryStart","didDraw","getDrawMode","_timerQueryEnd","_logDrawCallEnd","Query","_setAnimationProps","_animationProps","_animationLoop","_this$programProps","_this$programProps$vs","MODULAR_SHADERS","_this$programProps$fs","vertex_array","_evaluateAnimateUniforms","valueFunction","foundAnimated","newValue","isObjectEmpty","staticUniforms","query","beginTimeElapsedQuery","end","isResultAvailable","elapsedTime","getTimerMilliseconds","lastFrameTime","logDrawTimeout","priority","Date","now","collapsed","attributeTable","configuration","elements","attributeLocation","rowHeader","location","getDebugTableForVertexArray","_getDebugTableForUnif","uniformTable","_getDebugTableForUnif2","missingTable","configTable","config","attributeInfos","_table","JSON","varyingInfos","_table2","varyingInfo","getDebugTableForProgramConfiguration","isReady","attributesObject","uniformsObject","logModel","message","Model","_BaseModel","TRIANGLES","geometryBuffers","instanced","_setModelProps","geometry","_deleteGeometryBuffers","getInstanceCount","getAttributes","setDrawMode","setVertexCount","setInstanceCount","setGeometry","buffers","remappedName","constant","typedArray","ELEMENT_ARRAY_BUFFER","getBuffersFromGeometry","normalizedAttributes","transform","_Object$assign","_opts$discard","discard","feedbackBuffers","_opts$unbindModels","unbindModels","_setFeedbackBuffers","unbindBuffers","bindBuffers","_feedbackBuffers","transform_feedback","setBuffers","transpileShader","targetGLSLVersion","convertVertexShaderTo300","convertFragmentShaderTo300","convertVertexShaderTo100","convertFragmentShaderTo100","TYPE_DEFINITIONS","number","validate","propType","min","parsePropType","propDef","getTypeOf","ShaderModule","_ref$dependencies","_ref$deprecations","deprecations","vertexShader","fragmentShader","_parseDeprecationDefinitions","propDefs","propTypes","propName","parsePropTypes","getModuleSource","moduleSource","_defaultGetUniforms","getDefines","checkDeprecations","def","shaderSource","deprecated","RegExp","old","private","MODULE_INJECTORS","_MODULE_INJECTORS","DECLARATION_INJECT_MARKER","REGEX_START_OF_MAIN","REGEX_END_OF_MAIN","fragments","_loop","fragmentData","fragmentString","replace","match","combineInjects","injects","__webpack_require__","d","__webpack_exports__","FRAGMENT_SHADER","ModelNode","AfterRender","_lib_model__WEBPACK_IMPORTED_MODULE_0__","_setModelNodeProps","resource","_this$model","_this$model2","_this$model3","_this$model4","TransformFeedback","assertWebGL2Context","_Resource","stubRemovedMethods","isSupported","unused","bindOnUse","_unbindBuffers","bufferName","setBuffer","_getVaryingIndex","locationOrName","_this$_getBufferParam","_getBufferParams","bufferOrParams","byteSize","_bindBuffer","begin","primitiveMode","POINTS","bindTransformFeedback","TRANSFORM_FEEDBACK","handle","_bindBuffers","beginTransformFeedback","endTransformFeedback","_getVaryingInfo","getVaryingInfo","bufferIndex","_this$_getBufferParam2","bindBufferRange","TRANSFORM_FEEDBACK_BUFFER","bindBufferBase","_createHandle","createTransformFeedback","_deleteHandle","deleteTransformFeedback","_bindHandle","Resource","channelHandles","animationHandles","Timeline","lastEngineTime","_proto","_props$delay","delay","_props$duration","duration","POSITIVE_INFINITY","_props$rate","_props$repeat","repeat","channel","_setChannelTime","set","removeChannel","isFinished","getTime","animationData","pause","reset","channelHandle","engineTime","offsetTime"],"mappings":"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","file":"component---templates-core-example-gltf-jsx-f98ee2f8e85c15a11b7c.js","sourcesContent":["import {Matrix4} from 'math.gl';\nimport {log} from '../../utils';\nimport ScenegraphNode from './scenegraph-node';\n\nexport default class GroupNode extends ScenegraphNode {\n  constructor(props = {}) {\n    props = Array.isArray(props) ? {children: props} : props;\n    const {children = []} = props;\n    log.assert(\n      children.every(child => child instanceof ScenegraphNode),\n      'every child must an instance of ScenegraphNode'\n    );\n    super(props);\n    this.children = children;\n  }\n\n  // Unpacks arrays and nested arrays of children\n  add(...children) {\n    for (const child of children) {\n      if (Array.isArray(child)) {\n        this.add(...child);\n      } else {\n        this.children.push(child);\n      }\n    }\n    return this;\n  }\n\n  remove(child) {\n    const children = this.children;\n    const indexOf = children.indexOf(child);\n    if (indexOf > -1) {\n      children.splice(indexOf, 1);\n    }\n    return this;\n  }\n\n  removeAll() {\n    this.children = [];\n    return this;\n  }\n\n  delete() {\n    this.children.forEach(child => child.delete());\n    this.removeAll();\n    super.delete();\n  }\n\n  traverse(visitor, {worldMatrix = new Matrix4()} = {}) {\n    const modelMatrix = new Matrix4(worldMatrix).multiplyRight(this.matrix);\n\n    for (const child of this.children) {\n      if (child instanceof GroupNode) {\n        child.traverse(visitor, {worldMatrix: modelMatrix});\n      } else {\n        visitor(child, {worldMatrix: modelMatrix});\n      }\n    }\n  }\n\n  traverseReverse(visitor, opts) {\n    log.warn('traverseReverse is not reverse')();\n    return this.traverse(visitor, opts);\n  }\n}\n","import {assert, log} from '@luma.gl/core';\nimport {Matrix4, Quaternion} from 'math.gl';\n\n// TODO: import from loaders.gl?\nexport const ATTRIBUTE_TYPE_TO_COMPONENTS = {\n  SCALAR: 1,\n  VEC2: 2,\n  VEC3: 3,\n  VEC4: 4,\n  MAT2: 4,\n  MAT3: 9,\n  MAT4: 16\n};\n\nexport const ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY = {\n  5120: Int8Array,\n  5121: Uint8Array,\n  5122: Int16Array,\n  5123: Uint16Array,\n  5125: Uint32Array,\n  5126: Float32Array\n};\n//\n\nfunction accessorToJsArray(accessor) {\n  if (!accessor._animation) {\n    const ArrayType = ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY[accessor.componentType];\n    const components = ATTRIBUTE_TYPE_TO_COMPONENTS[accessor.type];\n    const length = components * accessor.count;\n    const {buffer, byteOffset} = accessor.bufferView.data;\n\n    const array = new ArrayType(buffer, byteOffset + (accessor.byteOffset || 0), length);\n\n    if (components === 1) {\n      accessor._animation = Array.from(array);\n    } else {\n      // Slice array\n      const slicedArray = [];\n      for (let i = 0; i < array.length; i += components) {\n        slicedArray.push(Array.from(array.slice(i, i + components)));\n      }\n      accessor._animation = slicedArray;\n    }\n  }\n\n  return accessor._animation;\n}\n\n// TODO: share with GLTFInstantiator\nconst helperMatrix = new Matrix4();\nfunction applyTranslationRotationScale(gltfNode, node) {\n  node.matrix.identity();\n\n  if (gltfNode.translation) {\n    node.matrix.translate(gltfNode.translation);\n  }\n\n  if (gltfNode.rotation) {\n    const rotationMatrix = helperMatrix.fromQuaternion(gltfNode.rotation);\n    node.matrix.multiplyRight(rotationMatrix);\n  }\n\n  if (gltfNode.scale) {\n    node.matrix.scale(gltfNode.scale);\n  }\n}\n\nconst quaternion = new Quaternion();\nfunction linearInterpolate(target, path, start, stop, ratio) {\n  if (path === 'rotation') {\n    // SLERP when path is rotation\n    quaternion.slerp({start, target: stop, ratio});\n    for (let i = 0; i < quaternion.length; i++) {\n      target[path][i] = quaternion[i];\n    }\n  } else {\n    // regular interpolation\n    for (let i = 0; i < start.length; i++) {\n      target[path][i] = ratio * stop[i] + (1 - ratio) * start[i];\n    }\n  }\n}\n\nfunction cubicsplineInterpolate(target, path, {p0, outTangent0, inTangent1, p1, tDiff, ratio: t}) {\n  // TODO: Quaternion might need normalization\n  for (let i = 0; i < target[path].length; i++) {\n    const m0 = outTangent0[i] * tDiff;\n    const m1 = inTangent1[i] * tDiff;\n    target[path][i] =\n      (2 * Math.pow(t, 3) - 3 * Math.pow(t, 2) + 1) * p0[i] +\n      (Math.pow(t, 3) - 2 * Math.pow(t, 2) + t) * m0 +\n      (-2 * Math.pow(t, 3) + 3 * Math.pow(t, 2)) * p1[i] +\n      (Math.pow(t, 3) - Math.pow(t, 2)) * m1;\n  }\n}\n\nfunction stepInterpolate(target, path, value) {\n  for (let i = 0; i < value.length; i++) {\n    target[path][i] = value[i];\n  }\n}\n\nfunction interpolate(time, {input, interpolation, output}, target, path) {\n  const maxTime = input[input.length - 1];\n  const animationTime = time % maxTime;\n\n  const nextIndex = input.findIndex(t => t >= animationTime);\n  const previousIndex = Math.max(0, nextIndex - 1);\n\n  if (!Array.isArray(target[path])) {\n    switch (path) {\n      case 'translation':\n        target[path] = [0, 0, 0];\n        break;\n\n      case 'rotation':\n        target[path] = [0, 0, 0, 1];\n        break;\n\n      case 'scale':\n        target[path] = [1, 1, 1];\n        break;\n\n      default:\n        log.warn(`Bad animation path ${path}`)();\n    }\n  }\n\n  assert(target[path].length === output[previousIndex].length);\n  const previousTime = input[previousIndex];\n  const nextTime = input[nextIndex];\n\n  switch (interpolation) {\n    case 'STEP':\n      stepInterpolate(target, path, output[previousIndex]);\n      break;\n\n    case 'LINEAR':\n      if (nextTime > previousTime) {\n        const ratio = (animationTime - previousTime) / (nextTime - previousTime);\n        linearInterpolate(target, path, output[previousIndex], output[nextIndex], ratio);\n      }\n      break;\n\n    case 'CUBICSPLINE':\n      if (nextTime > previousTime) {\n        const ratio = (animationTime - previousTime) / (nextTime - previousTime);\n        const tDiff = nextTime - previousTime;\n\n        const p0 = output[3 * previousIndex + 1];\n        const outTangent0 = output[3 * previousIndex + 2];\n        const inTangent1 = output[3 * nextIndex + 0];\n        const p1 = output[3 * nextIndex + 1];\n\n        cubicsplineInterpolate(target, path, {p0, outTangent0, inTangent1, p1, tDiff, ratio});\n      }\n      break;\n\n    default:\n      log.warn(`Interpolation ${interpolation} not supported`)();\n      break;\n  }\n}\n\nclass GLTFAnimation {\n  constructor(props) {\n    this.startTime = 0;\n    this.playing = true;\n    this.speed = 1;\n\n    Object.assign(this, props);\n  }\n\n  animate(timeMs) {\n    if (!this.playing) {\n      return;\n    }\n\n    const absTime = timeMs / 1000;\n    const time = (absTime - this.startTime) * this.speed;\n\n    this.channels.forEach(({sampler, target, path}) => {\n      interpolate(time, sampler, target, path);\n      applyTranslationRotationScale(target, target._node);\n    });\n  }\n}\n\nexport default class GLTFAnimator {\n  constructor(gltf) {\n    this.animations = gltf.animations.map((animation, index) => {\n      const name = animation.name || `Animation-${index}`;\n      const samplers = animation.samplers.map(({input, interpolation = 'LINEAR', output}) => ({\n        input: accessorToJsArray(gltf.accessors[input]),\n        interpolation,\n        output: accessorToJsArray(gltf.accessors[output])\n      }));\n      const channels = animation.channels.map(({sampler, target}) => ({\n        sampler: samplers[sampler],\n        target: gltf.nodes[target.node],\n        path: target.path\n      }));\n      return new GLTFAnimation({name, channels});\n    });\n  }\n\n  // TODO(Tarek): This should be removed? (deck.gl is using this)\n  animate(time) {\n    this.setTime(time);\n  }\n\n  setTime(time) {\n    this.animations.forEach(animation => animation.animate(time));\n  }\n\n  getAnimations() {\n    return this.animations;\n  }\n}\n","export default `\\\nuniform mat4 u_MVPMatrix;\nuniform mat4 u_ModelMatrix;\nuniform mat4 u_NormalMatrix;\n`;\n","export default `\\\n#if (defined(SHADER_TYPE_FRAGMENT) && defined(LIGHTING_FRAGMENT)) || (defined(SHADER_TYPE_VERTEX) && defined(LIGHTING_VERTEX))\n\nstruct AmbientLight {\n vec3 color;\n};\n\nstruct PointLight {\n vec3 color;\n vec3 position;\n\n // Constant-Linear-Exponential\n vec3 attenuation;\n};\n\nstruct DirectionalLight {\n  vec3 color;\n  vec3 direction;\n};\n\nuniform AmbientLight lighting_uAmbientLight;\nuniform PointLight lighting_uPointLight[MAX_LIGHTS];\nuniform DirectionalLight lighting_uDirectionalLight[MAX_LIGHTS];\nuniform int lighting_uPointLightCount;\nuniform int lighting_uDirectionalLightCount;\n\nuniform bool lighting_uEnabled;\n\nfloat getPointLightAttenuation(PointLight pointLight, float distance) {\n  return pointLight.attenuation.x\n       + pointLight.attenuation.y * distance\n       + pointLight.attenuation.z * distance * distance;\n}\n\n#endif\n`;\n","import lightingShader from './lights.glsl';\n\nexport default {\n  name: 'lights',\n  vs: lightingShader,\n  fs: lightingShader,\n  getUniforms,\n  defines: {\n    MAX_LIGHTS: 3\n  }\n};\n\nconst INITIAL_MODULE_OPTIONS = {};\n\n// Take color 0-255 and intensity as input and output 0.0-1.0 range\nfunction convertColor({color = [0, 0, 0], intensity = 1.0} = {}) {\n  return color.map(component => (component * intensity) / 255.0);\n}\n\nfunction getLightSourceUniforms({ambientLight, pointLights = [], directionalLights = []}) {\n  const lightSourceUniforms = {};\n\n  if (ambientLight) {\n    lightSourceUniforms['lighting_uAmbientLight.color'] = convertColor(ambientLight);\n  } else {\n    lightSourceUniforms['lighting_uAmbientLight.color'] = [0, 0, 0];\n  }\n\n  pointLights.forEach((pointLight, index) => {\n    lightSourceUniforms[`lighting_uPointLight[${index}].color`] = convertColor(pointLight);\n    lightSourceUniforms[`lighting_uPointLight[${index}].position`] = pointLight.position;\n    lightSourceUniforms[`lighting_uPointLight[${index}].attenuation`] = pointLight.attenuation;\n  });\n  lightSourceUniforms.lighting_uPointLightCount = pointLights.length;\n\n  directionalLights.forEach((directionalLight, index) => {\n    lightSourceUniforms[`lighting_uDirectionalLight[${index}].color`] = convertColor(\n      directionalLight\n    );\n    lightSourceUniforms[`lighting_uDirectionalLight[${index}].direction`] =\n      directionalLight.direction;\n  });\n  lightSourceUniforms.lighting_uDirectionalLightCount = directionalLights.length;\n\n  return lightSourceUniforms;\n}\n\n// eslint-disable-next-line complexity\nfunction getUniforms(opts = INITIAL_MODULE_OPTIONS) {\n  // Specify lights separately\n  if ('lightSources' in opts) {\n    const {ambientLight, pointLights, directionalLights} = opts.lightSources || {};\n    const hasLights =\n      ambientLight ||\n      (pointLights && pointLights.length > 0) ||\n      (directionalLights && directionalLights.length > 0);\n\n    if (!hasLights) {\n      return {lighting_uEnabled: false};\n    }\n\n    return Object.assign(\n      {},\n      getLightSourceUniforms({ambientLight, pointLights, directionalLights}),\n      {\n        lighting_uEnabled: true\n      }\n    );\n  }\n\n  // Support for array of lights. Type of light is detected by type field\n  if ('lights' in opts) {\n    const lightSources = {pointLights: [], directionalLights: []};\n    for (const light of opts.lights || []) {\n      switch (light.type) {\n        case 'ambient':\n          // Note: Only uses last ambient light\n          // TODO - add ambient light sources on CPU?\n          lightSources.ambientLight = light;\n          break;\n        case 'directional':\n          lightSources.directionalLights.push(light);\n          break;\n        case 'point':\n          lightSources.pointLights.push(light);\n          break;\n        default:\n        // eslint-disable-next-line\n        // console.warn(light.type);\n      }\n    }\n\n    // Call the `opts.lightSources`` version\n    return getUniforms({lightSources});\n  }\n\n  return {};\n}\n","export default `\\\nvarying vec3 pbr_vPosition;\nvarying vec2 pbr_vUV;\n\n#ifdef HAS_NORMALS\n# ifdef HAS_TANGENTS\nvarying mat3 pbr_vTBN;\n# else\nvarying vec3 pbr_vNormal;\n# endif\n#endif\n\nvoid pbr_setPositionNormalTangentUV(vec4 position, vec4 normal, vec4 tangent, vec2 uv)\n{\n  vec4 pos = u_ModelMatrix * position;\n  pbr_vPosition = vec3(pos.xyz) / pos.w;\n\n#ifdef HAS_NORMALS\n#ifdef HAS_TANGENTS\n  vec3 normalW = normalize(vec3(u_NormalMatrix * vec4(normal.xyz, 0.0)));\n  vec3 tangentW = normalize(vec3(u_ModelMatrix * vec4(tangent.xyz, 0.0)));\n  vec3 bitangentW = cross(normalW, tangentW) * tangent.w;\n  pbr_vTBN = mat3(tangentW, bitangentW, normalW);\n#else // HAS_TANGENTS != 1\n  pbr_vNormal = normalize(vec3(u_ModelMatrix * vec4(normal.xyz, 0.0)));\n#endif\n#endif\n\n#ifdef HAS_UV\n  pbr_vUV = uv;\n#else\n  pbr_vUV = vec2(0.,0.);\n#endif\n}\n`;\n","import project2 from '../project2/project2';\nimport lights from '../lights/lights';\n\nimport vs from './pbr-vertex.glsl';\nimport fs from './pbr-fragment.glsl';\n\nexport default {\n  name: 'pbr',\n  vs,\n  fs,\n  defines: {\n    LIGHTING_FRAGMENT: 1\n  },\n  dependencies: [project2, lights]\n};\n","// This fragment shader defines a reference implementation for Physically Based Shading of\n// a microfacet surface material defined by a glTF model.\n//\n// Attribution:\n// MIT license, Copyright (c) 2016-2017 Mohamad Moneimne and Contributors\n\nexport default `\\\n#if (__VERSION__ < 300)\n#extension GL_EXT_shader_texture_lod: enable\n#extension GL_OES_standard_derivatives : enable\n#endif\n\n// WebGL 1.0 does not support non-constant in for loops\n// This provides an easy way to handle these cases\n// and still take advantage of WebGL 2.0\n#if (__VERSION__ < 300)\n  #define SMART_FOR(INIT, WEBGL1COND, WEBGL2COND, INCR) for (INIT; WEBGL1COND; INCR)\n#else\n  #define SMART_FOR(INIT, WEBGL1COND, WEBGL2COND, INCR) for (INIT; WEBGL2COND; INCR)\n#endif\n\nprecision highp float;\n\n#ifdef USE_IBL\nuniform samplerCube u_DiffuseEnvSampler;\nuniform samplerCube u_SpecularEnvSampler;\nuniform sampler2D u_brdfLUT;\nuniform vec2 u_ScaleIBLAmbient;\n#endif\n\n#ifdef HAS_BASECOLORMAP\nuniform sampler2D u_BaseColorSampler;\n#endif\n#ifdef HAS_NORMALMAP\nuniform sampler2D u_NormalSampler;\nuniform float u_NormalScale;\n#endif\n#ifdef HAS_EMISSIVEMAP\nuniform sampler2D u_EmissiveSampler;\nuniform vec3 u_EmissiveFactor;\n#endif\n#ifdef HAS_METALROUGHNESSMAP\nuniform sampler2D u_MetallicRoughnessSampler;\n#endif\n#ifdef HAS_OCCLUSIONMAP\nuniform sampler2D u_OcclusionSampler;\nuniform float u_OcclusionStrength;\n#endif\n\n#ifdef ALPHA_CUTOFF\nuniform float u_AlphaCutoff;\n#endif\n\nuniform vec2 u_MetallicRoughnessValues;\nuniform vec4 u_BaseColorFactor;\n\nuniform vec3 u_Camera;\n\n// debugging flags used for shader output of intermediate PBR variables\n#ifdef PBR_DEBUG\nuniform vec4 u_ScaleDiffBaseMR;\nuniform vec4 u_ScaleFGDSpec;\n#endif\n\nvarying vec3 pbr_vPosition;\n\nvarying vec2 pbr_vUV;\n\n#ifdef HAS_NORMALS\n#ifdef HAS_TANGENTS\nvarying mat3 pbr_vTBN;\n#else\nvarying vec3 pbr_vNormal;\n#endif\n#endif\n\n// Encapsulate the various inputs used by the various functions in the shading equation\n// We store values in this struct to simplify the integration of alternative implementations\n// of the shading terms, outlined in the Readme.MD Appendix.\nstruct PBRInfo\n{\n  float NdotL;                  // cos angle between normal and light direction\n  float NdotV;                  // cos angle between normal and view direction\n  float NdotH;                  // cos angle between normal and half vector\n  float LdotH;                  // cos angle between light direction and half vector\n  float VdotH;                  // cos angle between view direction and half vector\n  float perceptualRoughness;    // roughness value, as authored by the model creator (input to shader)\n  float metalness;              // metallic value at the surface\n  vec3 reflectance0;            // full reflectance color (normal incidence angle)\n  vec3 reflectance90;           // reflectance color at grazing angle\n  float alphaRoughness;         // roughness mapped to a more linear change in the roughness (proposed by [2])\n  vec3 diffuseColor;            // color contribution from diffuse lighting\n  vec3 specularColor;           // color contribution from specular lighting\n  vec3 n;                       // normal at surface point\n  vec3 v;                       // vector from surface point to camera\n};\n\nconst float M_PI = 3.141592653589793;\nconst float c_MinRoughness = 0.04;\n\nvec4 SRGBtoLINEAR(vec4 srgbIn)\n{\n#ifdef MANUAL_SRGB\n#ifdef SRGB_FAST_APPROXIMATION\n  vec3 linOut = pow(srgbIn.xyz,vec3(2.2));\n#else //SRGB_FAST_APPROXIMATION\n  vec3 bLess = step(vec3(0.04045),srgbIn.xyz);\n  vec3 linOut = mix( srgbIn.xyz/vec3(12.92), pow((srgbIn.xyz+vec3(0.055))/vec3(1.055),vec3(2.4)), bLess );\n#endif //SRGB_FAST_APPROXIMATION\n  return vec4(linOut,srgbIn.w);;\n#else //MANUAL_SRGB\n  return srgbIn;\n#endif //MANUAL_SRGB\n}\n\n// Find the normal for this fragment, pulling either from a predefined normal map\n// or from the interpolated mesh normal and tangent attributes.\nvec3 getNormal()\n{\n  // Retrieve the tangent space matrix\n#ifndef HAS_TANGENTS\n  vec3 pos_dx = dFdx(pbr_vPosition);\n  vec3 pos_dy = dFdy(pbr_vPosition);\n  vec3 tex_dx = dFdx(vec3(pbr_vUV, 0.0));\n  vec3 tex_dy = dFdy(vec3(pbr_vUV, 0.0));\n  vec3 t = (tex_dy.t * pos_dx - tex_dx.t * pos_dy) / (tex_dx.s * tex_dy.t - tex_dy.s * tex_dx.t);\n\n#ifdef HAS_NORMALS\n  vec3 ng = normalize(pbr_vNormal);\n#else\n  vec3 ng = cross(pos_dx, pos_dy);\n#endif\n\n  t = normalize(t - ng * dot(ng, t));\n  vec3 b = normalize(cross(ng, t));\n  mat3 tbn = mat3(t, b, ng);\n#else // HAS_TANGENTS\n  mat3 tbn = pbr_vTBN;\n#endif\n\n#ifdef HAS_NORMALMAP\n  vec3 n = texture2D(u_NormalSampler, pbr_vUV).rgb;\n  n = normalize(tbn * ((2.0 * n - 1.0) * vec3(u_NormalScale, u_NormalScale, 1.0)));\n#else\n  // The tbn matrix is linearly interpolated, so we need to re-normalize\n  vec3 n = normalize(tbn[2].xyz);\n#endif\n\n  return n;\n}\n\n// Calculation of the lighting contribution from an optional Image Based Light source.\n// Precomputed Environment Maps are required uniform inputs and are computed as outlined in [1].\n// See our README.md on Environment Maps [3] for additional discussion.\n#ifdef USE_IBL\nvec3 getIBLContribution(PBRInfo pbrInputs, vec3 n, vec3 reflection)\n{\n  float mipCount = 9.0; // resolution of 512x512\n  float lod = (pbrInputs.perceptualRoughness * mipCount);\n  // retrieve a scale and bias to F0. See [1], Figure 3\n  vec3 brdf = SRGBtoLINEAR(texture2D(u_brdfLUT,\n    vec2(pbrInputs.NdotV, 1.0 - pbrInputs.perceptualRoughness))).rgb;\n  vec3 diffuseLight = SRGBtoLINEAR(textureCube(u_DiffuseEnvSampler, n)).rgb;\n\n#ifdef USE_TEX_LOD\n  vec3 specularLight = SRGBtoLINEAR(textureCubeLodEXT(u_SpecularEnvSampler, reflection, lod)).rgb;\n#else\n  vec3 specularLight = SRGBtoLINEAR(textureCube(u_SpecularEnvSampler, reflection)).rgb;\n#endif\n\n  vec3 diffuse = diffuseLight * pbrInputs.diffuseColor;\n  vec3 specular = specularLight * (pbrInputs.specularColor * brdf.x + brdf.y);\n\n  // For presentation, this allows us to disable IBL terms\n  diffuse *= u_ScaleIBLAmbient.x;\n  specular *= u_ScaleIBLAmbient.y;\n\n  return diffuse + specular;\n}\n#endif\n\n// Basic Lambertian diffuse\n// Implementation from Lambert's Photometria https://archive.org/details/lambertsphotome00lambgoog\n// See also [1], Equation 1\nvec3 diffuse(PBRInfo pbrInputs)\n{\n  return pbrInputs.diffuseColor / M_PI;\n}\n\n// The following equation models the Fresnel reflectance term of the spec equation (aka F())\n// Implementation of fresnel from [4], Equation 15\nvec3 specularReflection(PBRInfo pbrInputs)\n{\n  return pbrInputs.reflectance0 +\n    (pbrInputs.reflectance90 - pbrInputs.reflectance0) *\n    pow(clamp(1.0 - pbrInputs.VdotH, 0.0, 1.0), 5.0);\n}\n\n// This calculates the specular geometric attenuation (aka G()),\n// where rougher material will reflect less light back to the viewer.\n// This implementation is based on [1] Equation 4, and we adopt their modifications to\n// alphaRoughness as input as originally proposed in [2].\nfloat geometricOcclusion(PBRInfo pbrInputs)\n{\n  float NdotL = pbrInputs.NdotL;\n  float NdotV = pbrInputs.NdotV;\n  float r = pbrInputs.alphaRoughness;\n\n  float attenuationL = 2.0 * NdotL / (NdotL + sqrt(r * r + (1.0 - r * r) * (NdotL * NdotL)));\n  float attenuationV = 2.0 * NdotV / (NdotV + sqrt(r * r + (1.0 - r * r) * (NdotV * NdotV)));\n  return attenuationL * attenuationV;\n}\n\n// The following equation(s) model the distribution of microfacet normals across\n// the area being drawn (aka D())\n// Implementation from \"Average Irregularity Representation of a Roughened Surface\n// for Ray Reflection\" by T. S. Trowbridge, and K. P. Reitz\n// Follows the distribution function recommended in the SIGGRAPH 2013 course notes\n// from EPIC Games [1], Equation 3.\nfloat microfacetDistribution(PBRInfo pbrInputs)\n{\n  float roughnessSq = pbrInputs.alphaRoughness * pbrInputs.alphaRoughness;\n  float f = (pbrInputs.NdotH * roughnessSq - pbrInputs.NdotH) * pbrInputs.NdotH + 1.0;\n  return roughnessSq / (M_PI * f * f);\n}\n\nvoid PBRInfo_setAmbientLight(inout PBRInfo pbrInputs) {\n  pbrInputs.NdotL = 1.0;\n  pbrInputs.NdotH = 0.0;\n  pbrInputs.LdotH = 0.0;\n  pbrInputs.VdotH = 1.0;\n}\n\nvoid PBRInfo_setDirectionalLight(inout PBRInfo pbrInputs, vec3 lightDirection) {\n  vec3 n = pbrInputs.n;\n  vec3 v = pbrInputs.v;\n  vec3 l = normalize(lightDirection);             // Vector from surface point to light\n  vec3 h = normalize(l+v);                        // Half vector between both l and v\n\n  pbrInputs.NdotL = clamp(dot(n, l), 0.001, 1.0);\n  pbrInputs.NdotH = clamp(dot(n, h), 0.0, 1.0);\n  pbrInputs.LdotH = clamp(dot(l, h), 0.0, 1.0);\n  pbrInputs.VdotH = clamp(dot(v, h), 0.0, 1.0);\n}\n\nvoid PBRInfo_setPointLight(inout PBRInfo pbrInputs, PointLight pointLight) {\n  vec3 light_direction = normalize(pointLight.position - pbr_vPosition);\n  PBRInfo_setDirectionalLight(pbrInputs, light_direction);\n}\n\nvec3 calculateFinalColor(PBRInfo pbrInputs, vec3 lightColor) {\n  // Calculate the shading terms for the microfacet specular shading model\n  vec3 F = specularReflection(pbrInputs);\n  float G = geometricOcclusion(pbrInputs);\n  float D = microfacetDistribution(pbrInputs);\n\n  // Calculation of analytical lighting contribution\n  vec3 diffuseContrib = (1.0 - F) * diffuse(pbrInputs);\n  vec3 specContrib = F * G * D / (4.0 * pbrInputs.NdotL * pbrInputs.NdotV);\n  // Obtain final intensity as reflectance (BRDF) scaled by the energy of the light (cosine law)\n  return pbrInputs.NdotL * lightColor * (diffuseContrib + specContrib);\n}\n\nvec4 pbr_filterColor(vec4 colorUnused)\n{\n  // Metallic and Roughness material properties are packed together\n  // In glTF, these factors can be specified by fixed scalar values\n  // or from a metallic-roughness map\n  float perceptualRoughness = u_MetallicRoughnessValues.y;\n  float metallic = u_MetallicRoughnessValues.x;\n#ifdef HAS_METALROUGHNESSMAP\n  // Roughness is stored in the 'g' channel, metallic is stored in the 'b' channel.\n  // This layout intentionally reserves the 'r' channel for (optional) occlusion map data\n  vec4 mrSample = texture2D(u_MetallicRoughnessSampler, pbr_vUV);\n  perceptualRoughness = mrSample.g * perceptualRoughness;\n  metallic = mrSample.b * metallic;\n#endif\n  perceptualRoughness = clamp(perceptualRoughness, c_MinRoughness, 1.0);\n  metallic = clamp(metallic, 0.0, 1.0);\n  // Roughness is authored as perceptual roughness; as is convention,\n  // convert to material roughness by squaring the perceptual roughness [2].\n  float alphaRoughness = perceptualRoughness * perceptualRoughness;\n\n  // The albedo may be defined from a base texture or a flat color\n#ifdef HAS_BASECOLORMAP\n  vec4 baseColor = SRGBtoLINEAR(texture2D(u_BaseColorSampler, pbr_vUV)) * u_BaseColorFactor;\n#else\n  vec4 baseColor = u_BaseColorFactor;\n#endif\n\n#ifdef ALPHA_CUTOFF\n  if (baseColor.a < u_AlphaCutoff) {\n    discard;\n  }\n#endif\n\n  vec3 f0 = vec3(0.04);\n  vec3 diffuseColor = baseColor.rgb * (vec3(1.0) - f0);\n  diffuseColor *= 1.0 - metallic;\n  vec3 specularColor = mix(f0, baseColor.rgb, metallic);\n\n  // Compute reflectance.\n  float reflectance = max(max(specularColor.r, specularColor.g), specularColor.b);\n\n  // For typical incident reflectance range (between 4% to 100%) set the grazing\n  // reflectance to 100% for typical fresnel effect.\n  // For very low reflectance range on highly diffuse objects (below 4%),\n  // incrementally reduce grazing reflecance to 0%.\n  float reflectance90 = clamp(reflectance * 25.0, 0.0, 1.0);\n  vec3 specularEnvironmentR0 = specularColor.rgb;\n  vec3 specularEnvironmentR90 = vec3(1.0, 1.0, 1.0) * reflectance90;\n\n  vec3 n = getNormal();                          // normal at surface point\n  vec3 v = normalize(u_Camera - pbr_vPosition);  // Vector from surface point to camera\n\n  float NdotV = clamp(abs(dot(n, v)), 0.001, 1.0);\n  vec3 reflection = -normalize(reflect(v, n));\n\n  PBRInfo pbrInputs = PBRInfo(\n    0.0, // NdotL\n    NdotV,\n    0.0, // NdotH\n    0.0, // LdotH\n    0.0, // VdotH\n    perceptualRoughness,\n    metallic,\n    specularEnvironmentR0,\n    specularEnvironmentR90,\n    alphaRoughness,\n    diffuseColor,\n    specularColor,\n    n,\n    v\n  );\n\n  vec3 color = vec3(0, 0, 0);\n\n#ifdef USE_LIGHTS\n  // Apply ambient light\n  PBRInfo_setAmbientLight(pbrInputs);\n  color += calculateFinalColor(pbrInputs, lighting_uAmbientLight.color);\n\n  // Apply directional light\n  SMART_FOR(int i = 0, i < MAX_LIGHTS, i < lighting_uDirectionalLightCount, i++) {\n    if (i < lighting_uDirectionalLightCount) {\n      PBRInfo_setDirectionalLight(pbrInputs, lighting_uDirectionalLight[i].direction);\n      color += calculateFinalColor(pbrInputs, lighting_uDirectionalLight[i].color);\n    }\n  }\n\n  // Apply point light\n  SMART_FOR(int i = 0, i < MAX_LIGHTS, i < lighting_uPointLightCount, i++) {\n    if (i < lighting_uPointLightCount) {\n      PBRInfo_setPointLight(pbrInputs, lighting_uPointLight[i]);\n      float attenuation = getPointLightAttenuation(lighting_uPointLight[i], distance(lighting_uPointLight[i].position, pbr_vPosition));\n      color += calculateFinalColor(pbrInputs, lighting_uPointLight[i].color / attenuation);\n    }\n  }\n#endif\n\n  // Calculate lighting contribution from image based lighting source (IBL)\n#ifdef USE_IBL\n  color += getIBLContribution(pbrInputs, n, reflection);\n#endif\n\n  // Apply optional PBR terms for additional (optional) shading\n#ifdef HAS_OCCLUSIONMAP\n  float ao = texture2D(u_OcclusionSampler, pbr_vUV).r;\n  color = mix(color, color * ao, u_OcclusionStrength);\n#endif\n\n#ifdef HAS_EMISSIVEMAP\n  vec3 emissive = SRGBtoLINEAR(texture2D(u_EmissiveSampler, pbr_vUV)).rgb * u_EmissiveFactor;\n  color += emissive;\n#endif\n\n  // This section uses mix to override final color for reference app visualization\n  // of various parameters in the lighting equation.\n#ifdef PBR_DEBUG\n  // TODO: Figure out how to debug multiple lights\n\n  // color = mix(color, F, u_ScaleFGDSpec.x);\n  // color = mix(color, vec3(G), u_ScaleFGDSpec.y);\n  // color = mix(color, vec3(D), u_ScaleFGDSpec.z);\n  // color = mix(color, specContrib, u_ScaleFGDSpec.w);\n\n  // color = mix(color, diffuseContrib, u_ScaleDiffBaseMR.x);\n  color = mix(color, baseColor.rgb, u_ScaleDiffBaseMR.y);\n  color = mix(color, vec3(metallic), u_ScaleDiffBaseMR.z);\n  color = mix(color, vec3(perceptualRoughness), u_ScaleDiffBaseMR.w);\n#endif\n\n  return vec4(pow(color,vec3(1.0/2.2)), baseColor.a);\n}\n`;\n","import vs from './project2.vertex.glsl';\n\nexport default {\n  name: 'project2',\n  vs,\n  fs: vs\n};\n","import {Texture2D, log} from '@luma.gl/core';\n\nexport default class GLTFMaterialParser {\n  constructor(\n    gl,\n    {attributes, material, pbrDebug, imageBasedLightingEnvironment, lights, useTangents}\n  ) {\n    this.gl = gl;\n\n    this.defines = {\n      USE_TEX_LOD: 1,\n\n      // TODO: Use EXT_sRGB if available (Standard in WebGL 2.0)\n      MANUAL_SRGB: 1,\n      SRGB_FAST_APPROXIMATION: 1\n    };\n\n    this.uniforms = {\n      // TODO: find better values?\n      u_Camera: [0, 0, 0], // Model should override\n\n      u_MetallicRoughnessValues: [1, 1] // Default is 1 and 1\n    };\n\n    this.parameters = {};\n    this.generatedTextures = [];\n\n    if (imageBasedLightingEnvironment) {\n      this.uniforms.u_DiffuseEnvSampler = imageBasedLightingEnvironment.getDiffuseEnvSampler();\n      this.uniforms.u_SpecularEnvSampler = imageBasedLightingEnvironment.getSpecularEnvSampler();\n      this.uniforms.u_brdfLUT = imageBasedLightingEnvironment.getBrdfTexture();\n      this.uniforms.u_ScaleIBLAmbient = [1, 1];\n    }\n\n    if (pbrDebug) {\n      // Override final color for reference app visualization\n      // of various parameters in the lighting equation.\n      this.uniforms.u_ScaleDiffBaseMR = [0, 0, 0, 0];\n      this.uniforms.u_ScaleFGDSpec = [0, 0, 0, 0];\n    }\n\n    this.defineIfPresent(attributes.NORMAL, 'HAS_NORMALS');\n    this.defineIfPresent(attributes.TANGENT && useTangents, 'HAS_TANGENTS');\n    this.defineIfPresent(attributes.TEXCOORD_0, 'HAS_UV');\n\n    this.defineIfPresent(imageBasedLightingEnvironment, 'USE_IBL');\n    this.defineIfPresent(lights, 'USE_LIGHTS');\n    this.defineIfPresent(pbrDebug, 'PBR_DEBUG');\n\n    if (material) {\n      this.parseMaterial(material);\n    }\n  }\n\n  defineIfPresent(value, name) {\n    if (value) {\n      this.defines[name] = 1;\n    }\n  }\n\n  parseTexture(gltfTexture, name, define = null) {\n    const parameters =\n      (gltfTexture.texture &&\n        gltfTexture.texture.sampler &&\n        gltfTexture.texture.sampler.parameters) ||\n      {};\n\n    const texture = new Texture2D(this.gl, {\n      id: gltfTexture.name || gltfTexture.id,\n      parameters,\n      pixelStore: {\n        [this.gl.UNPACK_FLIP_Y_WEBGL]: false\n      },\n      // Texture2D accepts a promise that returns an image as data (Async Textures)\n      data: gltfTexture.texture.source.getImageAsync()\n    });\n    this.uniforms[name] = texture;\n    this.defineIfPresent(define, define);\n    this.generatedTextures.push(texture);\n  }\n\n  parsePbrMetallicRoughness(pbrMetallicRoughness) {\n    if (pbrMetallicRoughness.baseColorTexture) {\n      this.parseTexture(\n        pbrMetallicRoughness.baseColorTexture,\n        'u_BaseColorSampler',\n        'HAS_BASECOLORMAP'\n      );\n    }\n    this.uniforms.u_BaseColorFactor = pbrMetallicRoughness.baseColorFactor || [1, 1, 1, 1];\n\n    if (pbrMetallicRoughness.metallicRoughnessTexture) {\n      this.parseTexture(\n        pbrMetallicRoughness.metallicRoughnessTexture,\n        'u_MetallicRoughnessSampler',\n        'HAS_METALROUGHNESSMAP'\n      );\n    }\n    const {metallicFactor = 1, roughnessFactor = 1} = pbrMetallicRoughness;\n    this.uniforms.u_MetallicRoughnessValues = [metallicFactor, roughnessFactor];\n  }\n\n  parseMaterial(material) {\n    if (material.pbrMetallicRoughness) {\n      this.parsePbrMetallicRoughness(material.pbrMetallicRoughness);\n    }\n    if (material.normalTexture) {\n      this.parseTexture(material.normalTexture, 'u_NormalSampler', 'HAS_NORMALMAP');\n\n      const {scale = 1} = material.normalTexture;\n      this.uniforms.u_NormalScale = scale;\n    }\n    if (material.occlusionTexture) {\n      this.parseTexture(material.occlusionTexture, 'u_OcclusionSampler', 'HAS_OCCLUSIONMAP');\n\n      const {strength = 1} = material.occlusionTexture;\n      this.uniforms.u_OcclusionStrength = strength;\n    }\n    if (material.emissiveTexture) {\n      this.parseTexture(material.emissiveTexture, 'u_EmissiveSampler', 'HAS_EMISSIVEMAP');\n      this.uniforms.u_EmissiveFactor = material.emissiveFactor || [0, 0, 0];\n    }\n    if (material.alphaMode === 'MASK') {\n      const {alphaCutoff = 0.5} = material;\n      this.defines.ALPHA_CUTOFF = 1;\n      this.uniforms.u_AlphaCutoff = alphaCutoff;\n    } else if (material.alphaMode === 'BLEND') {\n      log.warn('BLEND alphaMode might not work well because it requires mesh sorting')();\n      Object.assign(this.parameters, {\n        blend: true,\n        blendEquation: this.gl.FUNC_ADD,\n        blendFunc: [\n          this.gl.SRC_ALPHA,\n          this.gl.ONE_MINUS_SRC_ALPHA,\n          this.gl.ONE,\n          this.gl.ONE_MINUS_SRC_ALPHA\n        ]\n      });\n    }\n  }\n}\n","import {isWebGL2, ModelNode, log, pbr} from '@luma.gl/core';\nimport GLTFMaterialParser from './gltf-material-parser';\n\nconst vs = `\n#if (__VERSION__ < 300)\n  #define _attr attribute\n#else\n  #define _attr in\n#endif\n\n  _attr vec4 POSITION;\n\n  #ifdef HAS_NORMALS\n    _attr vec4 NORMAL;\n  #endif\n\n  #ifdef HAS_TANGENTS\n    _attr vec4 TANGENT;\n  #endif\n\n  #ifdef HAS_UV\n    _attr vec2 TEXCOORD_0;\n  #endif\n\n  void main(void) {\n    vec4 _NORMAL = vec4(0.);\n    vec4 _TANGENT = vec4(0.);\n    vec2 _TEXCOORD_0 = vec2(0.);\n\n    #ifdef HAS_NORMALS\n      _NORMAL = NORMAL;\n    #endif\n\n    #ifdef HAS_TANGENTS\n      _TANGENT = TANGENT;\n    #endif\n\n    #ifdef HAS_UV\n      _TEXCOORD_0 = TEXCOORD_0;\n    #endif\n\n    pbr_setPositionNormalTangentUV(POSITION, _NORMAL, _TANGENT, _TEXCOORD_0);\n    gl_Position = u_MVPMatrix * POSITION;\n  }\n`;\n\nconst fs = `\n#if (__VERSION__ < 300)\n  #define fragmentColor gl_FragColor\n#else\n  out vec4 fragmentColor;\n#endif\n\n  void main(void) {\n    fragmentColor = pbr_filterColor(vec4(0));\n  }\n`;\n\nfunction addVersionToShader(gl, source) {\n  if (isWebGL2(gl)) {\n    return `#version 300 es\\n${source}`;\n  }\n\n  return source;\n}\n\nexport default function createGLTFModel(gl, options) {\n  const {id, drawMode, vertexCount, attributes, modelOptions} = options;\n  const materialParser = new GLTFMaterialParser(gl, options);\n\n  log.info(4, 'createGLTFModel defines: ', materialParser.defines)();\n\n  // Calculate managedResources\n  // TODO: Implement resource management logic that will\n  // not deallocate resources/textures/buffers that are shared\n  const managedResources = [];\n  managedResources.push(...materialParser.generatedTextures);\n  managedResources.push(...Object.values(attributes).map(attribute => attribute.buffer));\n\n  const model = new ModelNode(\n    gl,\n    Object.assign(\n      {\n        id,\n        drawMode,\n        vertexCount,\n        modules: [pbr],\n        defines: materialParser.defines,\n        parameters: materialParser.parameters,\n        vs: addVersionToShader(gl, vs),\n        fs: addVersionToShader(gl, fs),\n        managedResources\n      },\n      modelOptions\n    )\n  );\n\n  model.setProps({attributes});\n  model.setUniforms(materialParser.uniforms);\n\n  return model;\n}\n","import {Matrix4} from 'math.gl';\nimport {Buffer, _Accessor as Accessor, GroupNode, log} from '@luma.gl/core';\n\nimport GLTFAnimator from './gltf-animator';\nimport createGLTFModel from './create-gltf-model';\n\n// TODO: import {ATTRIBUTE_TYPE_TO_COMPONENTS} from '@loaders.gl/gltf';\nconst ATTRIBUTE_TYPE_TO_COMPONENTS = {\n  SCALAR: 1,\n  VEC2: 2,\n  VEC3: 3,\n  VEC4: 4,\n  MAT2: 4,\n  MAT3: 9,\n  MAT4: 16\n};\n\nconst DEFAULT_OPTIONS = {\n  modelOptions: {},\n  pbrDebug: false,\n  imageBasedLightingEnvironment: null,\n  lights: true,\n  useTangents: false\n};\n\n// GLTF instantiator for luma.gl\n// Walks the parsed and resolved glTF structure and builds a luma.gl scenegraph\nexport default class GLTFInstantiator {\n  constructor(gl, options = {}) {\n    this.gl = gl;\n    this.options = Object.assign({}, DEFAULT_OPTIONS, options);\n  }\n\n  instantiate(gltf) {\n    this.gltf = gltf;\n    const scenes = (gltf.scenes || []).map(scene => this.createScene(scene));\n    return scenes;\n  }\n\n  createAnimator() {\n    if (Array.isArray(this.gltf.animations)) {\n      return new GLTFAnimator(this.gltf);\n    }\n\n    return null;\n  }\n\n  createScene(gltfScene) {\n    const gltfNodes = gltfScene.nodes || [];\n    const nodes = gltfNodes.map(node => this.createNode(node));\n    const scene = new GroupNode({\n      id: gltfScene.name || gltfScene.id,\n      children: nodes\n    });\n    return scene;\n  }\n\n  createNode(gltfNode) {\n    if (!gltfNode._node) {\n      const gltfChildren = gltfNode.children || [];\n      const children = gltfChildren.map(child => this.createNode(child));\n\n      // Node can have children nodes and meshes at the same time\n      if (gltfNode.mesh) {\n        children.push(this.createMesh(gltfNode.mesh));\n      }\n\n      const node = new GroupNode({\n        id: gltfNode.name || gltfNode.id,\n        children\n      });\n\n      if (gltfNode.matrix) {\n        node.setMatrix(gltfNode.matrix);\n      } else {\n        node.matrix.identity();\n\n        if (gltfNode.translation) {\n          node.matrix.translate(gltfNode.translation);\n        }\n\n        if (gltfNode.rotation) {\n          const rotationMatrix = new Matrix4().fromQuaternion(gltfNode.rotation);\n          node.matrix.multiplyRight(rotationMatrix);\n        }\n\n        if (gltfNode.scale) {\n          node.matrix.scale(gltfNode.scale);\n        }\n      }\n      gltfNode._node = node;\n    }\n\n    return gltfNode._node;\n  }\n\n  createMesh(gltfMesh) {\n    // TODO: avoid changing the gltf\n    if (!gltfMesh._mesh) {\n      const gltfPrimitives = gltfMesh.primitives || [];\n      const primitives = gltfPrimitives.map((gltfPrimitive, i) =>\n        this.createPrimitive(gltfPrimitive, i, gltfMesh)\n      );\n      const mesh = new GroupNode({\n        id: gltfMesh.name || gltfMesh.id,\n        children: primitives\n      });\n      gltfMesh._mesh = mesh;\n    }\n\n    return gltfMesh._mesh;\n  }\n\n  getVertexCount(attributes) {\n    // TODO: implement this\n    log.warn('getVertexCount() not found')();\n  }\n\n  createPrimitive(gltfPrimitive, i, gltfMesh) {\n    return createGLTFModel(\n      this.gl,\n      Object.assign(\n        {\n          id: gltfPrimitive.name || `${gltfMesh.name || gltfMesh.id}-primitive-${i}`,\n          drawMode: gltfPrimitive.mode || 4,\n          vertexCount: gltfPrimitive.indices\n            ? gltfPrimitive.indices.count\n            : this.getVertexCount(gltfPrimitive.attributes),\n          attributes: this.createAttributes(gltfPrimitive.attributes, gltfPrimitive.indices),\n          material: gltfPrimitive.material\n        },\n        this.options\n      )\n    );\n  }\n\n  createAttributes(attributes, indices) {\n    const loadedAttributes = {};\n\n    Object.keys(attributes).forEach(attrName => {\n      loadedAttributes[attrName] = this.createAccessor(\n        attributes[attrName],\n        this.createBuffer(attributes[attrName], this.gl.ARRAY_BUFFER)\n      );\n    });\n\n    if (indices) {\n      loadedAttributes.indices = this.createAccessor(\n        indices,\n        this.createBuffer(indices, this.gl.ELEMENT_ARRAY_BUFFER)\n      );\n    }\n\n    log.info(4, 'glTF Attributes', {attributes, indices, generated: loadedAttributes})();\n\n    return loadedAttributes;\n  }\n\n  createBuffer(attribute, target) {\n    if (!attribute.bufferView) {\n      // Draco decoded files do not have a bufferView\n      attribute.bufferView = {};\n    }\n\n    const {bufferView} = attribute;\n    if (!bufferView.lumaBuffers) {\n      bufferView.lumaBuffers = {};\n    }\n\n    if (!bufferView.lumaBuffers[target]) {\n      bufferView.lumaBuffers[target] = new Buffer(this.gl, {\n        id: `from-${bufferView.id}`,\n        // Draco decoded files have attribute.value\n        data: bufferView.data || attribute.value,\n        target\n      });\n    }\n\n    return bufferView.lumaBuffers[target];\n  }\n\n  createAccessor(accessor, buffer) {\n    return new Accessor({\n      buffer,\n      offset: accessor.byteOffset || 0,\n      stride: accessor.bufferView.byteStride || 0,\n      type: accessor.componentType,\n      size: ATTRIBUTE_TYPE_TO_COMPONENTS[accessor.type]\n    });\n  }\n\n  // TODO - create sampler in WebGL2\n  createSampler(gltfSampler) {\n    return gltfSampler;\n  }\n\n  // Helper methods (move to GLTFLoader.resolve...?)\n\n  needsPOT() {\n    // Has a wrapping mode (either wrapS or wrapT) equal to REPEAT or MIRRORED_REPEAT, or\n    // Has a minification filter (minFilter) that uses mipmapping\n    // (NEAREST_MIPMAP_NEAREST, NEAREST_MIPMAP_LINEAR,\n    // LINEAR_MIPMAP_NEAREST, or LINEAR_MIPMAP_LINEAR).\n    return false;\n  }\n}\n","import GLTFInstantiator from './gltf-instantiator';\n\nexport default function createGLTFObjects(gl, gltf, options) {\n  const instantiator = new GLTFInstantiator(gl, options);\n  const scenes = instantiator.instantiate(gltf);\n  const animator = instantiator.createAnimator();\n\n  return {scenes, animator};\n}\n","/* global window */\nimport {assert} from '@luma.gl/core';\nimport {GLTFLoader} from '@loaders.gl/gltf';\nimport createGLTFObjects from './create-gltf-objects';\n\nasync function parse(data, options, uri, loader) {\n  assert(options.gl);\n\n  const gltf = await GLTFLoader.parse(data, {\n    ...options,\n    uri,\n    decompress: true\n  });\n\n  const gltfObjects = createGLTFObjects(options.gl, gltf, options);\n\n  if (options.waitForFullLoad) {\n    await waitForGLTFAssets(gltfObjects);\n  }\n\n  return Object.assign({gltf}, gltfObjects);\n}\n\nasync function waitForGLTFAssets(gltfObjects) {\n  const remaining = [];\n\n  gltfObjects.scenes.forEach(scene => {\n    scene.traverse(model => {\n      Object.values(model.model.program.uniforms).forEach(uniform => {\n        if (uniform.loaded === false) {\n          remaining.push(uniform);\n        }\n      });\n    });\n  });\n\n  return await waitWhileCondition(() => remaining.some(uniform => !uniform.loaded));\n}\n\nasync function waitWhileCondition(condition) {\n  while (condition()) {\n    await new Promise(resolve => window.requestAnimationFrame(resolve));\n  }\n}\n\nexport default {\n  name: 'GLTF Scenegraph Loader',\n  extensions: ['gltf', 'glb'],\n  parse\n};\n","import GL from '@luma.gl/constants';\nimport {Texture2D, TextureCube} from '@luma.gl/core';\nimport {loadImage} from '@loaders.gl/images';\n\nexport default class GLTFEnvironment {\n  constructor(gl, {brdfLutUrl, getTexUrl, specularMipLevels = 10}) {\n    this.gl = gl;\n    this.brdfLutUrl = brdfLutUrl;\n    this.getTexUrl = getTexUrl;\n    this.specularMipLevels = specularMipLevels;\n  }\n\n  makeCube({id, getTextureForFace, parameters}) {\n    const pixels = {};\n    TextureCube.FACES.forEach(face => {\n      pixels[face] = getTextureForFace(face);\n    });\n    return new TextureCube(this.gl, {\n      id,\n      mipmaps: false,\n      parameters,\n      pixels\n    });\n  }\n\n  getDiffuseEnvSampler() {\n    if (!this._DiffuseEnvSampler) {\n      this._DiffuseEnvSampler = this.makeCube({\n        id: 'DiffuseEnvSampler',\n        getTextureForFace: dir => loadImage(this.getTexUrl('diffuse', dir, 0)),\n        parameters: {\n          [GL.TEXTURE_WRAP_S]: GL.CLAMP_TO_EDGE,\n          [GL.TEXTURE_WRAP_T]: GL.CLAMP_TO_EDGE,\n          [GL.TEXTURE_MIN_FILTER]: GL.LINEAR,\n          [GL.TEXTURE_MAG_FILTER]: GL.LINEAR\n        }\n      });\n    }\n\n    return this._DiffuseEnvSampler;\n  }\n\n  getSpecularEnvSampler() {\n    if (!this._SpecularEnvSampler) {\n      this._SpecularEnvSampler = this.makeCube({\n        id: 'SpecularEnvSampler',\n        getTextureForFace: dir => {\n          const imageArray = [];\n          for (let lod = 0; lod <= this.specularMipLevels - 1; lod++) {\n            imageArray.push(loadImage(this.getTexUrl('specular', dir, lod)));\n          }\n          return imageArray;\n        },\n        parameters: {\n          [GL.TEXTURE_WRAP_S]: GL.CLAMP_TO_EDGE,\n          [GL.TEXTURE_WRAP_T]: GL.CLAMP_TO_EDGE,\n          [GL.TEXTURE_MIN_FILTER]: GL.LINEAR_MIPMAP_LINEAR,\n          [GL.TEXTURE_MAG_FILTER]: GL.LINEAR\n        }\n      });\n    }\n\n    return this._SpecularEnvSampler;\n  }\n\n  getBrdfTexture() {\n    if (!this._BrdfTexture) {\n      this._BrdfTexture = new Texture2D(this.gl, {\n        id: 'brdfLUT',\n        parameters: {\n          [GL.TEXTURE_WRAP_S]: GL.CLAMP_TO_EDGE,\n          [GL.TEXTURE_WRAP_T]: GL.CLAMP_TO_EDGE,\n          [GL.TEXTURE_MIN_FILTER]: GL.LINEAR,\n          [GL.TEXTURE_MAG_FILTER]: GL.LINEAR\n        },\n        pixelStore: {\n          [this.gl.UNPACK_FLIP_Y_WEBGL]: false\n        },\n        // Texture2D accepts a promise that returns an image as data (Async Textures)\n        data: loadImage(this.brdfLutUrl)\n      });\n    }\n\n    return this._BrdfTexture;\n  }\n\n  delete() {\n    if (this._DiffuseEnvSampler) {\n      this._DiffuseEnvSampler.delete();\n      this._DiffuseEnvSampler = null;\n    }\n\n    if (this._SpecularEnvSampler) {\n      this._SpecularEnvSampler.delete();\n      this._SpecularEnvSampler = null;\n    }\n\n    if (this._BrdfTexture) {\n      this._BrdfTexture.delete();\n      this._BrdfTexture = null;\n    }\n  }\n}\n","/* eslint-disable camelcase */\n/* global document, window */\nimport {parse} from '@loaders.gl/core';\n// eslint-disable-next-line import/no-unresolved\nimport {DracoLoader} from '@loaders.gl/draco';\nimport '@loaders.gl/polyfills'; // text-encoding polyfill for older MS browsers\nimport GL from '@luma.gl/constants';\nimport {AnimationLoop, setParameters, clear, log, lumaStats} from '@luma.gl/core';\nimport {\n  GLTFScenegraphLoader,\n  createGLTFObjects,\n  GLTFEnvironment,\n  Timeline,\n  VRDisplay\n} from '@luma.gl/addons';\nimport {Matrix4, radians} from 'math.gl';\n\nconst CUBE_FACE_TO_DIRECTION = {\n  [GL.TEXTURE_CUBE_MAP_POSITIVE_X]: 'right',\n  [GL.TEXTURE_CUBE_MAP_NEGATIVE_X]: 'left',\n  [GL.TEXTURE_CUBE_MAP_POSITIVE_Y]: 'top',\n  [GL.TEXTURE_CUBE_MAP_NEGATIVE_Y]: 'bottom',\n  [GL.TEXTURE_CUBE_MAP_POSITIVE_Z]: 'front',\n  [GL.TEXTURE_CUBE_MAP_NEGATIVE_Z]: 'back'\n};\n\n// Damaged helmet model used under creative commons: https://github.com/KhronosGroup/glTF-Sample-Models/tree/1ba47770292486e66ca1e1161857a6e5695c2631/2.0/DamagedHelmet\n// Papermill textures used under Apache 2.0: https://github.com/KhronosGroup/glTF-Sample-Viewer/blob/e2d487693fa2e6148bd29d05bc82586f5a002a45/LICENSE.md\n\nconst GLTF_BASE_URL =\n  'https://raw.githubusercontent.com/uber-common/deck.gl-data/master/luma.gl/examples/gltf/';\nconst GLTF_DEFAULT_MODEL = 'DamagedHelmet.glb';\n\n// URL for animated model\n// 'https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Models/master/2.0/InterpolationTest/glTF-Binary/InterpolationTest.glb';\n\nconst INFO_HTML = `\n<p><b>glTF Loader</b>.</p>\n<p>Rendered using luma.gl.</p>\n<div>\n  Show\n  <select id=\"showSelector\">\n    <option value=\"0 0 0 0 0 0 0 0\">Final Result</option>\n\n    <option value=\"0 1 0 0 0 0 0 0\">Base Color</option>\n    <option value=\"0 0 1 0 0 0 0 0\">Metallic</option>\n    <option value=\"0 0 0 1 0 0 0 0\">Roughness</option>\n    <option value=\"1 0 0 0 0 0 0 0\">Diffuse</option>\n\n    <option value=\"0 0 0 0 1 0 0 0\">Specular Reflection</option>\n    <option value=\"0 0 0 0 0 1 0 0\">Geometric Occlusion</option>\n    <option value=\"0 0 0 0 0 0 1 0\">Microfacet Distribution</option>\n    <option value=\"0 0 0 0 0 0 0 1\">Specular</option>\n  </select>\n  <br>\n</div>\n<div>\n  Regular Lights\n  <select id=\"lightSelector\">\n    <option value=\"default\">Default</option>\n    <option value=\"ambient\">Ambient Only</option>\n    <option value=\"directional1\">1x Directional (Red) + Ambient</option>\n    <option value=\"directional3\">3x Directional (RGB)</option>\n    <option value=\"point1far\">1x Point Light Far (Red) + Ambient</option>\n    <option value=\"point1near\">1x Point Light Near (Red) + Ambient</option>\n  </select>\n  <br>\n</div>\n<div>\n  Image-Based Light\n  <select id=\"iblSelector\">\n    <option value=\"exclusive\">On (Exclusive)</option>\n    <option value=\"addition\">On (Addition to Regular)</option>\n    <option value=\"off\">Off (Only Regular)</option>\n  </select>\n  <br>\n</div>\n<p><img src=\"https://img.shields.io/badge/WebVR-Supported-orange.svg\" /></p>\n`;\n\nconst LIGHT_SOURCES = {\n  default: {\n    directionalLights: [\n      {\n        color: [255, 255, 255],\n        direction: [0.0, 0.5, 0.5],\n        intensity: 1.0\n      }\n    ]\n  },\n  ambient: {\n    ambientLight: {\n      color: [255, 255, 255],\n      intensity: 1.0\n    }\n  },\n  directional1: {\n    directionalLights: [\n      {\n        color: [255, 0, 0],\n        direction: [1.0, 0.0, 0.0],\n        intensity: 1.0\n      }\n    ],\n    ambientLight: {\n      color: [255, 255, 255],\n      intensity: 1.0\n    }\n  },\n  directional3: {\n    directionalLights: [\n      {\n        color: [255, 0.0, 0.0],\n        direction: [1.0, 0.0, 0.0],\n        intensity: 1.0\n      },\n      {\n        color: [0.0, 0.0, 255],\n        direction: [0.0, 0.0, 1.0],\n        intensity: 1.0\n      },\n      {\n        color: [0.0, 255, 0.0],\n        direction: [0.0, 1.0, 0.0],\n        intensity: 1.0\n      }\n    ]\n  },\n  point1far: {\n    pointLights: [\n      {\n        color: [255, 0, 0],\n        position: [200.0, 0.0, 0.0],\n        attenuation: [0, 0, 0.01],\n        intensity: 1.0\n      }\n    ],\n    ambientLight: {\n      color: [255, 255, 255],\n      intensity: 1.0\n    }\n  },\n  point1near: {\n    pointLights: [\n      {\n        color: [255, 0, 0],\n        position: [10.0, 0.0, 0.0],\n        attenuation: [0, 0, 0.01],\n        intensity: 1.0\n      }\n    ],\n    ambientLight: {\n      color: [255, 255, 255],\n      intensity: 1.0\n    }\n  }\n};\n\nconst DEFAULT_OPTIONS = {\n  pbrDebug: true,\n  imageBasedLightingEnvironment: null,\n  lights: false\n};\n\nasync function loadGLTF(urlOrPromise, gl, options) {\n  const data = typeof urlOrPromise === 'string' ? window.fetch(urlOrPromise) : urlOrPromise;\n  const {gltf, scenes, animator} = await parse(data, GLTFScenegraphLoader, {\n    ...options,\n    gl,\n    DracoLoader\n  });\n\n  scenes[0].traverse((node, {worldMatrix}) => log.info(4, 'Using model: ', node)());\n  return {scenes, animator, gltf};\n}\n\nexport default class AppAnimationLoop extends AnimationLoop {\n  static getInfo() {\n    return INFO_HTML;\n  }\n  constructor(opts = {}) {\n    super({\n      ...opts,\n      glOptions: {\n        // Use to test gltf with webgl 1.0 and 2.0\n        webgl1: true,\n        webgl2: true,\n        // alpha causes issues with some glTF demos\n        alpha: false\n      }\n    });\n\n    const {modelFile = null, initialZoom = 2} = opts;\n    this.scenes = [];\n    this.animator = null;\n    this.gl = null;\n    this.modelFile = modelFile;\n\n    this.mouse = {\n      lastX: 0,\n      lastY: 0\n    };\n\n    this.translate = initialZoom;\n    this.rotation = [0, 0];\n    this.rotationStart = [0, 0];\n\n    this.u_ScaleDiffBaseMR = [0, 0, 0, 0];\n    this.u_ScaleFGDSpec = [0, 0, 0, 0];\n\n    this.attachTimeline(new Timeline());\n    this.timeline.play();\n    this.timelineChannel = this.timeline.addChannel({\n      rate: 0.5\n    });\n    this.animationHandle = null;\n\n    this.onInitialize = this.onInitialize.bind(this);\n    this.onRender = this.onRender.bind(this);\n    this._setDisplay(new VRDisplay());\n  }\n\n  initalizeEventHandling(canvas) {\n    let pointerIsDown = false;\n\n    const pointerDown = (x, y) => {\n      this.mouse.lastX = x;\n      this.mouse.lastY = y;\n\n      this.rotationStart[0] = this.rotation[0];\n      this.rotationStart[1] = this.rotation[1];\n\n      pointerIsDown = true;\n    };\n\n    const pointerMove = (x, y) => {\n      if (!pointerIsDown) {\n        return;\n      }\n\n      const dX = x - this.mouse.lastX;\n      const dY = y - this.mouse.lastY;\n\n      this.rotation[0] = this.rotationStart[0] + dY / 100;\n      this.rotation[1] = this.rotationStart[1] + dX / 100;\n    };\n\n    canvas.addEventListener('wheel', e => {\n      this.translate += e.deltaY / 10;\n      if (this.translate < 0.5) {\n        this.translate = 0.5;\n      }\n      e.preventDefault();\n    });\n\n    canvas.addEventListener('mousedown', e => {\n      pointerDown(e.clientX, e.clientY);\n\n      e.preventDefault();\n    });\n\n    canvas.addEventListener('mouseup', e => {\n      pointerIsDown = false;\n    });\n\n    canvas.addEventListener('mousemove', e => {\n      pointerMove(e.clientX, e.clientY);\n    });\n\n    canvas.addEventListener('touchstart', e => {\n      pointerDown(e.touches[0].clientX, e.touches[0].clientY);\n\n      e.preventDefault();\n    });\n\n    canvas.addEventListener('touchmove', e => {\n      pointerMove(e.touches[0].clientX, e.touches[0].clientY);\n    });\n\n    canvas.addEventListener('touchend', e => {\n      if (e.touches.length === 0) {\n        pointerIsDown = false;\n      }\n    });\n\n    canvas.addEventListener('dragover', e => {\n      e.dataTransfer.dropEffect = 'link';\n      e.preventDefault();\n    });\n\n    canvas.addEventListener('drop', e => {\n      e.preventDefault();\n      if (e.dataTransfer.files && e.dataTransfer.files.length === 1) {\n        this._deleteScenes();\n        const readPromise = new Promise(resolve => {\n          const reader = new window.FileReader();\n          reader.onload = ev => resolve(ev.target.result);\n          reader.readAsArrayBuffer(e.dataTransfer.files[0]);\n        });\n\n        loadGLTF(readPromise, this.gl, this.loadOptions).then(result => this._fileLoaded(result));\n      }\n    });\n  }\n\n  _fileLoaded(loadResult) {\n    if (this.animationHandle !== null) {\n      this.timeline.detachAnimation(this.animationHandle);\n      this.animationHandle = null;\n    }\n    this.animator = null;\n\n    Object.assign(this, loadResult);\n    if (this.animator) {\n      this.animationHandle = this.timeline.attachAnimation(this.animator, this.timelineChannel);\n    }\n  }\n\n  onInitialize({gl, canvas}) {\n    setParameters(gl, {\n      depthTest: true,\n      blend: false\n    });\n\n    this.loadOptions = DEFAULT_OPTIONS;\n    this.environment = new GLTFEnvironment(gl, {\n      brdfLutUrl: `${GLTF_BASE_URL}/brdfLUT.png`,\n      getTexUrl: (type, dir, mipLevel) =>\n        `${GLTF_BASE_URL}/papermill/${type}/${type}_${CUBE_FACE_TO_DIRECTION[dir]}_${mipLevel}.jpg`\n    });\n    this.loadOptions.imageBasedLightingEnvironment = this.environment;\n\n    this.gl = gl;\n    if (this.modelFile) {\n      // options for unit testing\n      const options = {\n        pbrDebug: false,\n        imageBasedLightingEnvironment: null,\n        lights: true\n      };\n      loadGLTF(this.modelFile, this.gl, options).then(result => this._fileLoaded(result));\n    } else {\n      const modelUrl = GLTF_DEFAULT_MODEL;\n      loadGLTF(GLTF_BASE_URL + modelUrl, this.gl, this.loadOptions).then(result =>\n        this._fileLoaded(result)\n      );\n    }\n\n    const showSelector = document.getElementById('showSelector');\n    if (showSelector) {\n      showSelector.onchange = event => {\n        const value = showSelector.value.split(' ').map(x => parseFloat(x));\n        this.u_ScaleDiffBaseMR = value.slice(0, 4);\n        this.u_ScaleFGDSpec = value.slice(4);\n      };\n    }\n\n    const lightSelector = document.getElementById('lightSelector');\n    if (lightSelector) {\n      lightSelector.onchange = event => {\n        this.light = lightSelector.value;\n      };\n    }\n\n    const iblSelector = document.getElementById('iblSelector');\n    if (iblSelector) {\n      iblSelector.onchange = event => {\n        this._updateLightSettings(iblSelector.value);\n        this._rebuildModel();\n      };\n    }\n\n    this.initalizeEventHandling(canvas);\n  }\n\n  _updateLightSettings(value) {\n    switch (value) {\n      case 'exclusive':\n        Object.assign(this.loadOptions, {\n          imageBasedLightingEnvironment: this.environment,\n          lights: false\n        });\n        break;\n\n      case 'addition':\n        Object.assign(this.loadOptions, {\n          imageBasedLightingEnvironment: this.environment,\n          lights: true\n        });\n        break;\n\n      case 'off':\n        Object.assign(this.loadOptions, {\n          imageBasedLightingEnvironment: null,\n          lights: true\n        });\n        break;\n\n      default:\n        break;\n    }\n  }\n\n  _rebuildModel() {\n    // Clean and regenerate model so we have new \"#defines\"\n    // TODO: Find better way to do this\n    (this.gltf.meshes || []).forEach(mesh => delete mesh._mesh);\n    (this.gltf.nodes || []).forEach(node => delete node._node);\n    (this.gltf.bufferViews || []).forEach(bufferView => delete bufferView.lumaBuffers);\n\n    this._deleteScenes();\n    Object.assign(this, createGLTFObjects(this.gl, this.gltf, this.loadOptions));\n  }\n\n  _deleteScenes() {\n    this.scenes.forEach(scene => scene.delete());\n    this.scenes = [];\n\n    lumaStats.get('Resource Counts').forEach(({name, count}) => {\n      log.info(3, `${name}: ${count}`)();\n    });\n  }\n\n  applyLight(model) {\n    // TODO: only do this when light changes\n    model.updateModuleSettings({\n      lightSources: LIGHT_SOURCES[this.light || 'default']\n    });\n  }\n\n  onRender({gl, time, aspect, viewMatrix, projectionMatrix}) {\n    clear(gl, {color: [0.2, 0.2, 0.2, 1.0], depth: true});\n\n    const [pitch, roll] = this.rotation;\n    const cameraPos = [\n      -this.translate * Math.sin(roll) * Math.cos(-pitch),\n      -this.translate * Math.sin(-pitch),\n      this.translate * Math.cos(roll) * Math.cos(-pitch)\n    ];\n\n    // TODO: find how to avoid using Array.from() to convert TypedArray to regular array\n    const uView = new Matrix4(viewMatrix ? Array.from(viewMatrix) : null)\n      .translate([0, 0, -this.translate])\n      .rotateX(pitch)\n      .rotateY(roll);\n\n    const uProjection = projectionMatrix\n      ? new Matrix4(Array.from(projectionMatrix))\n      : new Matrix4().perspective({fov: radians(40), aspect, near: 0.1, far: 9000});\n\n    if (!this.scenes.length) return false;\n\n    let success = true;\n\n    this.scenes[0].traverse((model, {worldMatrix}) => {\n      // In glTF, meshes and primitives do no have their own matrix.\n      const u_MVPMatrix = new Matrix4(uProjection).multiplyRight(uView).multiplyRight(worldMatrix);\n      this.applyLight(model);\n      success =\n        success &&\n        model.draw({\n          uniforms: {\n            u_Camera: cameraPos,\n            u_MVPMatrix,\n            u_ModelMatrix: worldMatrix,\n            u_NormalMatrix: new Matrix4(worldMatrix).invert().transpose(),\n\n            u_ScaleDiffBaseMR: this.u_ScaleDiffBaseMR,\n            u_ScaleFGDSpec: this.u_ScaleFGDSpec\n          },\n          parameters: model.props.parameters\n        });\n    });\n\n    return success;\n  }\n}\n\nif (typeof window !== 'undefined' && !window.website) {\n  const animationLoop = new AppAnimationLoop();\n  animationLoop.start();\n\n  const infoDiv = document.createElement('div');\n  infoDiv.innerHTML = AppAnimationLoop.getInfo();\n  document.body.appendChild(infoDiv);\n}\n","import React from 'react';\nimport AnimationLoopExamplePage from '../../src/components/animation-loop-example-page';\nimport AnimationLoop from '../../../examples/core/gltf/app';\n\nexport default class Example extends React.Component {\n  render() {\n    return (\n      <AnimationLoopExamplePage AnimationLoop={AnimationLoop} exampleConfig={this.props.pageContext.exampleConfig} />\n    );\n  }\n}\n","// Feature detection for WebGL\n//\n// Provides a function that enables simple checking of which WebGL features are\n// available in an WebGL1 or WebGL2 environment.\n\n/* eslint-disable no-inline-comments, max-len */\nimport isOldIE from './is-old-ie';\nimport assert from './assert';\n\nconst GL_VENDOR = 0x1f00;\nconst GL_RENDERER = 0x1f01;\nconst GL_VERSION = 0x1f02;\nconst GL_SHADING_LANGUAGE_VERSION = 0x8b8c;\n\n// Defines luma.gl \"feature\" names and semantics\nconst WEBGL_FEATURES = {\n  // GLSL extensions\n  GLSL_FRAG_DATA: ['WEBGL_draw_buffers', true], // TODO - name makes no sense in GLSL 3.00\n  GLSL_FRAG_DEPTH: ['EXT_frag_depth', true],\n  GLSL_DERIVATIVES: ['OES_standard_derivatives', true],\n  GLSL_TEXTURE_LOD: ['EXT_shader_texture_lod', true]\n};\n\n// Create a key-mirrored FEATURES array\nconst FEATURES = {};\nObject.keys(WEBGL_FEATURES).forEach(key => {\n  FEATURES[key] = key;\n});\n\nexport {FEATURES};\n\nfunction isWebGL2(gl) {\n  return Boolean(gl && gl._version === 2);\n}\n\nexport function getContextInfo(gl) {\n  const info = gl.getExtension('WEBGL_debug_renderer_info');\n  const vendor = gl.getParameter((info && info.UNMASKED_VENDOR_WEBGL) || GL_VENDOR);\n  const renderer = gl.getParameter((info && info.UNMASKED_RENDERER_WEBGL) || GL_RENDERER);\n  const gpuVendor = identifyGPUVendor(vendor, renderer);\n  const gpuInfo = {\n    gpuVendor,\n    vendor,\n    renderer,\n    version: gl.getParameter(GL_VERSION),\n    shadingLanguageVersion: gl.getParameter(GL_SHADING_LANGUAGE_VERSION)\n  };\n  return gpuInfo;\n}\n\nfunction identifyGPUVendor(vendor, renderer) {\n  if (vendor.match(/NVIDIA/i) || renderer.match(/NVIDIA/i)) {\n    return 'NVIDIA';\n  }\n  if (vendor.match(/INTEL/i) || renderer.match(/INTEL/i)) {\n    return 'INTEL';\n  }\n  if (\n    vendor.match(/AMD/i) ||\n    renderer.match(/AMD/i) ||\n    vendor.match(/ATI/i) ||\n    renderer.match(/ATI/i)\n  ) {\n    return 'AMD';\n  }\n  return 'UNKNOWN GPU';\n}\n\nconst compiledGlslExtensions = {};\n\n// Enables feature detection in IE11 due to a bug where gl.getExtension may return true\n// but fail to compile when the extension is enabled in the shader. Specifically,\n// the OES_standard_derivatives and WEBGL_draw_buffers extensions fails to compile in IE11 even though its included\n// in the list of supported extensions.\n// opts allows user agent to be overridden for testing\n/*\n* Inputs :\n*  gl : WebGL context\n*  cap : Key of WEBGL_FEATURES object identifying the extension\n*  opts :\n*   behavior : behavor of extension to be tested, by defualt `enable` is used\n* Returns : true, if shader is compiled successfully, false otherwise\n*/\nexport function canCompileGLGSExtension(gl, cap, opts = {}) {\n  const feature = WEBGL_FEATURES[cap];\n  assert(feature, cap);\n\n  if (!isOldIE(opts)) {\n    return true;\n  }\n\n  if (cap in compiledGlslExtensions) {\n    return compiledGlslExtensions[cap];\n  }\n\n  const extensionName = feature[0];\n  const behavior = opts.behavior || 'enable';\n  const source = `#extension GL_${extensionName} : ${behavior}\\nvoid main(void) {}`;\n\n  const shader = gl.createShader(gl.VERTEX_SHADER);\n  gl.shaderSource(shader, source);\n  gl.compileShader(shader);\n  const canCompile = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\n  gl.deleteShader(shader);\n  compiledGlslExtensions[cap] = canCompile;\n  return canCompile;\n}\n\n// TODO - cache the value\nfunction getFeature(gl, cap) {\n  const feature = WEBGL_FEATURES[cap];\n  assert(feature, cap);\n\n  // Get extension name from table\n  const extensionName = isWebGL2(gl) ? feature[1] || feature[0] : feature[0];\n\n  // Check if the value is dependent on checking an extension\n  const value =\n    typeof extensionName === 'string' ? Boolean(gl.getExtension(extensionName)) : extensionName;\n\n  assert(value === false || value === true);\n\n  return value;\n}\n\nexport function hasFeatures(gl, features) {\n  features = Array.isArray(features) ? features : [features];\n  return features.every(feature => getFeature(gl, feature));\n}\n","/* global window */\n// opts allows user agent to be overridden for testing\nexport default function isOldIE(opts = {}) {\n  const navigator = typeof window !== 'undefined' ? window.navigator || {} : {};\n  const userAgent = opts.userAgent || navigator.userAgent || '';\n  // We only care about older versions of IE (IE 11 and below). Newer versions of IE (Edge)\n  // have much better web standards support.\n  const isMSIE = userAgent.indexOf('MSIE ') !== -1;\n  const isTrident = userAgent.indexOf('Trident/') !== -1;\n  return isMSIE || isTrident;\n}\n","import {getContextInfo, hasFeatures, canCompileGLGSExtension, FEATURES} from '../utils/webgl-info';\n\nexport function getPlatformShaderDefines(gl) {\n  const debugInfo = getContextInfo(gl);\n\n  switch (debugInfo.gpuVendor.toLowerCase()) {\n    case 'nvidia':\n      return `\\\n#define NVIDIA_GPU\n// Nvidia optimizes away the calculation necessary for emulated fp64\n#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1\n`;\n\n    case 'intel':\n      return `\\\n#define INTEL_GPU\n// Intel optimizes away the calculation necessary for emulated fp64\n#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1\n// Intel's built-in 'tan' function doesn't have acceptable precision\n#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1\n// Intel GPU doesn't have full 32 bits precision in same cases, causes overflow\n#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1\n`;\n\n    case 'amd':\n      // AMD Does not eliminate fp64 code\n      return `\\\n#define AMD_GPU\n`;\n\n    default:\n      // We don't know what GPU it is, could be that the GPU driver or\n      // browser is not implementing UNMASKED_RENDERER constant and not\n      // reporting a correct name\n      return `\\\n#define DEFAULT_GPU\n// Prevent driver from optimizing away the calculation necessary for emulated fp64\n#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1\n// Intel's built-in 'tan' function doesn't have acceptable precision\n#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1\n// Intel GPU doesn't have full 32 bits precision in same cases, causes overflow\n#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1\n`;\n  }\n}\n\nexport function getVersionDefines(gl, glslVersion, isFragment) {\n  // Add shadertools defines to let shaders portably v1/v3 check for features\n  let versionDefines = `\\\n#if (__VERSION__ > 120)\n\n# define FRAG_DEPTH\n# define DERIVATIVES\n# define DRAW_BUFFERS\n# define TEXTURE_LOD\n\n#endif // __VERSION\n`;\n\n  if (hasFeatures(gl, FEATURES.GLSL_FRAG_DEPTH)) {\n    versionDefines += `\\\n// FRAG_DEPTH => gl_FragDepth is available\n#ifdef GL_EXT_frag_depth\n#extension GL_EXT_frag_depth : enable\n# define FRAG_DEPTH\n# define gl_FragDepth gl_FragDepthEXT\n#endif\n`;\n  }\n  if (\n    hasFeatures(gl, FEATURES.GLSL_DERIVATIVES) &&\n    canCompileGLGSExtension(gl, FEATURES.GLSL_DERIVATIVES)\n  ) {\n    versionDefines += `\\\n// DERIVATIVES => dxdF, dxdY and fwidth are available\n#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives : enable\n# define DERIVATIVES\n#endif\n`;\n  }\n  if (\n    hasFeatures(gl, FEATURES.GLSL_FRAG_DATA) &&\n    canCompileGLGSExtension(gl, FEATURES.GLSL_FRAG_DATA, {behavior: 'require'})\n  ) {\n    versionDefines += `\\\n// DRAW_BUFFERS => gl_FragData[] is available\n#ifdef GL_EXT_draw_buffers\n#extension GL_EXT_draw_buffers : require\n#define DRAW_BUFFERS\n#endif\n`;\n  }\n  if (hasFeatures(gl, FEATURES.GLSL_TEXTURE_LOD)) {\n    versionDefines += `\\\n// TEXTURE_LOD => texture2DLod etc are available\n#ifdef GL_EXT_shader_texture_lod\n#extension GL_EXT_shader_texture_lod : enable\n# define TEXTURE_LOD\n#define texture2DLod texture2DLodEXT\n#define texture2DProjLod texture2DProjLodEXT\n#define texture2DProjLod texture2DProjLodEXT\n#define textureCubeLod textureCubeLodEXT\n#define texture2DGrad texture2DGradEXT\n#define texture2DProjGrad texture2DProjGradEXT\n#define texture2DProjGrad texture2DProjGradEXT\n#define textureCubeGrad textureCubeGradEXT\n#endif\n`;\n  }\n  return versionDefines;\n}\n","import {VERTEX_SHADER, FRAGMENT_SHADER} from './constants';\nimport {resolveModules, getShaderModule} from './resolve-modules';\nimport {getPlatformShaderDefines, getVersionDefines} from './platform-defines';\nimport injectShader, {DECLARATION_INJECT_MARKER} from './inject-shader';\nimport {assert} from '../utils';\n/* eslint-disable max-depth, complexity */\n\nconst INJECT_SHADER_DECLARATIONS = `\\n\\n${DECLARATION_INJECT_MARKER}\\n\\n`;\n\nconst SHADER_TYPE = {\n  [VERTEX_SHADER]: 'vertex',\n  [FRAGMENT_SHADER]: 'fragment'\n};\n\nconst HOOK_FUNCTIONS = {\n  [VERTEX_SHADER]: {},\n  [FRAGMENT_SHADER]: {}\n};\n\nconst MODULE_INJECTIONS = {\n  [VERTEX_SHADER]: {},\n  [FRAGMENT_SHADER]: {}\n};\n\n// Precision prologue to inject before functions are injected in shader\n// TODO - extract any existing prologue in the fragment source and move it up...\nconst FRAGMENT_SHADER_PROLOGUE = `\\\nprecision highp float;\n\n`;\n\nexport function createShaderHook(hook, opts = {}) {\n  hook = hook.trim();\n  const [stage, signature] = hook.split(':');\n  const name = hook.replace(/\\(.+/, '');\n  HOOK_FUNCTIONS[stage][name] = Object.assign(opts, {signature});\n}\n\nexport function createModuleInjection(moduleName, opts) {\n  const {hook, injection, order = 0} = opts;\n  const shaderStage = hook.slice(0, 2);\n\n  const moduleInjections = MODULE_INJECTIONS[shaderStage];\n  moduleInjections[moduleName] = moduleInjections[moduleName] || {};\n\n  assert(!moduleInjections[moduleName][hook], 'Module injection already created');\n\n  moduleInjections[moduleName][hook] = {\n    injection,\n    order\n  };\n}\n\n// Helpful for tests\nexport function resetGlobalShaderHooks() {\n  HOOK_FUNCTIONS[VERTEX_SHADER] = {};\n  HOOK_FUNCTIONS[FRAGMENT_SHADER] = {};\n\n  MODULE_INJECTIONS[VERTEX_SHADER] = {};\n  MODULE_INJECTIONS[FRAGMENT_SHADER] = {};\n}\n\n// Inject a list of modules\nexport function assembleShaders(gl, opts) {\n  const {vs, fs} = opts;\n  const modules = resolveModules(opts.modules || []);\n  return {\n    gl,\n    vs: assembleShader(gl, Object.assign({}, opts, {source: vs, type: VERTEX_SHADER, modules})),\n    fs: assembleShader(gl, Object.assign({}, opts, {source: fs, type: FRAGMENT_SHADER, modules})),\n    getUniforms: assembleGetUniforms(modules),\n    modules: assembleModuleMap(modules)\n  };\n}\n\n// Pulls together complete source code for either a vertex or a fragment shader\n// adding prologues, requested module chunks, and any final injections.\nfunction assembleShader(\n  gl,\n  {\n    id,\n    source,\n    type,\n    modules,\n    defines = {},\n    hookFunctions = HOOK_FUNCTIONS,\n    moduleInjections = MODULE_INJECTIONS,\n    inject = {},\n    prologue = true,\n    log\n  }\n) {\n  assert(typeof source === 'string', 'shader source must be a string');\n\n  // TODO(Tarek): Supporting global hooks, remove when they're removed.\n  if (hookFunctions !== HOOK_FUNCTIONS) {\n    hookFunctions = {\n      [VERTEX_SHADER]: Object.assign(\n        {},\n        HOOK_FUNCTIONS[VERTEX_SHADER],\n        hookFunctions[VERTEX_SHADER]\n      ),\n      [FRAGMENT_SHADER]: Object.assign(\n        {},\n        HOOK_FUNCTIONS[FRAGMENT_SHADER],\n        hookFunctions[FRAGMENT_SHADER]\n      )\n    };\n  }\n\n  if (moduleInjections !== MODULE_INJECTIONS) {\n    moduleInjections = {\n      [VERTEX_SHADER]: Object.assign(\n        {},\n        MODULE_INJECTIONS[VERTEX_SHADER],\n        moduleInjections[VERTEX_SHADER]\n      ),\n      [FRAGMENT_SHADER]: Object.assign(\n        {},\n        MODULE_INJECTIONS[FRAGMENT_SHADER],\n        moduleInjections[FRAGMENT_SHADER]\n      )\n    };\n  }\n\n  const isVertex = type === VERTEX_SHADER;\n\n  const sourceLines = source.split('\\n');\n  let glslVersion = 100;\n  let versionLine = '';\n  let coreSource = source;\n  // Extract any version directive string from source.\n  // TODO : keep all pre-processor statements at the begining of the shader.\n  if (sourceLines[0].indexOf('#version ') === 0) {\n    glslVersion = 300; // TODO - regexp that matches atual version number\n    versionLine = sourceLines[0];\n    coreSource = sourceLines.slice(1).join('\\n');\n  } else {\n    versionLine = `#version ${glslVersion}`;\n  }\n\n  // Combine Module and Application Defines\n  const allDefines = {};\n  modules.forEach(module => {\n    Object.assign(allDefines, module.getDefines());\n  });\n  Object.assign(allDefines, defines);\n\n  // Add platform defines (use these to work around platform-specific bugs and limitations)\n  // Add common defines (GLSL version compatibility, feature detection)\n  // Add precision declaration for fragment shaders\n  let assembledSource = prologue\n    ? `\\\n${versionLine}\n${getShaderName({id, source, type})}\n${getShaderType({type})}\n${getPlatformShaderDefines(gl)}\n${getVersionDefines(gl, glslVersion, !isVertex)}\n${getApplicationDefines(allDefines)}\n${isVertex ? '' : FRAGMENT_SHADER_PROLOGUE}\n`\n    : `${versionLine}\n`;\n\n  // Add source of dependent modules in resolved order\n  let injectStandardStubs = false;\n  const hookInjections = {};\n  const mainInjections = {};\n\n  for (const key in inject) {\n    const injection =\n      typeof inject[key] === 'string' ? {injection: inject[key], order: 0} : inject[key];\n    if (key.match(/^(v|f)s:/)) {\n      if (key[3] === '#') {\n        mainInjections[key] = [injection];\n      } else {\n        hookInjections[key] = [injection];\n      }\n    } else {\n      // Regex injection\n      mainInjections[key] = [injection];\n    }\n  }\n\n  for (const module of modules) {\n    switch (module.name) {\n      case 'inject':\n        injectStandardStubs = true;\n        break;\n\n      default:\n        if (log) {\n          module.checkDeprecations(coreSource, log);\n        }\n        const moduleSource = module.getModuleSource(type, glslVersion);\n        // Add the module source, and a #define that declares it presence\n        assembledSource += moduleSource;\n\n        if (moduleInjections[type][module.name]) {\n          const injections = moduleInjections[type][module.name];\n          for (const key in injections) {\n            if (key.match(/^(v|f)s:#/)) {\n              mainInjections[key] = mainInjections[key] || [];\n              mainInjections[key].push(injections[key]);\n            } else {\n              hookInjections[key] = hookInjections[key] || [];\n              hookInjections[key].push(injections[key]);\n            }\n          }\n        }\n    }\n  }\n\n  // For injectShader\n  assembledSource += INJECT_SHADER_DECLARATIONS;\n\n  assembledSource += getHookFunctions(hookFunctions[type], hookInjections);\n\n  // Add the version directive and actual source of this shader\n  assembledSource += coreSource;\n\n  // Apply any requested shader injections\n  assembledSource = injectShader(assembledSource, type, mainInjections, injectStandardStubs);\n\n  return assembledSource;\n}\n\n// Returns a combined `getUniforms` covering the options for all the modules,\n// the created function will pass on options to the inidividual `getUniforms`\n// function of each shader module and combine the results into one object that\n// can be passed to setUniforms.\nfunction assembleGetUniforms(modules) {\n  return function getUniforms(opts) {\n    const uniforms = {};\n    for (const module of modules) {\n      // `modules` is already sorted by dependency level. This guarantees that\n      // modules have access to the uniforms that are generated by their dependencies.\n      const moduleUniforms = module.getUniforms(opts, uniforms);\n      Object.assign(uniforms, moduleUniforms);\n    }\n    return uniforms;\n  };\n}\n\n// Returns a map with module names as keys, resolving to their module definitions\n// The presence of a key indicates that the module is available in this program,\n// whether directly included, or through a dependency of some other module\nfunction assembleModuleMap(modules) {\n  const result = {};\n  for (const moduleName of modules) {\n    const shaderModule = getShaderModule(moduleName);\n    result[moduleName] = shaderModule;\n  }\n  return result;\n}\n\nfunction getShaderType({type}) {\n  return `\n#define SHADER_TYPE_${SHADER_TYPE[type].toUpperCase()}\n`;\n}\n\n// Generate \"glslify-compatible\" SHADER_NAME defines\n// These are understood by the GLSL error parsing function\n// If id is provided and no SHADER_NAME constant is present in source, create one\nfunction getShaderName({id, source, type}) {\n  const injectShaderName = id && typeof id === 'string' && source.indexOf('SHADER_NAME') === -1;\n  return injectShaderName\n    ? `\n#define SHADER_NAME ${id}_${SHADER_TYPE[type]}\n\n`\n    : '';\n}\n\n// Generates application defines from an object\nfunction getApplicationDefines(defines = {}) {\n  let count = 0;\n  let sourceText = '';\n  for (const define in defines) {\n    if (count === 0) {\n      sourceText += '\\n// APPLICATION DEFINES\\n';\n    }\n    count++;\n\n    const value = defines[define];\n    if (value || Number.isFinite(value)) {\n      sourceText += `#define ${define.toUpperCase()} ${defines[define]}\\n`;\n    }\n  }\n  if (count === 0) {\n    sourceText += '\\n';\n  }\n  return sourceText;\n}\n\nfunction getHookFunctions(hookFunctions, hookInjections) {\n  let result = '';\n  for (const hookName in hookFunctions) {\n    const hookFunction = hookFunctions[hookName];\n    result += `void ${hookFunction.signature} {\\n`;\n    if (hookFunction.header) {\n      result += `  ${hookFunction.header}`;\n    }\n    if (hookInjections[hookName]) {\n      const injections = hookInjections[hookName];\n      injections.sort((a, b) => a.order - b.order);\n      for (const injection of injections) {\n        result += `  ${injection.injection}\\n`;\n      }\n    }\n    if (hookFunction.footer) {\n      result += `  ${hookFunction.footer}`;\n    }\n    result += '}\\n';\n  }\n\n  return result;\n}\n","import ShaderModule from './shader-module';\nimport {assert} from '../utils';\n\nexport default class ShaderModuleRegistry {\n  constructor() {\n    this.shaderModules = {};\n    this.defaultShaderModules = [];\n  }\n\n  setDefaultShaderModules(modules) {\n    this.defaultShaderModules = this.resolveModules(modules);\n  }\n\n  getDefaultShaderModules() {\n    return this.defaultShaderModules;\n  }\n\n  registerShaderModules(shaderModuleList, {ignoreMultipleRegistrations = false} = {}) {\n    for (const shaderModule of shaderModuleList) {\n      this._registerShaderModule(shaderModule, ignoreMultipleRegistrations);\n    }\n  }\n\n  getShaderModule(moduleOrName) {\n    // Check if \"inline\" module, return it\n    if (moduleOrName instanceof ShaderModule) {\n      return moduleOrName;\n    }\n\n    // Check if module descriptor\n    if (typeof moduleOrName !== 'string') {\n      return this._registerShaderModule(moduleOrName, true);\n    }\n\n    // Module name - Look up module\n    const module = this.shaderModules[moduleOrName];\n    if (!module) {\n      assert(false, `Unknown shader module ${moduleOrName}`);\n    }\n    return module;\n  }\n\n  // registers any supplied modules, resolves any names into modules\n  // returns a list of modules\n  resolveModules(modules) {\n    return modules.map(moduleOrName => this.getShaderModule(moduleOrName));\n  }\n\n  // PRIVATE API\n\n  _registerShaderModule(module, ignoreMultipleRegistrations = false) {\n    // Check if \"inline\" module, return it\n    if (module instanceof ShaderModule) {\n      return module;\n    }\n\n    assert(module.name, 'shader module has no name');\n\n    if (!this.shaderModules[module.name] || ignoreMultipleRegistrations) {\n      // if ignoreMultipleRegistrations = true, we allow module to be re-registered\n      module = new ShaderModule(module);\n      module.dependencies = this.resolveModules(module.dependencies);\n      this.shaderModules[module.name] = module;\n    } else {\n      // TODO - instead verify that definition is not changing...\n      throw new Error(`shader module ${module.name} already registered`);\n    }\n\n    return this.shaderModules[module.name];\n  }\n}\n","import ShaderModuleRegistry from './shader-module-registry';\n\nconst shaderModuleRegistry = new ShaderModuleRegistry();\n\n/**\n * Registers an array of default shader modules. These will be concatenated\n * automatically at the end of any shader module list passed to\n * `assembleShaders` (plus `resolveModules` and `getShaderDependencies`)\n * @param {Object[]} modules - Array of shader modules\n */\nexport function setDefaultShaderModules(modules) {\n  shaderModuleRegistry.setDefaultShaderModules(modules);\n}\n\nexport function getDefaultShaderModules() {\n  return shaderModuleRegistry.getDefaultShaderModules();\n}\n\n/**\n * Registers an array of shader modules\n * @param {Object[]} shaderModuleList - Array of shader modules\n */\nexport function registerShaderModules(\n  shaderModuleList,\n  {ignoreMultipleRegistrations = false} = {}\n) {\n  shaderModuleRegistry.registerShaderModules(shaderModuleList, {ignoreMultipleRegistrations});\n}\n\n// registers any supplied modules and returns a list of module names\nexport function resolveModules(modules) {\n  modules = modules.concat(shaderModuleRegistry.defaultShaderModules);\n  modules = shaderModuleRegistry.resolveModules(modules);\n  return getShaderDependencies(modules);\n}\n\n// Looks up a moduleName among registered modules and returns definition.\n// If \"inline\" module, returns it directly\nexport function getShaderModule(moduleOrName) {\n  return shaderModuleRegistry.getShaderModule(moduleOrName);\n}\n\n/**\n * Takes a list of shader module names and returns a new list of\n * shader module names that includes all dependencies, sorted so\n * that modules that are dependencies of other modules come first.\n *\n * If the shader glsl code from the returned modules is concatenated\n * in the reverse order, it is guaranteed that all functions be resolved and\n * that all function and variable definitions come before use.\n *\n * @param {String[]} modules - Array of modules (inline modules or module names)\n * @return {String[]} - Array of modules\n */\nfunction getShaderDependencies(modules) {\n  const moduleMap = {};\n  const moduleDepth = {};\n  getDependencyGraph({modules, level: 0, moduleMap, moduleDepth});\n\n  // Return a reverse sort so that dependencies come before the modules that use them\n  return Object.keys(moduleDepth)\n    .sort((a, b) => moduleDepth[b] - moduleDepth[a])\n    .map(name => moduleMap[name]);\n}\n\n/**\n * Recursively checks module dpendencies to calculate dependency\n * level of each module.\n *\n * @param {String[]} modules - Array of modules\n * @param {Number} level - Current level\n * @return {result} - Map of module name to its level\n */\n// Adds another level of dependencies to the result map\nfunction getDependencyGraph({modules, level, moduleMap, moduleDepth}) {\n  if (level >= 5) {\n    throw new Error('Possible loop in shader dependency graph');\n  }\n\n  // Update level on all current modules\n  for (const module of modules) {\n    moduleMap[module.name] = module;\n    if (moduleDepth[module.name] === undefined || moduleDepth[module.name] < level) {\n      moduleDepth[module.name] = level;\n    }\n  }\n\n  // Recurse\n  for (const module of modules) {\n    if (module.dependencies) {\n      getDependencyGraph({modules: module.dependencies, level: level + 1, moduleMap, moduleDepth});\n    }\n  }\n}\n\nexport const TEST_EXPORTS = {\n  getShaderDependencies,\n  getDependencyGraph\n};\n","import {Vector3, Matrix4} from 'math.gl';\nimport {assert, uid} from '../../utils';\n\nexport default class ScenegraphNode {\n  constructor(props = {}) {\n    const {id} = props;\n\n    this.id = id || uid(this.constructor.name);\n\n    this.display = true; // whether to display the object at all\n    this.position = new Vector3();\n    this.rotation = new Vector3();\n    this.scale = new Vector3(1, 1, 1);\n    this.matrix = new Matrix4();\n    this.userData = {};\n\n    this.props = {};\n    this._setScenegraphNodeProps(props);\n  }\n\n  delete() {}\n\n  setProps(props) {\n    this._setScenegraphNodeProps(props);\n    return this;\n  }\n\n  toString() {\n    return `{type: ScenegraphNode, id: ${this.id})}`;\n  }\n\n  setPosition(position) {\n    assert(position.length === 3, 'setPosition requires vector argument');\n    this.position = position;\n    return this;\n  }\n\n  setRotation(rotation) {\n    assert(rotation.length === 3, 'setRotation requires vector argument');\n    this.rotation = rotation;\n    return this;\n  }\n\n  setScale(scale) {\n    assert(scale.length === 3, 'setScale requires vector argument');\n    this.scale = scale;\n    return this;\n  }\n\n  setMatrix(matrix, copyMatrix = true) {\n    if (copyMatrix) {\n      this.matrix.copy(matrix);\n    } else {\n      this.matrix = matrix;\n    }\n  }\n\n  setMatrixComponents({position, rotation, scale, update = true}) {\n    if (position) {\n      this.setPosition(position);\n    }\n    if (rotation) {\n      this.setRotation(rotation);\n    }\n    if (scale) {\n      this.setScale(scale);\n    }\n    if (update) {\n      this.updateMatrix();\n    }\n    return this;\n  }\n\n  updateMatrix() {\n    const pos = this.position;\n    const rot = this.rotation;\n    const scale = this.scale;\n\n    this.matrix.identity();\n    this.matrix.translate(pos);\n    this.matrix.rotateXYZ(rot);\n    this.matrix.scale(scale);\n    return this;\n  }\n\n  update({position, rotation, scale} = {}) {\n    if (position) {\n      this.setPosition(position);\n    }\n    if (rotation) {\n      this.setRotation(rotation);\n    }\n    if (scale) {\n      this.setScale(scale);\n    }\n    this.updateMatrix();\n    return this;\n  }\n\n  getCoordinateUniforms(viewMatrix, modelMatrix) {\n    // TODO - solve multiple class problem\n    // assert(viewMatrix instanceof Matrix4);\n    assert(viewMatrix);\n    modelMatrix = modelMatrix || this.matrix;\n    const worldMatrix = new Matrix4(viewMatrix).multiplyRight(modelMatrix);\n    const worldInverse = worldMatrix.invert();\n    const worldInverseTranspose = worldInverse.transpose();\n\n    return {\n      viewMatrix,\n      modelMatrix,\n      objectMatrix: modelMatrix,\n      worldMatrix,\n      worldInverseMatrix: worldInverse,\n      worldInverseTransposeMatrix: worldInverseTranspose\n    };\n  }\n\n  // TODO - copied code, not yet vetted\n  /*\n  transform() {\n    if (!this.parent) {\n      this.endPosition.set(this.position);\n      this.endRotation.set(this.rotation);\n      this.endScale.set(this.scale);\n    } else {\n      const parent = this.parent;\n      this.endPosition.set(this.position.add(parent.endPosition));\n      this.endRotation.set(this.rotation.add(parent.endRotation));\n      this.endScale.set(this.scale.add(parent.endScale));\n    }\n\n    const ch = this.children;\n    for (let i = 0; i < ch.length; ++i) {\n      ch[i].transform();\n    }\n\n    return this;\n  }\n  */\n\n  _setScenegraphNodeProps(props) {\n    if ('display' in props) {\n      this.display = props.display;\n    }\n\n    if ('position' in props) {\n      this.setPosition(props.position);\n    }\n    if ('rotation' in props) {\n      this.setRotation(props.rotation);\n    }\n    if ('scale' in props) {\n      this.setScale(props.scale);\n    }\n\n    // Matrix overwrites other props\n    if ('matrix' in props) {\n      this.setMatrix(props.matrix);\n    }\n\n    Object.assign(this.props, props);\n  }\n}\n","import GL from '@luma.gl/constants';\nimport {Buffer} from '@luma.gl/webgl';\nimport {assert} from '../utils';\n\n// Support for mapping new geometries with glTF attribute names to \"classic\" luma.gl shader names\nconst GLTF_TO_LUMA_ATTRIBUTE_MAP = {\n  POSITION: 'positions',\n  NORMAL: 'normals',\n  COLOR_0: 'colors',\n  TEXCOORD_0: 'texCoords',\n  TEXCOORD_1: 'texCoords1',\n  TEXCOORD_2: 'texCoords2'\n};\n\nexport function getBuffersFromGeometry(gl, geometry, options) {\n  const buffers = {};\n  let indices = geometry.indices;\n\n  for (const name in geometry.attributes) {\n    const attribute = geometry.attributes[name];\n    const remappedName = mapAttributeName(name, options);\n\n    if (name === 'indices') {\n      indices = attribute;\n    } else if (attribute.constant) {\n      buffers[remappedName] = attribute.value;\n    } else {\n      const typedArray = attribute.value;\n      // Create accessor by copying the attribute and removing `value``\n      const accessor = {...attribute};\n      delete accessor.value;\n      buffers[remappedName] = [new Buffer(gl, typedArray), accessor];\n\n      inferAttributeAccessor(name, accessor);\n    }\n  }\n\n  if (indices) {\n    const data = indices.value || indices;\n    assert(\n      data instanceof Uint16Array || data instanceof Uint32Array,\n      'attribute array for \"indices\" must be of integer type'\n    );\n    const accessor = {\n      size: 1,\n      isIndexed: indices.isIndexed === undefined ? true : indices.isIndexed\n    };\n    buffers.indices = [\n      new Buffer(gl, {\n        data,\n        target: GL.ELEMENT_ARRAY_BUFFER\n      }),\n      accessor\n    ];\n  }\n\n  return buffers;\n}\n\nfunction mapAttributeName(name, options) {\n  const {attributeMap = GLTF_TO_LUMA_ATTRIBUTE_MAP} = options || {};\n  return (attributeMap && attributeMap[name]) || name;\n}\n\n// Check for well known attribute names\n// eslint-disable-next-line complexity\nexport function inferAttributeAccessor(attributeName, attribute) {\n  let category;\n  switch (attributeName) {\n    case 'texCoords':\n    case 'texCoord1':\n    case 'texCoord2':\n    case 'texCoord3':\n      category = 'uvs';\n      break;\n    case 'vertices':\n    case 'positions':\n    case 'normals':\n    case 'pickingColors':\n      category = 'vectors';\n      break;\n    default:\n  }\n\n  // Check for categorys\n  switch (category) {\n    case 'vectors':\n      attribute.size = attribute.size || 3;\n      break;\n    case 'uvs':\n      attribute.size = attribute.size || 2;\n      break;\n    default:\n  }\n\n  assert(Number.isFinite(attribute.size), `attribute ${attributeName} needs size`);\n}\n","import {assembleShaders} from '@luma.gl/shadertools';\nimport {Program} from '@luma.gl/webgl';\n\nexport default class ProgramManager {\n  static getDefaultProgramManager(gl) {\n    gl.luma = gl.luma || {};\n    gl.luma.defaultProgramManager = gl.luma.defaultProgramManager || new ProgramManager(gl);\n\n    return gl.luma.defaultProgramManager;\n  }\n\n  constructor(gl) {\n    this.gl = gl;\n\n    this._programCache = {};\n    this._getUniforms = {};\n    this._registeredModules = {};\n    this._moduleInjections = {\n      vs: {},\n      fs: {}\n    };\n    this._hookFunctions = {\n      vs: {},\n      fs: {}\n    };\n    this._defaultModules = [];\n\n    this._hashes = {};\n    this._hashCounter = 0;\n    this.stateHash = 0; // Used change hashing if hooks are modified\n    this._useCounts = {};\n  }\n\n  addDefaultModule(module) {\n    if (!this._defaultModules.find(m => m.name === module.name)) {\n      this._defaultModules.push(module);\n    }\n\n    this.stateHash++;\n  }\n\n  removeDefaultModule(module) {\n    const moduleName = typeof module === 'string' ? module : module.name;\n    this._defaultModules = this._defaultModules.filter(m => m.name !== moduleName);\n    this.stateHash++;\n  }\n\n  addModuleInjection(module, opts) {\n    const moduleName = typeof module === 'string' ? module : module.name;\n    const {hook, injection, order = 0} = opts;\n    const shaderStage = hook.slice(0, 2);\n\n    const moduleInjections = this._moduleInjections[shaderStage];\n    moduleInjections[moduleName] = moduleInjections[moduleName] || {};\n\n    moduleInjections[moduleName][hook] = {\n      injection,\n      order\n    };\n\n    this.stateHash++;\n  }\n\n  addShaderHook(hook, opts = {}) {\n    hook = hook.trim();\n    const [stage, signature] = hook.split(':');\n    const name = hook.replace(/\\(.+/, '');\n    this._hookFunctions[stage][name] = Object.assign(opts, {signature});\n\n    this.stateHash++;\n  }\n\n  get(props = {}) {\n    const {vs = '', fs = '', defines = {}, inject = {}, varyings = [], bufferMode = 0x8c8d} = props; // varyings/bufferMode for xform feedback, 0x8c8d = SEPARATE_ATTRIBS\n\n    const modules = this._getModuleList(props.modules); // Combine with default modules\n\n    const vsHash = this._getHash(vs);\n    const fsHash = this._getHash(fs);\n    const moduleHashes = modules.map(m => this._getHash(typeof m === 'string' ? m : m.name)).sort();\n    const varyingHashes = varyings.map(v => this._getHash(v));\n\n    const defineKeys = Object.keys(defines).sort();\n    const injectKeys = Object.keys(inject).sort();\n    const defineHashes = [];\n    const injectHashes = [];\n\n    for (const key of defineKeys) {\n      defineHashes.push(this._getHash(key));\n      defineHashes.push(this._getHash(defines[key]));\n    }\n\n    for (const key of injectKeys) {\n      defineHashes.push(this._getHash(key));\n      defineHashes.push(this._getHash(inject[key]));\n    }\n\n    const hash = `${vsHash}/${fsHash}D${defineHashes.join('/')}M${moduleHashes.join(\n      '/'\n    )}I${injectHashes.join('/')}V${varyingHashes.join('/')}H${this.stateHash}B${bufferMode}`;\n\n    if (!this._programCache[hash]) {\n      const assembled = assembleShaders(this.gl, {\n        vs,\n        fs,\n        modules,\n        inject,\n        defines,\n        hookFunctions: this._hookFunctions,\n        moduleInjections: this._moduleInjections\n      });\n\n      this._programCache[hash] = new Program(this.gl, {\n        hash,\n        vs: assembled.vs,\n        fs: assembled.fs,\n        varyings,\n        bufferMode\n      });\n\n      this._getUniforms[hash] = assembled.getUniforms || (x => {});\n      this._useCounts[hash] = 0;\n    }\n\n    this._useCounts[hash]++;\n\n    return this._programCache[hash];\n  }\n\n  getUniforms(program) {\n    return this._getUniforms[program.hash] || null;\n  }\n\n  release(program) {\n    const hash = program.hash;\n    this._useCounts[hash]--;\n\n    if (this._useCounts[hash] === 0) {\n      this._programCache[hash].delete();\n      delete this._programCache[hash];\n      delete this._getUniforms[hash];\n      delete this._useCounts[hash];\n    }\n  }\n\n  _getHash(key) {\n    if (this._hashes[key] === undefined) {\n      this._hashes[key] = this._hashCounter++;\n    }\n\n    return this._hashes[key];\n  }\n\n  // Dedup and combine with default modules\n  _getModuleList(appModules = []) {\n    const modules = new Array(this._defaultModules.length + appModules.length);\n    const seen = {};\n    let count = 0;\n\n    for (let i = 0, len = this._defaultModules.length; i < len; ++i) {\n      const module = this._defaultModules[i];\n      const name = typeof module === 'string' ? module : module.name;\n      modules[count++] = module;\n      seen[name] = true;\n    }\n\n    for (let i = 0, len = appModules.length; i < len; ++i) {\n      const module = appModules[i];\n      const name = typeof module === 'string' ? module : module.name;\n      if (!seen[name]) {\n        modules[count++] = module;\n        seen[name] = true;\n      }\n    }\n\n    modules.length = count;\n\n    return modules;\n  }\n}\n","// TODO / DEPRECATED - delete when confident that probe.gl logging implements all opts\n/* eslint-disable no-console */\nfunction formatArrayValue(v, opts) {\n  const {maxElts = 16, size = 1} = opts;\n  let string = '[';\n  for (let i = 0; i < v.length && i < maxElts; ++i) {\n    if (i > 0) {\n      string += `,${i % size === 0 ? ' ' : ''}`;\n    }\n    string += formatValue(v[i], opts);\n  }\n  const terminator = v.length > maxElts ? '...' : ']';\n  return `${string}${terminator}`;\n}\n\nexport function formatValue(v, opts = {}) {\n  const EPSILON = 1e-16;\n  const {isInteger = false} = opts;\n  if (Array.isArray(v) || ArrayBuffer.isView(v)) {\n    return formatArrayValue(v, opts);\n  }\n  if (!Number.isFinite(v)) {\n    return String(v);\n  }\n  if (Math.abs(v) < EPSILON) {\n    return isInteger ? '0' : '0.';\n  }\n  if (isInteger) {\n    return v.toFixed(0);\n  }\n  if (Math.abs(v) > 100 && Math.abs(v) < 10000) {\n    return v.toFixed(0);\n  }\n  const string = v.toPrecision(2);\n  const decimal = string.indexOf('.0');\n  return decimal === string.length - 2 ? string.slice(0, -1) : string;\n}\n","import Buffer from '../classes/buffer';\nimport {getKey} from '../webgl-utils';\nimport {getCompositeGLType} from '../webgl-utils/attribute-utils';\nimport {formatValue} from '../utils';\n\n// Creates object suitable as input for console.table\nexport function getDebugTableForVertexArray({vertexArray, header = 'Attributes'} = {}) {\n  if (!vertexArray.configuration) {\n    return {};\n  }\n\n  const table = {}; // {[header]: {}};\n\n  // Add index (elements) if available\n  if (vertexArray.elements) {\n    // const elements = Object.assign({size: 1}, vertexArray.elements);\n    table.ELEMENT_ARRAY_BUFFER = getDebugTableRow(vertexArray, vertexArray.elements, null, header);\n  }\n\n  // Add used attributes\n  const attributes = vertexArray.values;\n\n  for (const attributeLocation in attributes) {\n    const info = vertexArray._getAttributeInfo(attributeLocation);\n    if (info) {\n      let rowHeader = `${attributeLocation}: ${info.name}`;\n      const accessor = vertexArray.accessors[info.location];\n      if (accessor) {\n        rowHeader = `${attributeLocation}: ${getGLSLDeclaration(info.name, accessor)}`;\n      }\n      table[rowHeader] = getDebugTableRow(\n        vertexArray,\n        attributes[attributeLocation],\n        accessor,\n        header\n      );\n    }\n  }\n\n  return table;\n}\n\n/* eslint-disable max-statements */\nfunction getDebugTableRow(vertexArray, attribute, accessor, header) {\n  const {gl} = vertexArray;\n\n  if (!attribute) {\n    return {\n      [header]: 'null',\n      'Format ': 'N/A'\n    };\n  }\n\n  let type = 'NOT PROVIDED';\n  let size = 'N/A';\n  let verts = 'N/A';\n  let bytes = 'N/A';\n\n  let isInteger;\n  let marker;\n  let value;\n\n  if (accessor) {\n    type = accessor.type;\n    size = accessor.size;\n\n    // Generate a type name by dropping Array from Float32Array etc.\n    type = String(type).replace('Array', '');\n\n    // Look for 'nt' to detect integer types, e.g. Int32Array, Uint32Array\n    isInteger = type.indexOf('nt') !== -1;\n  }\n\n  if (attribute instanceof Buffer) {\n    const buffer = attribute;\n\n    const {data, modified} = buffer.getDebugData();\n    marker = modified ? '*' : '';\n\n    value = data;\n    bytes = buffer.byteLength;\n    verts = bytes / data.BYTES_PER_ELEMENT / size;\n\n    let format;\n\n    if (accessor) {\n      const instanced = accessor.divisor > 0;\n      format = `${instanced ? 'I ' : 'P '} ${verts} (x${size}=${bytes} bytes ${getKey(gl, type)})`;\n    } else {\n      // element buffer\n      isInteger = true;\n      format = `${bytes} bytes`;\n    }\n\n    return {\n      [header]: `${marker}${formatValue(value, {size, isInteger})}`,\n      'Format ': format\n    };\n  }\n\n  // CONSTANT VALUE\n  value = attribute;\n  size = attribute.length;\n  // Generate a type name by dropping Array from Float32Array etc.\n  type = String(attribute.constructor.name).replace('Array', '');\n  // Look for 'nt' to detect integer types, e.g. Int32Array, Uint32Array\n  isInteger = type.indexOf('nt') !== -1;\n\n  return {\n    [header]: `${formatValue(value, {size, isInteger})} (constant)`,\n    'Format ': `${size}x${type} (constant)`\n  };\n}\n/* eslint-ensable max-statements */\n\nfunction getGLSLDeclaration(name, accessor) {\n  const {type, size} = accessor;\n  const typeAndName = getCompositeGLType(type, size);\n  return typeAndName ? `${name} (${typeAndName.name})` : name;\n}\n","import {formatValue, assert} from '../utils';\n\n// Prepares a table suitable for console.table\n/* eslint-disable max-statements, complexity */\nexport function getDebugTableForUniforms({\n  header = 'Uniforms',\n  program,\n  uniforms,\n  undefinedOnly = false\n} = {}) {\n  assert(program);\n\n  const SHADER_MODULE_UNIFORM_REGEXP = '.*_.*';\n  const PROJECT_MODULE_UNIFORM_REGEXP = '.*Matrix'; // TODO - Use explicit list\n\n  const uniformLocations = program._uniformSetters;\n  const table = {}; // {[header]: {}};\n\n  // Add program's provided uniforms (in alphabetical order)\n  const uniformNames = Object.keys(uniformLocations).sort();\n\n  let count = 0;\n\n  // First add non-underscored uniforms (assumed not coming from shader modules)\n  for (const uniformName of uniformNames) {\n    if (\n      !uniformName.match(SHADER_MODULE_UNIFORM_REGEXP) &&\n      !uniformName.match(PROJECT_MODULE_UNIFORM_REGEXP)\n    ) {\n      if (addUniformToTable({table, header, uniforms, uniformName, undefinedOnly})) {\n        count++;\n      }\n    }\n  }\n\n  // add underscored uniforms (assumed from shader modules)\n  for (const uniformName of uniformNames) {\n    if (uniformName.match(PROJECT_MODULE_UNIFORM_REGEXP)) {\n      if (addUniformToTable({table, header, uniforms, uniformName, undefinedOnly})) {\n        count++;\n      }\n    }\n  }\n\n  for (const uniformName of uniformNames) {\n    if (!table[uniformName]) {\n      if (addUniformToTable({table, header, uniforms, uniformName, undefinedOnly})) {\n        count++;\n      }\n    }\n  }\n\n  // Create a table of unused uniforms\n  let unusedCount = 0;\n  const unusedTable = {};\n  if (!undefinedOnly) {\n    for (const uniformName in uniforms) {\n      const uniform = uniforms[uniformName];\n      if (!table[uniformName]) {\n        unusedCount++;\n        unusedTable[uniformName] = {\n          Type: `NOT USED: ${uniform}`,\n          [header]: formatValue(uniform)\n        };\n      }\n    }\n  }\n\n  return {table, count, unusedTable, unusedCount};\n}\n\n// Helper\nfunction addUniformToTable({table, header, uniforms, uniformName, undefinedOnly}) {\n  const value = uniforms[uniformName];\n  const isDefined = isUniformDefined(value);\n  if (!undefinedOnly || !isDefined) {\n    table[uniformName] = {\n      // Add program's unprovided uniforms\n      [header]: isDefined ? formatValue(value) : 'N/A',\n      'Uniform Type': isDefined ? value : 'NOT PROVIDED'\n    };\n    return true;\n  }\n  return false;\n}\n\nfunction isUniformDefined(value) {\n  return value !== undefined && value !== null;\n}\n","import {getCompositeGLType} from '../webgl-utils/attribute-utils';\n\nexport function getDebugTableForProgramConfiguration(config) {\n  const table = {};\n\n  const header = `Accessors for ${config.id}`;\n\n  for (const attributeInfo of config.attributeInfos) {\n    if (attributeInfo) {\n      const glslDeclaration = getGLSLDeclaration(attributeInfo);\n      table[`in ${glslDeclaration}`] = {[header]: JSON.stringify(attributeInfo.accessor)};\n    }\n  }\n\n  for (const varyingInfo of config.varyingInfos) {\n    if (varyingInfo) {\n      const glslDeclaration = getGLSLDeclaration(varyingInfo);\n      table[`out ${glslDeclaration}`] = {[header]: JSON.stringify(varyingInfo.accessor)};\n    }\n  }\n\n  return table;\n}\n\nfunction getGLSLDeclaration(attributeInfo) {\n  const {type, size} = attributeInfo.accessor;\n  const typeAndName = getCompositeGLType(type, size);\n  if (typeAndName) {\n    return `${typeAndName.name} ${attributeInfo.name}`;\n  }\n  return attributeInfo.name;\n}\n","import seer from 'seer';\n\nimport {window} from '../utils';\n\nconst models = {};\n\n/**\n * Add a model to our cache indexed by id\n */\nexport const addModel = model => {\n  if (models[model.id]) {\n    return;\n  }\n  models[model.id] = model;\n\n  seer.listItem('luma.gl', model.id);\n};\n\n/**\n * Log a model uniforms and attributes.\n */\nexport const logModel = (model, uniforms) => {\n  if (!seer.isReady() || seer.throttle(`luma.gl:${model.id}`, 1e3)) {\n    return;\n  }\n\n  const attributesObject = model.geometry\n    ? Object.assign({}, model.geometry.attributes, model.attributes)\n    : model.attributes;\n  const uniformsObject = Object.assign({}, model.uniforms, uniforms);\n\n  seer.multiUpdate('luma.gl', model.id, [\n    {path: 'objects.uniforms', data: uniformsObject},\n    {path: 'objects.attributes', data: attributesObject}\n  ]);\n};\n\n/**\n * Remove a previously set model from the cache\n */\nexport const removeModel = id => {\n  delete models[id];\n  seer.deleteItem('luma.gl', id);\n};\n\n/**\n * Recursively traverse an object given a path of properties and set the given value\n */\nconst recursiveSet = (obj, path, value) => {\n  if (!obj) {\n    return;\n  }\n\n  if (path.length > 1) {\n    recursiveSet(obj[path[0]], path.slice(1), value);\n  } else {\n    obj[path[0]] = value;\n  }\n};\n\nconst overrides = new Map();\n\n/**\n * Create an override on the specify layer, indexed by a valuePath array.\n * Do nothing in case Seer as not been initialized to prevent any preformance drawback.\n */\nexport const setOverride = (id, valuePath, value) => {\n  if (!window.__SEER_INITIALIZED__) {\n    return;\n  }\n\n  if (!overrides.has(id)) {\n    overrides.set(id, new Map());\n  }\n\n  const uniforms = overrides.get(id);\n  uniforms.set(valuePath, value);\n};\n\n/**\n * Apply overrides to a specific model's uniforms\n */\nexport const getOverrides = (id, uniforms) => {\n  if (!window.__SEER_INITIALIZED__ || !id) {\n    return;\n  }\n\n  const overs = overrides.get(id);\n  if (!overs) {\n    return;\n  }\n\n  overs.forEach((value, valuePath) => {\n    recursiveSet(uniforms, valuePath, value);\n  });\n};\n\n/**\n * Listen for luma.gl edit events\n */\nseer.listenFor('luma.gl', payload => {\n  const model = models[payload.itemKey];\n  if (!model || payload.type !== 'edit' || payload.valuePath[0] !== 'uniforms') {\n    return;\n  }\n\n  const valuePath = payload.valuePath.slice(1);\n  setOverride(payload.itemKey, valuePath, payload.value);\n\n  const uniforms = model.getUniforms();\n  recursiveSet(uniforms, valuePath, payload.value);\n  model.setUniforms(uniforms);\n});\n","/* eslint-disable complexity */\n// Shared code between Model and MeshModel\nimport ProgramManager from '../resource-management/program-manager';\nimport {isWebGL, Query, Program, VertexArray, clear} from '@luma.gl/webgl';\nimport {MODULAR_SHADERS} from '@luma.gl/shadertools';\nimport {\n  getDebugTableForUniforms,\n  getDebugTableForVertexArray,\n  getDebugTableForProgramConfiguration\n} from '@luma.gl/webgl';\nimport {addModel, removeModel, logModel, getOverrides} from '../debug/seer-integration';\nimport {log, isObjectEmpty, uid, assert} from '../utils';\n\nconst LOG_DRAW_PRIORITY = 2;\nconst LOG_DRAW_TIMEOUT = 10000;\n\n// Model abstract O3D Class\nexport default class BaseModel {\n  constructor(gl, props = {}) {\n    assert(isWebGL(gl));\n    const {id = uid('base-model')} = props;\n    this.id = id;\n    this.gl = gl;\n    this.id = props.id || uid('Model');\n    this.lastLogTime = 0; // TODO - move to probe.gl\n    this.initialize(props);\n  }\n\n  initialize(props) {\n    this.props = {};\n\n    if (props.shaderCache) {\n      log.warn('ShaderCache property is deprecated')();\n    }\n\n    this.programManager = props.programManager || ProgramManager.getDefaultProgramManager(this.gl);\n    this._programManagerState = -1;\n    this._managedProgram = false;\n\n    const {program = null, vs, fs, modules, defines, inject, varyings, bufferMode} = props;\n\n    this.programProps = {program, vs, fs, modules, defines, inject, varyings, bufferMode};\n    this.program = null;\n    this.vertexArray = null;\n    this._programDirty = true;\n\n    // Initialize state\n    this.userData = {};\n    this.needsRedraw = true;\n\n    // Attributes and buffers\n    // Model manages auto Buffer creation from typed arrays\n    this._attributes = {}; // All attributes\n    this.attributes = {}; // User defined attributes\n\n    // Model manages uniform animation\n    this.uniforms = {};\n    this.animatedUniforms = {};\n    this.animated = false;\n    this.animationLoop = null; // if set, used as source for animationProps\n\n    this.timerQueryEnabled = false;\n    this.timeElapsedQuery = undefined;\n    this.lastQueryReturned = true;\n\n    this.stats = {\n      accumulatedFrameTime: 0,\n      averageFrameTime: 0,\n      profileFrameCount: 0\n    };\n\n    // picking options\n    this.pickable = true;\n\n    this._checkProgram();\n\n    this._setBaseModelProps(props);\n\n    this.setUniforms(\n      Object.assign(\n        {},\n        this.getModuleUniforms(props.moduleSettings) // Get unforms for supplied parameters\n      )\n    );\n  }\n\n  setProps(props) {\n    this._setBaseModelProps(props);\n  }\n\n  delete() {\n    // delete all attributes created by this model\n    // TODO - should buffer deletes be handled by vertex array?\n    for (const key in this._attributes) {\n      if (this._attributes[key] !== this.attributes[key]) {\n        this._attributes[key].delete();\n      }\n    }\n\n    if (this._managedProgram) {\n      this.programManager.release(this.program);\n    }\n\n    this.vertexArray.delete();\n\n    removeModel(this.id);\n  }\n\n  // GETTERS\n\n  isAnimated() {\n    return this.animated;\n  }\n\n  getProgram() {\n    return this.program;\n  }\n\n  setProgram(props) {\n    this.programProps = Object.assign({}, props);\n    this._programDirty = true;\n  }\n\n  getUniforms() {\n    return this.uniforms;\n  }\n\n  // SETTERS\n\n  // TODO - should actually set the uniforms\n  setUniforms(uniforms = {}) {\n    // Let Seer override edited uniforms\n    uniforms = Object.assign({}, uniforms);\n    getOverrides(this.id, uniforms);\n\n    // Resolve any animated uniforms so that we have an initial value\n    uniforms = this._extractAnimatedUniforms(uniforms);\n\n    Object.assign(this.uniforms, uniforms);\n\n    return this;\n  }\n\n  getModuleUniforms(opts) {\n    this._checkProgram();\n\n    const getUniforms = this.programManager.getUniforms(this.program);\n\n    if (getUniforms) {\n      return getUniforms(opts);\n    }\n\n    return {};\n  }\n\n  updateModuleSettings(opts) {\n    const uniforms = this.getModuleUniforms(opts || {});\n    return this.setUniforms(uniforms);\n  }\n\n  // DRAW CALLS\n\n  clear(opts) {\n    clear(this.program.gl, opts);\n    return this;\n  }\n\n  /* eslint-disable max-statements  */\n  drawGeometry(opts = {}) {\n    // Lazy update program and vertex array\n    this._checkProgram();\n\n    const {\n      moduleSettings = null,\n      framebuffer,\n      uniforms = {},\n      attributes = {},\n      transformFeedback = this.transformFeedback,\n      parameters = {},\n      vertexArray = this.vertexArray,\n      animationProps\n    } = opts;\n\n    addModel(this);\n\n    // Update model with any just provided attributes, settings or uniforms\n    this.setAttributes(attributes);\n    this.updateModuleSettings(moduleSettings);\n    this.setUniforms(uniforms);\n\n    // Animate any function valued uniforms\n    this._refreshAnimationProps(animationProps);\n\n    const logPriority = this._logDrawCallStart(2);\n\n    const drawParams = this.vertexArray.getDrawParams(this.props);\n    if (drawParams.isInstanced && !this.isInstanced) {\n      log.warn('Found instanced attributes on non-instanced model', this.id)();\n    }\n\n    const {isIndexed, indexType, indexOffset} = drawParams;\n    const {isInstanced, instanceCount} = this;\n\n    const noop = () => {};\n    const {onBeforeRender = noop, onAfterRender = noop} = this.props;\n\n    onBeforeRender();\n\n    this._timerQueryStart();\n\n    this.program.setUniforms(this.uniforms);\n\n    const didDraw = this.program.draw(\n      Object.assign({}, opts, {\n        logPriority,\n        uniforms: null, // Already set (may contain \"function values\" not understood by Program)\n        framebuffer,\n        parameters,\n        drawMode: this.getDrawMode(),\n        vertexCount: this.getVertexCount(),\n        vertexArray,\n        transformFeedback,\n        isIndexed,\n        indexType,\n        isInstanced,\n        instanceCount,\n        offset: isIndexed ? indexOffset : 0\n      })\n    );\n\n    this._timerQueryEnd();\n\n    onAfterRender();\n\n    this._logDrawCallEnd(logPriority, vertexArray, framebuffer);\n\n    return didDraw;\n  }\n  /* eslint-enable max-statements  */\n\n  // PRIVATE METHODS\n\n  // eslint-disable-next-line max-statements, complexity\n  _setBaseModelProps(props) {\n    Object.assign(this.props, props);\n\n    if ('uniforms' in props) {\n      this.setUniforms(props.uniforms);\n    }\n\n    if ('pickable' in props) {\n      this.pickable = props.pickable;\n    }\n\n    // if ('onBeforeRender' in props) {}\n    // if ('onAfterRender' in props) {}\n\n    // Experimental props\n    if ('timerQueryEnabled' in props) {\n      this.timerQueryEnabled = props.timerQueryEnabled && Query.isSupported(this.gl, ['timers']);\n      if (props.timerQueryEnabled && !this.timerQueryEnabled) {\n        log.warn('GPU timer not supported')();\n      }\n    }\n\n    if ('_animationProps' in props) {\n      this._setAnimationProps(props._animationProps);\n    }\n\n    if ('_animationLoop' in props) {\n      this.animationLoop = props._animationLoop;\n    }\n  }\n\n  _checkProgram(shaderCache = null) {\n    const needsUpdate =\n      this._programDirty || this.programManager.stateHash !== this._programManagerState;\n\n    if (!needsUpdate) {\n      return;\n    }\n\n    let {program} = this.programProps;\n\n    if (program) {\n      this._managedProgram = false;\n    } else {\n      const {\n        // TODO(Tarek): Are these actually used anywhere?\n        vs = MODULAR_SHADERS.vs,\n        fs = MODULAR_SHADERS.fs,\n        modules,\n        inject,\n        defines,\n        varyings,\n        bufferMode\n      } = this.programProps;\n      program = this.programManager.get({vs, fs, modules, inject, defines, varyings, bufferMode});\n      if (this.program && this._managedProgram) {\n        this.programManager.release(this.program);\n      }\n      this._programManagerState = this.programManager.stateHash;\n      this._managedProgram = true;\n    }\n\n    assert(program instanceof Program, 'Model needs a program');\n\n    this._programDirty = false;\n\n    if (program === this.program) {\n      return;\n    }\n\n    this.program = program;\n\n    if (this.vertexArray) {\n      this.vertexArray.setProps({program: this.program, attributes: this.vertexArray.attributes});\n    } else {\n      this.vertexArray = new VertexArray(this.gl, {program: this.program});\n    }\n\n    // Make sure we have some reasonable default uniforms in place\n    this.setUniforms(\n      Object.assign(\n        {},\n        this.getModuleUniforms() // Get all default uniforms,\n      )\n    );\n  }\n\n  // Refreshes animated uniforms, attempting to get animated props from animationLoop if registered\n  _refreshAnimationProps(animationProps) {\n    // Try to read animationProps\n    animationProps = animationProps || (this.animationLoop && this.animationLoop.animationProps);\n    if (animationProps) {\n      this._setAnimationProps(animationProps);\n    }\n  }\n\n  // Calculate new values for any function uniforms based on supplied animationProps\n  _evaluateAnimateUniforms(animationProps) {\n    if (!this.animated) {\n      return {};\n    }\n    const animatedUniforms = {};\n    for (const uniformName in this.animatedUniforms) {\n      const valueFunction = this.animatedUniforms[uniformName];\n      animatedUniforms[uniformName] = valueFunction(animationProps);\n    }\n    return animatedUniforms;\n  }\n\n  // Extracts a list of function valued uniforms, so we can update them before each draw call\n  // Also removes such uniforms from the returned list\n  _extractAnimatedUniforms(uniforms) {\n    let foundAnimated = false;\n\n    // Keep our animatedUniforms map up-to-date\n    for (const uniformName in uniforms) {\n      const newValue = uniforms[uniformName];\n      if (typeof newValue === 'function') {\n        this.animatedUniforms[uniformName] = newValue;\n        foundAnimated = true;\n      } else {\n        delete this.animatedUniforms[uniformName];\n      }\n    }\n\n    // Update animated flag: `Model` is animated if any uniforms are animated (i.e. functions)\n    this.animated = !isObjectEmpty(this.animatedUniforms);\n\n    if (!foundAnimated) {\n      return uniforms;\n    }\n\n    // If animated uniforms were found, remove them from ordinary uniform list\n    // `Program` class can't (and shouldn't) handle function valued uniforms\n    const staticUniforms = {};\n    for (const uniformName in uniforms) {\n      if (!this.animatedUniforms[uniformName]) {\n        staticUniforms[uniformName] = uniforms[uniformName];\n      }\n    }\n    return staticUniforms;\n  }\n\n  // Timer Queries\n\n  _timerQueryStart() {\n    if (this.timerQueryEnabled === true) {\n      if (!this.timeElapsedQuery) {\n        this.timeElapsedQuery = new Query(this.gl);\n      }\n      if (this.lastQueryReturned) {\n        this.lastQueryReturned = false;\n        this.timeElapsedQuery.beginTimeElapsedQuery();\n      }\n    }\n  }\n\n  _timerQueryEnd() {\n    if (this.timerQueryEnabled === true) {\n      this.timeElapsedQuery.end();\n      // TODO: Skip results if 'gl.getParameter(this.ext.GPU_DISJOINT_EXT)' returns false\n      // should this be incorporated into Query object?\n      if (this.timeElapsedQuery.isResultAvailable()) {\n        this.lastQueryReturned = true;\n        const elapsedTime = this.timeElapsedQuery.getTimerMilliseconds();\n\n        // Update stats (e.g. for seer)\n        this.stats.lastFrameTime = elapsedTime;\n        this.stats.accumulatedFrameTime += elapsedTime;\n        this.stats.profileFrameCount++;\n        this.stats.averageFrameTime =\n          this.stats.accumulatedFrameTime / this.stats.profileFrameCount;\n\n        // Log stats\n        log.log(\n          LOG_DRAW_PRIORITY,\n          `\\\nGPU time ${this.program.id}: ${this.stats.lastFrameTime}ms \\\naverage ${this.stats.averageFrameTime}ms \\\naccumulated: ${this.stats.accumulatedFrameTime}ms \\\ncount: ${this.stats.profileFrameCount}`\n        )();\n      }\n    }\n  }\n\n  _logDrawCallStart(priority) {\n    const logDrawTimeout = priority > 3 ? 0 : LOG_DRAW_TIMEOUT;\n    if (log.priority < priority || Date.now() - this.lastLogTime < logDrawTimeout) {\n      return undefined;\n    }\n\n    this.lastLogTime = Date.now();\n\n    log.group(LOG_DRAW_PRIORITY, `>>> DRAWING MODEL ${this.id}`, {collapsed: log.priority <= 2})();\n\n    return priority;\n  }\n\n  _logDrawCallEnd(priority, vertexArray, uniforms, framebuffer) {\n    // HACK: priority === undefined means logDrawCallStart didn't run\n    if (priority === undefined) {\n      return;\n    }\n\n    const attributeTable = getDebugTableForVertexArray({\n      vertexArray,\n      header: `${this.id} attributes`,\n      attributes: this._attributes\n    });\n\n    const {table: uniformTable, unusedTable, unusedCount} = getDebugTableForUniforms({\n      header: `${this.id} uniforms`,\n      program: this.program,\n      uniforms: Object.assign({}, this.program.uniforms, uniforms)\n    });\n\n    // log missing uniforms\n    const {table: missingTable, count: missingCount} = getDebugTableForUniforms({\n      header: `${this.id} uniforms`,\n      program: this.program,\n      uniforms: Object.assign({}, this.program.uniforms, uniforms),\n      undefinedOnly: true\n    });\n\n    if (missingCount > 0) {\n      log.log('MISSING UNIFORMS', Object.keys(missingTable))();\n      // log.table(priority, missingTable)();\n    }\n    if (unusedCount > 0) {\n      log.log('UNUSED UNIFORMS', Object.keys(unusedTable))();\n      // log.log(priority, 'Unused uniforms ', unusedTable)();\n    }\n\n    const configTable = getDebugTableForProgramConfiguration(this.vertexArray.configuration);\n\n    log.table(priority, attributeTable)();\n\n    log.table(priority, uniformTable)();\n\n    log.table(priority + 1, configTable)();\n\n    logModel(this, uniforms);\n\n    if (framebuffer) {\n      framebuffer.log({priority: LOG_DRAW_PRIORITY, message: `Rendered to ${framebuffer.id}`});\n    }\n\n    log.groupEnd(LOG_DRAW_PRIORITY, `>>> DRAWING MODEL ${this.id}`)();\n  }\n}\n","import GL from '@luma.gl/constants';\nimport {TransformFeedback, Buffer} from '@luma.gl/webgl';\nimport {getBuffersFromGeometry} from './model-utils';\nimport BaseModel from './base-model';\nimport {log, isObjectEmpty, uid, assert} from '../utils';\n\nconst ERR_MODEL_PARAMS = 'Model needs drawMode and vertexCount';\n\nexport default class Model extends BaseModel {\n  constructor(gl, props = {}) {\n    // Deduce a helpful id\n    const {id = uid('model')} = props;\n    super(gl, {...props, id});\n  }\n\n  initialize(props) {\n    super.initialize(props);\n\n    this.drawMode = props.drawMode !== undefined ? props.drawMode : GL.TRIANGLES;\n    this.vertexCount = props.vertexCount || 0;\n\n    // Track buffers created by setGeometry\n    this.geometryBuffers = {};\n\n    // geometry might have set drawMode and vertexCount\n    this.isInstanced = props.isInstanced || props.instanced;\n\n    this._setModelProps(props);\n\n    // TODO - just to unbreak deck.gl 7.0-beta, remove as soon as updated\n    this.geometry = {};\n\n    // assert(program || program instanceof Program);\n    assert(this.drawMode !== undefined && Number.isFinite(this.vertexCount), ERR_MODEL_PARAMS);\n  }\n\n  setProps(props) {\n    super.setProps(props);\n    this._setModelProps(props);\n  }\n\n  delete() {\n    super.delete();\n\n    this._deleteGeometryBuffers();\n  }\n\n  // GETTERS\n\n  getDrawMode() {\n    return this.drawMode;\n  }\n\n  getVertexCount() {\n    return this.vertexCount;\n  }\n\n  getInstanceCount() {\n    return this.instanceCount;\n  }\n\n  getAttributes() {\n    return this.attributes;\n  }\n\n  // SETTERS\n\n  setDrawMode(drawMode) {\n    this.drawMode = drawMode;\n    return this;\n  }\n\n  setVertexCount(vertexCount) {\n    assert(Number.isFinite(vertexCount));\n    this.vertexCount = vertexCount;\n    return this;\n  }\n\n  setInstanceCount(instanceCount) {\n    assert(Number.isFinite(instanceCount));\n    this.instanceCount = instanceCount;\n    return this;\n  }\n\n  setGeometry(geometry) {\n    this.drawMode = geometry.drawMode;\n    this.vertexCount = geometry.getVertexCount();\n\n    this._deleteGeometryBuffers();\n\n    this.geometryBuffers = getBuffersFromGeometry(this.gl, geometry);\n    this.vertexArray.setAttributes(this.geometryBuffers);\n    return this;\n  }\n\n  setAttributes(attributes = {}) {\n    // Avoid setting needsRedraw if no attributes\n    if (isObjectEmpty(attributes)) {\n      return this;\n    }\n\n    const normalizedAttributes = {};\n    for (const name in attributes) {\n      const attribute = attributes[name];\n      // The `getValue` call provides support for deck.gl `Attribute` class\n      // TODO - remove once deck refactoring completes\n      normalizedAttributes[name] = attribute.getValue ? attribute.getValue() : attribute;\n    }\n\n    this.vertexArray.setAttributes(normalizedAttributes);\n    return this;\n  }\n\n  // DRAW CALLS\n\n  draw(options = {}) {\n    return this.drawGeometry(options);\n  }\n\n  // Draw call for transform feedback\n  transform(opts = {}) {\n    const {discard = true, feedbackBuffers, unbindModels = []} = opts;\n\n    let {parameters} = opts;\n\n    if (feedbackBuffers) {\n      this._setFeedbackBuffers(feedbackBuffers);\n    }\n\n    if (discard) {\n      parameters = Object.assign({}, parameters, {[GL.RASTERIZER_DISCARD]: discard});\n    }\n\n    unbindModels.forEach(model => model.vertexArray.unbindBuffers());\n    try {\n      this.draw(Object.assign({}, opts, {parameters}));\n    } finally {\n      unbindModels.forEach(model => model.vertexArray.bindBuffers());\n    }\n\n    return this;\n  }\n\n  // DEPRECATED METHODS\n\n  render(uniforms = {}) {\n    log.warn('Model.render() is deprecated. Use Model.setUniforms() and Model.draw()')();\n    return this.setUniforms(uniforms).draw();\n  }\n\n  // PRIVATE METHODS\n\n  _setModelProps(props) {\n    // params\n    // if ('drawMode' in props) {\n    //   this.drawMode = getDrawMode(props.drawMode);\n    // }\n    // if ('vertexCount' in props) {\n    //   this.vertexCount = props.vertexCount;\n    // }\n    if ('instanceCount' in props) {\n      this.instanceCount = props.instanceCount;\n    }\n    if ('geometry' in props) {\n      this.setGeometry(props.geometry);\n    }\n\n    // webgl settings\n    if ('attributes' in props) {\n      this.setAttributes(props.attributes);\n    }\n    if ('_feedbackBuffers' in props) {\n      this._setFeedbackBuffers(props._feedbackBuffers);\n    }\n  }\n\n  _deleteGeometryBuffers() {\n    for (const name in this.geometryBuffers) {\n      // Buffer is raw value (for indices) or first element of [buffer, accessor] pair\n      const buffer = this.geometryBuffers[name][0] || this.geometryBuffers[name];\n      if (buffer instanceof Buffer) {\n        buffer.delete();\n      }\n    }\n  }\n\n  // Updates (evaluates) all function valued uniforms based on a new set of animationProps\n  // experimental\n  _setAnimationProps(animationProps) {\n    if (this.animated) {\n      assert(animationProps, 'Model.draw(): animated uniforms but no animationProps');\n      const animatedUniforms = this._evaluateAnimateUniforms(animationProps);\n      Object.assign(this.uniforms, animatedUniforms);\n    }\n  }\n\n  // Transform Feedback\n\n  _setFeedbackBuffers(feedbackBuffers = {}) {\n    // Avoid setting needsRedraw if no feedbackBuffers\n    if (isObjectEmpty(feedbackBuffers)) {\n      return this;\n    }\n\n    const {gl} = this.program;\n    this.transformFeedback =\n      this.transformFeedback ||\n      new TransformFeedback(gl, {\n        program: this.program\n      });\n\n    this.transformFeedback.setBuffers(feedbackBuffers);\n    return this;\n  }\n}\n","// Transpiles shader source code to target GLSL version\n// Note: We always run transpiler even if same version e.g. 3.00 => 3.00\n// RFC: https://github.com/uber/luma.gl/blob/7.0-release/dev-docs/RFCs/v6.0/portable-glsl-300-rfc.md\nexport default function transpileShader(source, targetGLSLVersion, isVertex) {\n  switch (targetGLSLVersion) {\n    case 300:\n      return isVertex ? convertVertexShaderTo300(source) : convertFragmentShaderTo300(source);\n    case 100:\n      return isVertex ? convertVertexShaderTo100(source) : convertFragmentShaderTo100(source);\n    default:\n      throw new Error(`unknown GLSL version ${targetGLSLVersion}`);\n  }\n}\n\nfunction convertVertexShaderTo300(source) {\n  return source\n    .replace(/attribute\\s+/g, 'in ')\n    .replace(/varying\\s+/g, 'out ')\n    .replace(/texture2D\\(/g, 'texture(')\n    .replace(/textureCube\\(+/g, 'texture(')\n    .replace(/texture2DLodEXT\\(/g, 'textureLod(')\n    .replace(/textureCubeLodEXT\\(/g, 'textureLod(');\n}\n\nfunction convertFragmentShaderTo300(source) {\n  return source\n    .replace(/varying\\s+/g, 'in ')\n    .replace(/texture2D\\(/g, 'texture(')\n    .replace(/textureCube\\(/g, 'texture(')\n    .replace(/texture2DLodEXT\\(/g, 'textureLod(')\n    .replace(/textureCubeLodEXT\\(/g, 'textureLod(');\n\n  // Deal with fragColor\n  // .replace(/gl_fragColor/g, 'fragColor ');\n}\n\nfunction convertVertexShaderTo100(source) {\n  // /gm - treats each line as a string, so that ^ matches after newlines\n  return source\n    .replace(/^in\\s+/gm, 'attribute ')\n    .replace(/^out\\s+/gm, 'varying ')\n    .replace(/texture\\(/g, 'texture2D(');\n}\n\nfunction convertFragmentShaderTo100(source) {\n  // /gm - treats each line as a string, so that ^ matches after newlines\n  return source.replace(/^in\\s+/gm, 'varying ').replace(/texture\\(/g, 'texture2D(');\n\n  // Deal with fragColor\n  // .replace(/^out\\s+/g, 'varying ')\n}\n","const TYPE_DEFINITIONS = {\n  number: {\n    validate(value, propType) {\n      return (\n        Number.isFinite(value) &&\n        (!('max' in propType) || value <= propType.max) &&\n        (!('min' in propType) || value >= propType.min)\n      );\n    }\n  },\n  array: {\n    validate(value, propType) {\n      return Array.isArray(value) || ArrayBuffer.isView(value);\n    }\n  }\n};\n\nexport function parsePropTypes(propDefs) {\n  const propTypes = {};\n  for (const propName in propDefs) {\n    const propDef = propDefs[propName];\n    const propType = parsePropType(propDef);\n    propTypes[propName] = propType;\n  }\n  return propTypes;\n}\n\n// Parses one property definition entry. Either contains:\n// * a valid prop type object ({type, ...})\n// * or just a default value, in which case type and name inference is used\nfunction parsePropType(propDef) {\n  let type = getTypeOf(propDef);\n  if (type === 'object') {\n    if (!propDef) {\n      return {type: 'object', value: null};\n    }\n    if ('type' in propDef) {\n      return Object.assign({}, propDef, TYPE_DEFINITIONS[propDef.type]);\n    }\n    if (!('value' in propDef)) {\n      // If no type and value this object is likely the value\n      return {type: 'object', value: propDef};\n    }\n    type = getTypeOf(propDef.value);\n    return Object.assign({type}, propDef, TYPE_DEFINITIONS[type]);\n  }\n  return Object.assign({type, value: propDef}, TYPE_DEFINITIONS[type]);\n}\n\n// improved version of javascript typeof that can distinguish arrays and null values\nfunction getTypeOf(value) {\n  if (Array.isArray(value) || ArrayBuffer.isView(value)) {\n    return 'array';\n  }\n  return typeof value;\n}\n","import transpileShader from './transpile-shader';\nimport {assert} from '../utils';\nimport {parsePropTypes} from './filters/prop-types';\n\nconst VERTEX_SHADER = 'vs';\nconst FRAGMENT_SHADER = 'fs';\n\nexport default class ShaderModule {\n  constructor({\n    name,\n    vs,\n    fs,\n    dependencies = [],\n    uniforms,\n    getUniforms,\n    deprecations = [],\n    defines = {},\n    // DEPRECATED\n    vertexShader,\n    fragmentShader\n  }) {\n    assert(typeof name === 'string');\n    this.name = name;\n    this.vs = vs || vertexShader;\n    this.fs = fs || fragmentShader;\n    this.getModuleUniforms = getUniforms;\n    this.dependencies = dependencies;\n    this.deprecations = this._parseDeprecationDefinitions(deprecations);\n    this.defines = defines;\n\n    if (uniforms) {\n      this.uniforms = parsePropTypes(uniforms);\n    }\n  }\n\n  // Extracts the source code chunk for the specified shader type from the named shader module\n  getModuleSource(type, targetGLSLVersion) {\n    let moduleSource;\n    switch (type) {\n      case VERTEX_SHADER:\n        moduleSource = transpileShader(this.vs || '', targetGLSLVersion, true);\n        break;\n      case FRAGMENT_SHADER:\n        moduleSource = transpileShader(this.fs || '', targetGLSLVersion, false);\n        break;\n      default:\n        assert(false);\n    }\n\n    return `\\\n#define MODULE_${this.name.toUpperCase()}\n${moduleSource}\\\n// END MODULE_${this.name}\n\n`;\n  }\n\n  getUniforms(opts, uniforms) {\n    if (this.getModuleUniforms) {\n      return this.getModuleUniforms(opts, uniforms);\n    }\n    // Build uniforms from the uniforms array\n    if (this.uniforms) {\n      return this._defaultGetUniforms(opts);\n    }\n    return {};\n  }\n\n  getDefines() {\n    return this.defines;\n  }\n\n  // Warn about deprecated uniforms or functions\n  checkDeprecations(shaderSource, log) {\n    this.deprecations.forEach(def => {\n      if (def.regex.test(shaderSource)) {\n        if (def.deprecated) {\n          log.deprecated(def.old, def.new)();\n        } else {\n          log.removed(def.old, def.new)();\n        }\n      }\n    });\n  }\n\n  _parseDeprecationDefinitions(deprecations) {\n    deprecations.forEach(def => {\n      switch (def.type) {\n        case 'function':\n          def.regex = new RegExp(`\\\\b${def.old}\\\\(`);\n          break;\n        default:\n          def.regex = new RegExp(`${def.type} ${def.old};`);\n      }\n    });\n\n    return deprecations;\n  }\n\n  _defaultGetUniforms(opts = {}) {\n    const uniforms = {};\n    const propTypes = this.uniforms;\n\n    for (const key in propTypes) {\n      const propDef = propTypes[key];\n      if (key in opts && !propDef.private) {\n        if (propDef.validate) {\n          assert(propDef.validate(opts[key], propDef), `${this.name}: invalid ${key}`);\n        }\n        uniforms[key] = opts[key];\n      } else {\n        uniforms[key] = propDef.value;\n      }\n    }\n\n    return uniforms;\n  }\n}\n\n// This utility mutates the original module\n// Keeping for backward compatibility\n// TODO - remove in v8\nexport function normalizeShaderModule(module) {\n  if (!module.normalized) {\n    module.normalized = true;\n    if (module.uniforms && !module.getUniforms) {\n      const shaderModule = new ShaderModule(module);\n      module.getUniforms = shaderModule.getUniforms.bind(shaderModule);\n    }\n  }\n  return module;\n}\n","import {MODULE_INJECTORS_VS, MODULE_INJECTORS_FS} from '../modules/module-injectors';\nimport {VERTEX_SHADER, FRAGMENT_SHADER} from './constants';\nimport {assert} from '../utils';\n\n// TODO - experimental\nconst MODULE_INJECTORS = {\n  [VERTEX_SHADER]: MODULE_INJECTORS_VS,\n  [FRAGMENT_SHADER]: MODULE_INJECTORS_FS\n};\n\nexport const DECLARATION_INJECT_MARKER = '__LUMA_INJECT_DECLARATIONS__'; // Uniform/attribute declarations\n\nconst REGEX_START_OF_MAIN = /void main\\s*\\([^)]*\\)\\s*\\{\\n?/; // Beginning of main\nconst REGEX_END_OF_MAIN = /}\\n?[^{}]*$/; // End of main, assumes main is last function\nconst fragments = [];\n\n// A minimal shader injection/templating system.\n// RFC: https://github.com/uber/luma.gl/blob/7.0-release/dev-docs/RFCs/v6.0/shader-injection-rfc.md\n/* eslint-disable complexity */\nexport default function injectShader(source, type, inject, injectStandardStubs) {\n  const isVertex = type === VERTEX_SHADER;\n\n  for (const key in inject) {\n    const fragmentData = inject[key];\n    fragmentData.sort((a, b) => a.order - b.order);\n    fragments.length = fragmentData.length;\n    for (let i = 0, len = fragmentData.length; i < len; ++i) {\n      fragments[i] = fragmentData[i].injection;\n    }\n    const fragmentString = `${fragments.join('\\n')}\\n`;\n    switch (key) {\n      // declarations are injected before the main function\n      case 'vs:#decl':\n        if (isVertex) {\n          source = source.replace(DECLARATION_INJECT_MARKER, fragmentString);\n        }\n        break;\n      // main code is injected at the end of main function\n      case 'vs:#main-start':\n        if (isVertex) {\n          source = source.replace(REGEX_START_OF_MAIN, match => match + fragmentString);\n        }\n        break;\n      case 'vs:#main-end':\n        if (isVertex) {\n          source = source.replace(REGEX_END_OF_MAIN, match => fragmentString + match);\n        }\n        break;\n      case 'fs:#decl':\n        if (!isVertex) {\n          source = source.replace(DECLARATION_INJECT_MARKER, fragmentString);\n        }\n        break;\n      case 'fs:#main-start':\n        if (!isVertex) {\n          source = source.replace(REGEX_START_OF_MAIN, match => match + fragmentString);\n        }\n        break;\n      case 'fs:#main-end':\n        if (!isVertex) {\n          source = source.replace(REGEX_END_OF_MAIN, match => fragmentString + match);\n        }\n        break;\n\n      default:\n        // TODO(Tarek): I think this usage should be deprecated.\n\n        // inject code after key, leaving key in place\n        source = source.replace(key, match => match + fragmentString);\n    }\n  }\n\n  // Remove if it hasn't already been replaced\n  source = source.replace(DECLARATION_INJECT_MARKER, '');\n\n  // Finally, if requested, insert an automatic module injector chunk\n  if (injectStandardStubs) {\n    source = source.replace(/\\}\\s*$/, match => match + MODULE_INJECTORS[type]);\n  }\n\n  return source;\n}\n\n/* eslint-enable complexity */\n\n// Takes an array of inject objects and combines them into one\nexport function combineInjects(injects) {\n  const result = {};\n  assert(Array.isArray(injects) && injects.length > 1);\n  injects.forEach(inject => {\n    for (const key in inject) {\n      result[key] = result[key] ? `${result[key]}\\n${inject[key]}` : inject[key];\n    }\n  });\n  return result;\n}\n","export const MODULE_INJECTORS_VS = `\\\n#ifdef MODULE_LOGDEPTH\n  logdepth_adjustPosition(gl_Position);\n#endif\n`;\n\nexport const MODULE_INJECTORS_FS = `\\\n#ifdef MODULE_MATERIAL\n  gl_FragColor = material_filterColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_LIGHTING\n  gl_FragColor = lighting_filterColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_FOG\n  gl_FragColor = fog_filterColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_PICKING\n  gl_FragColor = picking_filterHighlightColor(gl_FragColor);\n  gl_FragColor = picking_filterPickingColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_LOGDEPTH\n  logdepth_setFragDepth();\n#endif\n`;\n","// shadertools exports\n\n// DEFAULT SHADERS\n// A set of base shaders that leverage the shader module system,\n// dynamically enabling features depending on which modules are included\nimport MODULAR_VS from './shaders/modular-vertex.glsl';\nimport MODULAR_FS from './shaders/modular-fragment.glsl';\n\n// DOCUMENTED APIS\nexport {\n  registerShaderModules,\n  setDefaultShaderModules,\n  getDefaultShaderModules\n} from './lib/resolve-modules';\nexport {\n  assembleShaders,\n  createShaderHook,\n  createModuleInjection,\n  resetGlobalShaderHooks\n} from './lib/assemble-shaders';\n\n// HELPERS\nexport {combineInjects} from './lib/inject-shader';\nexport {normalizeShaderModule} from './lib/shader-module';\n\n// UTILS\nexport {\n  getQualifierDetails,\n  getPassthroughFS,\n  typeToChannelSuffix,\n  typeToChannelCount,\n  convertToVec4\n} from './utils/shader-utils';\n\n// SHADER MODULES\nexport * from './modules';\n\nexport const MODULAR_SHADERS = {\n  vs: MODULAR_VS,\n  fs: MODULAR_FS,\n  uniforms: {}\n};\n","export default `\\\n#define SHADER_NAME luma_modular_vertex\n\n// object attributes\nattribute vec3 positions;\nattribute vec3 normals;\nattribute vec4 colors;\nattribute vec2 texCoords;\nattribute vec3 pickingColors;\n\nvoid main(void) {\n\n  // Set up position\n#ifdef MODULE_GEOMETRY\n  geometry_setPosition(positions);\n  geometry_setNormal(normals);\n#endif\n\n#ifdef MODULE_PROJECT\n  project_setPositionAndNormal_Model(positions, normals);\n  gl_Position = project_model_to_clipspace(positions);\n#endif\n\n  // Set up depth\n#ifdef MODULE_LOGDEPTH\n  logdepth_adjustPosition(gl_Position);\n#endif\n\n#ifdef MODULE_DIFFUSE\n  diffuse_setTextureCoordinate(texCoords);\n#endif\n\n  // Set up color calculations\n#ifdef MODULE_MATERIAL\n  material_setDiffuseColor(colors);\n  material_setDiffuseTextureCoordinates(texCoords);\n#endif\n\n#ifdef MODULE_LIGHTING\n  lighting_setPositionAndNormal(positions, normals);\n  lighting_apply_light(positions);\n  lighting_apply_reflection(positions);\n#endif\n\n#ifdef MODULE_PICKING\n  picking_setPickingColor(pickingColors);\n#endif\n\n}\n`;\n","export default `\\\n#define SHADER_NAME luma-modular-fragment\n\nprecision highp float;\n\n// varyings\nvarying vec4 vColor;\n\nvoid main(){\n  gl_FragColor = vec4(1., 0., 1., 1.);\n\n#ifdef MODULE_DIFFUSE\n  gl_FragColor = diffuse_filterColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_MATERIAL\n  gl_FragColor = material_filterColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_LIGHTING\n  gl_FragColor = lighting_filterColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_FOG\n  gl_FragColor = fog_filterColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_PICKING\n  gl_FragColor = picking_filterHighlightColor(gl_FragColor);\n  gl_FragColor = picking_filterPickingColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_LOGDEPTH\n  logdepth_setFragDepth(gl_Position);\n#endif\n}\n`;\n","export const VERTEX_SHADER = 'vs';\nexport const FRAGMENT_SHADER = 'fs';\n","import Model from '../../lib/model';\nimport ScenegraphNode from './scenegraph-node';\n\nexport default class ModelNode extends ScenegraphNode {\n  constructor(gl, props = {}) {\n    super(props);\n\n    // pverride callbacks to make sure we call them with this\n    this.onBeforeRender = null;\n    this.AfterRender = null;\n\n    // Create new Model or used supplied Model\n    if (gl instanceof Model) {\n      this.model = gl;\n      this._setModelNodeProps(props);\n    } else {\n      this.model = new Model(gl, props);\n    }\n\n    this.managedResources = props.managedResources || [];\n  }\n\n  setProps(props) {\n    super.setProps(props);\n    this._setModelNodeProps(props);\n    return this;\n  }\n\n  delete() {\n    if (this.model) {\n      this.model.delete();\n      this.model = null;\n    }\n\n    this.managedResources.forEach(resource => resource.delete());\n    this.managedResources = [];\n  }\n\n  // Forward node methods\n  draw(...args) {\n    // Return value indicates if something was actually drawn\n    return this.model.draw(...args);\n  }\n\n  setUniforms(...args) {\n    this.model.setUniforms(...args);\n    return this;\n  }\n\n  setAttributes(...args) {\n    this.model.setAttributes(...args);\n    return this;\n  }\n\n  updateModuleSettings(...args) {\n    this.model.updateModuleSettings(...args);\n    return this;\n  }\n\n  // PRIVATE\n\n  _setModelNodeProps(props) {\n    this.model.setProps(props);\n  }\n}\n","// Recommendation is to ignore message but current test suite checks agains the\n// message so keep it for now.\nexport default function assert(condition, message) {\n  if (!condition) {\n    throw new Error(message || 'shadertools: assertion failed.');\n  }\n}\n","import GL from '@luma.gl/constants';\nimport Resource from './resource';\nimport Buffer from './buffer';\nimport {isWebGL2, assertWebGL2Context} from '../webgl-utils';\nimport {log, isObjectEmpty} from '../utils';\n\n// NOTE: The `bindOnUse` flag is a major workaround:\n// See https://github.com/KhronosGroup/WebGL/issues/2346\n\nexport default class TransformFeedback extends Resource {\n  static isSupported(gl) {\n    return isWebGL2(gl);\n  }\n\n  constructor(gl, props = {}) {\n    assertWebGL2Context(gl);\n    super(gl, props);\n\n    this.initialize(props);\n    this.stubRemovedMethods('TransformFeedback', 'v6.0', ['pause', 'resume']);\n    Object.seal(this);\n  }\n\n  initialize(props = {}) {\n    this.buffers = {};\n    this.unused = {};\n    this.configuration = null;\n    this.bindOnUse = true;\n\n    // Unbind any currently bound buffers\n    if (!isObjectEmpty(this.buffers)) {\n      this.bind(() => this._unbindBuffers());\n    }\n\n    this.setProps(props);\n    return this;\n  }\n\n  setProps(props) {\n    if ('program' in props) {\n      this.configuration = props.program && props.program.configuration;\n    }\n    if ('configuration' in props) {\n      this.configuration = props.configuration;\n    }\n    if ('bindOnUse' in props) {\n      props = props.bindOnUse;\n    }\n    if ('buffers' in props) {\n      this.setBuffers(props.buffers);\n    }\n  }\n\n  setBuffers(buffers = {}) {\n    this.bind(() => {\n      for (const bufferName in buffers) {\n        this.setBuffer(bufferName, buffers[bufferName]);\n      }\n    });\n    return this;\n  }\n\n  setBuffer(locationOrName, bufferOrParams) {\n    const location = this._getVaryingIndex(locationOrName);\n    const {buffer, byteSize, byteOffset} = this._getBufferParams(bufferOrParams);\n\n    if (location < 0) {\n      this.unused[locationOrName] = buffer;\n      log.warn(() => `${this.id} unused varying buffer ${locationOrName}`)();\n      return this;\n    }\n\n    this.buffers[location] = bufferOrParams;\n\n    // Need to avoid chrome bug where buffer that is already bound to a different target\n    // cannot be bound to 'TRANSFORM_FEEDBACK_BUFFER' target.\n    if (!this.bindOnUse) {\n      this._bindBuffer(location, buffer, byteOffset, byteSize);\n    }\n\n    return this;\n  }\n\n  begin(primitiveMode = GL.POINTS) {\n    this.gl.bindTransformFeedback(GL.TRANSFORM_FEEDBACK, this.handle);\n    this._bindBuffers();\n    this.gl.beginTransformFeedback(primitiveMode);\n    return this;\n  }\n\n  end() {\n    this.gl.endTransformFeedback();\n    this._unbindBuffers();\n    this.gl.bindTransformFeedback(GL.TRANSFORM_FEEDBACK, null);\n    return this;\n  }\n\n  // PRIVATE METHODS\n\n  _getBufferParams(bufferOrParams) {\n    let byteOffset;\n    let byteSize;\n    let buffer;\n    if (bufferOrParams instanceof Buffer === false) {\n      buffer = bufferOrParams.buffer;\n      byteSize = bufferOrParams.byteSize;\n      byteOffset = bufferOrParams.byteOffset;\n    } else {\n      buffer = bufferOrParams;\n    }\n    // to use bindBufferRange, either offset or size must be specified, use default value for the other.\n    if (byteOffset !== undefined || byteSize !== undefined) {\n      byteOffset = byteOffset || 0;\n      byteSize = byteSize || buffer.byteLength - byteOffset;\n    }\n    return {buffer, byteOffset, byteSize};\n  }\n\n  _getVaryingInfo(locationOrName) {\n    return this.configuration && this.configuration.getVaryingInfo(locationOrName);\n  }\n\n  _getVaryingIndex(locationOrName) {\n    if (this.configuration) {\n      return this.configuration.getVaryingInfo(locationOrName).location;\n    }\n    const location = Number(locationOrName);\n    return Number.isFinite(location) ? location : -1;\n  }\n\n  // Need to avoid chrome bug where buffer that is already bound to a different target\n  // cannot be bound to 'TRANSFORM_FEEDBACK_BUFFER' target.\n  _bindBuffers() {\n    if (this.bindOnUse) {\n      for (const bufferIndex in this.buffers) {\n        const {buffer, byteSize, byteOffset} = this._getBufferParams(this.buffers[bufferIndex]);\n        this._bindBuffer(bufferIndex, buffer, byteOffset, byteSize);\n      }\n    }\n  }\n\n  _unbindBuffers() {\n    if (this.bindOnUse) {\n      for (const bufferIndex in this.buffers) {\n        this._bindBuffer(bufferIndex, null);\n      }\n    }\n  }\n\n  _bindBuffer(index, buffer, byteOffset = 0, byteSize) {\n    const handle = buffer && buffer.handle;\n    if (!handle || byteSize === undefined) {\n      this.gl.bindBufferBase(GL.TRANSFORM_FEEDBACK_BUFFER, index, handle);\n    } else {\n      this.gl.bindBufferRange(GL.TRANSFORM_FEEDBACK_BUFFER, index, handle, byteOffset, byteSize);\n    }\n    return this;\n  }\n\n  // RESOURCE METHODS\n\n  _createHandle() {\n    return this.gl.createTransformFeedback();\n  }\n\n  _deleteHandle() {\n    this.gl.deleteTransformFeedback(this.handle);\n  }\n\n  _bindHandle(handle) {\n    this.gl.bindTransformFeedback(GL.TRANSFORM_FEEDBACK, this.handle);\n  }\n}\n","let channelHandles = 1;\nlet animationHandles = 1;\n\nexport class Timeline {\n  constructor() {\n    this.time = 0;\n    this.channels = new Map();\n    this.animations = new Map();\n    this.playing = false;\n    this.lastEngineTime = -1;\n  }\n\n  addChannel(props) {\n    const {delay = 0, duration = Number.POSITIVE_INFINITY, rate = 1, repeat = 1} = props;\n\n    const handle = channelHandles++;\n    const channel = {\n      time: 0,\n      delay,\n      duration,\n      rate,\n      repeat\n    };\n    this._setChannelTime(channel, this.time);\n    this.channels.set(handle, channel);\n\n    return handle;\n  }\n\n  removeChannel(handle) {\n    this.channels.delete(handle);\n\n    for (const [animationHandle, animation] of this.animations) {\n      if (animation.channel === handle) {\n        this.detachAnimation(animationHandle);\n      }\n    }\n  }\n\n  isFinished(handle) {\n    const channel = this.channels.get(handle);\n    if (channel === undefined) {\n      return false;\n    }\n\n    return this.time >= channel.delay + channel.duration * channel.repeat;\n  }\n\n  getTime(handle) {\n    if (handle === undefined) {\n      return this.time;\n    }\n\n    const channel = this.channels.get(handle);\n\n    if (channel === undefined) {\n      return -1;\n    }\n\n    return channel.time;\n  }\n\n  setTime(time) {\n    this.time = Math.max(0, time);\n\n    const channels = this.channels.values();\n    for (const channel of channels) {\n      this._setChannelTime(channel, this.time);\n    }\n\n    const animations = this.animations.values();\n    for (const animationData of animations) {\n      const {animation, channel} = animationData;\n      animation.setTime(this.getTime(channel));\n    }\n  }\n\n  play() {\n    this.playing = true;\n  }\n\n  pause() {\n    this.playing = false;\n    this.lastEngineTime = -1;\n  }\n\n  reset() {\n    this.setTime(0);\n  }\n\n  attachAnimation(animation, channelHandle) {\n    const animationHandle = animationHandles++;\n\n    this.animations.set(animationHandle, {\n      animation,\n      channel: channelHandle\n    });\n\n    animation.setTime(this.getTime(channelHandle));\n\n    return animationHandle;\n  }\n\n  detachAnimation(handle) {\n    this.animations.delete(handle);\n  }\n\n  update(engineTime) {\n    if (this.playing) {\n      if (this.lastEngineTime === -1) {\n        this.lastEngineTime = engineTime;\n      }\n      this.setTime(this.time + (engineTime - this.lastEngineTime));\n      this.lastEngineTime = engineTime;\n    }\n  }\n\n  _setChannelTime(channel, time) {\n    const offsetTime = time - channel.delay;\n    const totalDuration = channel.duration * channel.repeat;\n    // Note(Tarek): Don't loop on final repeat.\n    if (offsetTime >= totalDuration) {\n      channel.time = channel.duration * channel.rate;\n    } else {\n      channel.time = Math.max(0, offsetTime) % channel.duration;\n      channel.time *= channel.rate;\n    }\n  }\n}\n"],"sourceRoot":""}