(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{425:function(e,n,t){"use strict";t.r(n);var o=t(1),a=t.n(o),r=t(405),i=(t(35),t(7),t(6),t(4),t(33)),c=t(489),p=t(450);var l=1e5,s=-.0150086889504513,d=.7818669390408505,v=[[-2.2,-1.2],[.7,-1.2],[-2.2,1.2],[.7,1.2]],u=0,f=0,m=1;var g=function(e){var n,t;function o(){return e.apply(this,arguments)||this}t=e,(n=o).prototype=Object.create(t.prototype),n.prototype.constructor=n,n.__proto__=t,o.getInfo=function(){return"\n<p>\n<code>Mandelbrot</code> set zoom implemented as a GLSL fragment shader.\n<p>\nUses a luma.gl <code>ClipSpace</code> Model to set up a screen spaced model\nin which the <code>fragment shader</code> can render.\n"};var a=o.prototype;return a.onInitialize=function(e){var n=e.gl,t=(e._animationLoop,new i.a(n,32));return{clipSpace:new c.a(n,{fs:"#define SHADER_NAME mandelbrot32\n\nprecision highp float;\n\n// Based on a renderman shader by Michael Rivero\nconst int maxIterations = 1;\nvarying vec2 coordinate;\n\nvoid main (void)\n{\n  vec2 pos = coordinate;\n  float real = pos.x;\n  float imag = pos.y;\n  float Creal = real;\n  float Cimag = imag;\n\n  int divergeIteration = 0;\n  for (int i = 0; i < 100; i++)\n  {\n    // z = z^2 + c\n    float tempreal = real;\n    float tempimag = imag;\n    real = (tempreal * tempreal) - (tempimag * tempimag);\n    imag = 2. * tempreal * tempimag;\n    real += Creal;\n    imag += Cimag;\n    float r2 = (real * real) + (imag * imag);\n    if (divergeIteration == 0 && r2 >= 4.) {\n      divergeIteration = i;\n    }\n  }\n  // Base the color on the number of iterations\n  vec4 color;\n  if (divergeIteration < 9) {\n    color = vec4 (0., 0., 0., 1.0); // black\n  }\n  else\n  {\n    float tmpval = fract((float(divergeIteration) / 100.));\n    color = vec4 (tmpval, 0, tmpval, 1.0);\n    // color = vec4 (coordinate.r, coordinate.g, 0., 1.0);\n  }\n  gl_FragColor = color;\n}\n",attributes:{aCoordinate:[t,{size:2}]}}),cornersBuffer:t}},a.onRender=function(e){var n=e.gl,t=e.canvas,o=(e.tick,e.clipSpace),a=e.cornersBuffer;n.viewport(0,0,Math.max(t.width,t.height),Math.max(t.width,t.height)),a.setData(new Float32Array(function(e){void 0===e&&(e=1.01),(m*=e)>l&&(m=1);var n=[],t=v,o=Array.isArray(t),a=0;for(t=o?t:t[Symbol.iterator]();;){var r;if(o){if(a>=t.length)break;r=t[a++]}else{if((a=t.next()).done)break;r=a.value}var i=r;n.push(i[0]/m+u,i[1]/m+f)}return u!==s&&(u+=(s-u)/20),f!==d&&(f+=(d-f)/20),n}())),o.draw()},o}(p.a);"undefined"==typeof window||window.website||(new g).start();t.d(n,"default",(function(){return h}));var h=function(e){var n,t;function o(){return e.apply(this,arguments)||this}return t=e,(n=o).prototype=Object.create(t.prototype),n.prototype.constructor=n,n.__proto__=t,o.prototype.render=function(){return a.a.createElement(r.a,{AnimationLoop:g,exampleConfig:this.props.pageContext.exampleConfig})},o}(a.a.Component)},489:function(e,n,t){"use strict";t.d(n,"a",(function(){return l}));t(35),t(2);var o=t(0),a=t.n(o),r=t(407),i=t(406);var c="attribute vec2 aClipSpacePosition;\nattribute vec2 aTexCoord;\nattribute vec2 aCoordinate;\n\nvarying vec2 position;\nvarying vec2 coordinate;\nvarying vec2 uv;\n\nvoid main(void) {\n  gl_Position = vec4(aClipSpacePosition, 0., 1.);\n  position = aClipSpacePosition;\n  coordinate = aCoordinate;\n  uv = aTexCoord;\n}\n",p=[-1,-1,1,-1,-1,1,1,1],l=function(e){var n,t;function o(n,t){var o,r=p.map((function(e){return-1===e?0:e}));return(o=e.call(this,n,Object.assign({},t,{vs:c,geometry:new i.a({drawMode:a.a.TRIANGLE_STRIP,vertexCount:4,attributes:{aClipSpacePosition:{size:2,value:new Float32Array(p)},aTexCoord:{size:2,value:new Float32Array(r)},aCoordinate:{size:2,value:new Float32Array(r)}}})}))||this).setVertexCount(4),o}return t=e,(n=o).prototype=Object.create(t.prototype),n.prototype.constructor=n,n.__proto__=t,o}(r.a)}}]);
//# sourceMappingURL=component---templates-core-example-mandelbrot-jsx-af083197bf6153e6efb9.js.map