{"version":3,"sources":["webpack:///../examples/core/mandelbrot/app.js","webpack:///./templates/core/example-mandelbrot.jsx","webpack:///../modules/core/src/lib/clip-space.js"],"names":["ZOOM_THRESHOLD","ZOOM_CENTER_X","ZOOM_CENTER_Y","BASE_CORNERS","centerOffsetX","centerOffsetY","zoom","AppAnimationLoop","getInfo","onInitialize","gl","cornersBuffer","_animationLoop","clipSpace","fs","attributes","aCoordinate","size","onRender","canvas","tick","Math","Float32Array","zoomFactor","corners","baseCorner","getZoomedCorners","AnimationLoop","window","animationLoop","Example","render","exampleConfig","this","props","pageContext","React","Component","CLIPSPACE_VERTEX_SHADER","POSITIONS","ClipSpace","TEX_COORDS","coord","Object","vs","geometry","drawMode","GL","vertexCount","aClipSpacePosition","value","aTexCoord","Model"],"mappings":"gLAEA,IAyDMA,EAAN,IACMC,GAAN,kBACMC,EAAN,kBAEMC,EAAe,CAAC,OAAD,KAAe,CAAC,IAAhB,KAA4B,MAA5B,KAAyC,CAAC,GAA/D,MAEIC,EAAJ,EACIC,EAAJ,EACIC,EAAJ,E,IAwBqBC,E,+JACZC,QAAP,WACE,MA3FJ,6N,2BA8FEC,yBAAoC,IAAtBC,EAAqB,EAArBA,GACNC,GAD2B,EAAjBC,eACM,IAAI,EAAJ,IAAtB,KAEA,MAAO,CACLC,UAAW,IAAI,EAAJ,IAAkB,CAC3BC,GAzFR,6jCA0FQC,WAAY,CACVC,YAAa,CAACL,EAAe,CAACM,KAAM,OAGxCN,kB,EAIJO,qBAAwD,IAA9CR,EAA6C,EAA7CA,GAAIS,EAAyC,EAAzCA,OAAcN,GAA2B,EAAjCO,KAAiC,EAA3BP,WAAWF,EAAgB,EAAhBA,cACrCD,eAAkBW,SAASF,EAATE,MAAuBF,EAAzCT,QAAyDW,SAASF,EAATE,MAAuBF,EAAhFT,SAEAC,UAAsB,IAAIW,aA3C9B,SAA0BC,QAAmB,IAAnBA,MAAa,OACrCjB,MACA,IACEA,KAGF,IAAMkB,EAAN,GACA,4DAAuC,CAAC,IAAD,oFAA5BC,EAA4B,EACrCD,OAAaC,OAAbD,EAAmDC,OAAnDD,GAUF,OAPIpB,IAAJ,IACEA,IAAkBH,EAAD,GAAjBG,IAEEC,IAAJ,IACEA,IAAkBH,EAAD,GAAjBG,IAGKmB,EAyBkCE,KAEvCb,U,GAxB0Cc,KA6B1C,oBAAOC,QAA2BA,OAAtC,UACwB,IAAtB,GACAC,Q,4CCtHmBC,E,gLACnBC,kBACE,OACE,uBAA0BJ,cAA1B,EAAwDK,cAAeC,KAAKC,MAAMC,YAAYH,iB,GAH/DI,IAAMC,Y,oHCC3C,IAAMC,EAAN,kUAkBMC,EAAY,mBAAlB,GAEqBC,E,oBACnB,gBAAuB,IAAD,EACdC,EAAaF,EAAA,KAAc,SAAAG,GAAK,OAAKA,QAAL,KADlB,OAGpB,gBAEEC,OAAA,YAAwB,CACtBC,GADsB,EAEtBC,SAAU,IAAI,EAAJ,EAAa,CACrBC,SAAUC,IADW,eAErBC,YAFqB,EAGrBjC,WAAY,CACVkC,mBAAoB,CAAChC,KAAD,EAAUiC,MAAO,IAAI5B,aAAaiB,IACtDY,UAAW,CAAClC,KAAD,EAAUiC,MAAO,IAAI5B,aAAamB,IAC7CzB,YAAa,CAACC,KAAD,EAAUiC,MAAO,IAAI5B,aAAamB,WAVvD,MAeA,kBAlBoB,E,iGADeW","file":"component---templates-core-example-mandelbrot-jsx-db5c88976c465aac6cf0.js","sourcesContent":["import {AnimationLoop, ClipSpace, Buffer} from '@luma.gl/core';\n\nconst INFO_HTML = `\n<p>\n<code>Mandelbrot</code> set zoom implemented as a GLSL fragment shader.\n<p>\nUses a luma.gl <code>ClipSpace</code> Model to set up a screen spaced model\nin which the <code>fragment shader</code> can render.\n`;\n\n// CONTEXT 1 - 32 bit mandelbrot\n\nconst MANDELBROT_FRAGMENT_SHADER = `\\\n#define SHADER_NAME mandelbrot32\n\nprecision highp float;\n\n// Based on a renderman shader by Michael Rivero\nconst int maxIterations = 1;\nvarying vec2 coordinate;\n\nvoid main (void)\n{\n  vec2 pos = coordinate;\n  float real = pos.x;\n  float imag = pos.y;\n  float Creal = real;\n  float Cimag = imag;\n\n  int divergeIteration = 0;\n  for (int i = 0; i < 100; i++)\n  {\n    // z = z^2 + c\n    float tempreal = real;\n    float tempimag = imag;\n    real = (tempreal * tempreal) - (tempimag * tempimag);\n    imag = 2. * tempreal * tempimag;\n    real += Creal;\n    imag += Cimag;\n    float r2 = (real * real) + (imag * imag);\n    if (divergeIteration == 0 && r2 >= 4.) {\n      divergeIteration = i;\n    }\n  }\n  // Base the color on the number of iterations\n  vec4 color;\n  if (divergeIteration < 9) {\n    color = vec4 (0., 0., 0., 1.0); // black\n  }\n  else\n  {\n    float tmpval = fract((float(divergeIteration) / 100.));\n    color = vec4 (tmpval, 0, tmpval, 1.0);\n    // color = vec4 (coordinate.r, coordinate.g, 0., 1.0);\n  }\n  gl_FragColor = color;\n}\n`;\n\nconst ZOOM_THRESHOLD = 1e5;\nconst ZOOM_CENTER_X = -0.0150086889504513;\nconst ZOOM_CENTER_Y = 0.78186693904085048;\n\nconst BASE_CORNERS = [[-2.2, -1.2], [0.7, -1.2], [-2.2, 1.2], [0.7, 1.2]];\n\nlet centerOffsetX = 0;\nlet centerOffsetY = 0;\nlet zoom = 1;\n\n// Calculate new zoomed extents\nfunction getZoomedCorners(zoomFactor = 1.01) {\n  zoom *= zoomFactor;\n  if (zoom > ZOOM_THRESHOLD) {\n    zoom = 1;\n  }\n\n  const corners = [];\n  for (const baseCorner of BASE_CORNERS) {\n    corners.push(baseCorner[0] / zoom + centerOffsetX, baseCorner[1] / zoom + centerOffsetY);\n  }\n\n  if (centerOffsetX !== ZOOM_CENTER_X) {\n    centerOffsetX += (ZOOM_CENTER_X - centerOffsetX) / 20;\n  }\n  if (centerOffsetY !== ZOOM_CENTER_Y) {\n    centerOffsetY += (ZOOM_CENTER_Y - centerOffsetY) / 20;\n  }\n\n  return corners;\n}\n\nexport default class AppAnimationLoop extends AnimationLoop {\n  static getInfo() {\n    return INFO_HTML;\n  }\n\n  onInitialize({gl, _animationLoop}) {\n    const cornersBuffer = new Buffer(gl, 32);\n\n    return {\n      clipSpace: new ClipSpace(gl, {\n        fs: MANDELBROT_FRAGMENT_SHADER,\n        attributes: {\n          aCoordinate: [cornersBuffer, {size: 2}]\n        }\n      }),\n      cornersBuffer\n    };\n  }\n\n  onRender({gl, canvas, tick, clipSpace, cornersBuffer}) {\n    gl.viewport(0, 0, Math.max(canvas.width, canvas.height), Math.max(canvas.width, canvas.height));\n\n    cornersBuffer.setData(new Float32Array(getZoomedCorners()));\n\n    clipSpace.draw();\n  }\n}\n\n/* global window */\nif (typeof window !== 'undefined' && !window.website) {\n  const animationLoop = new AppAnimationLoop();\n  animationLoop.start();\n}\n","import React from 'react';\nimport AnimationLoopExamplePage from '../../src/components/animation-loop-example-page';\nimport AnimationLoop from '../../../examples/core/mandelbrot/app';\n\nexport default class Example extends React.Component {\n  render() {\n    return (\n      <AnimationLoopExamplePage AnimationLoop={AnimationLoop} exampleConfig={this.props.pageContext.exampleConfig} />\n    );\n  }\n}\n","// ClipSpace\nimport GL from '@luma.gl/constants';\nimport Model from '../lib/model';\nimport Geometry from '../geometry/geometry';\n\nconst CLIPSPACE_VERTEX_SHADER = `\\\nattribute vec2 aClipSpacePosition;\nattribute vec2 aTexCoord;\nattribute vec2 aCoordinate;\n\nvarying vec2 position;\nvarying vec2 coordinate;\nvarying vec2 uv;\n\nvoid main(void) {\n  gl_Position = vec4(aClipSpacePosition, 0., 1.);\n  position = aClipSpacePosition;\n  coordinate = aCoordinate;\n  uv = aTexCoord;\n}\n`;\n\n/* eslint-disable indent, no-multi-spaces */\nconst POSITIONS = [-1, -1, 1, -1, -1, 1, 1, 1];\n\nexport default class ClipSpace extends Model {\n  constructor(gl, opts) {\n    const TEX_COORDS = POSITIONS.map(coord => (coord === -1 ? 0 : coord));\n\n    super(\n      gl,\n      Object.assign({}, opts, {\n        vs: CLIPSPACE_VERTEX_SHADER,\n        geometry: new Geometry({\n          drawMode: GL.TRIANGLE_STRIP,\n          vertexCount: 4,\n          attributes: {\n            aClipSpacePosition: {size: 2, value: new Float32Array(POSITIONS)},\n            aTexCoord: {size: 2, value: new Float32Array(TEX_COORDS)},\n            aCoordinate: {size: 2, value: new Float32Array(TEX_COORDS)}\n          }\n        })\n      })\n    );\n    this.setVertexCount(4);\n  }\n}\n"],"sourceRoot":""}