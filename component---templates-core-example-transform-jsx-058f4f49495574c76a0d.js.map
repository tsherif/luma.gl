{"version":3,"sources":["webpack:///../modules/core/src/lib/transform/buffer-transform.js","webpack:///../modules/webgl/src/glsl-utils/get-shader-version.js","webpack:///../modules/shadertools/src/modules/transform/transform.js","webpack:///../modules/core/src/lib/transform/transform-shader-utils.js","webpack:///../modules/core/src/lib/transform/texture-transform.js","webpack:///../modules/core/src/lib/transform/transform.js","webpack:///../examples/core/transform/app.js","webpack:///./templates/core/example-transform.jsx","webpack:///../node_modules/seer/dist/index.js","webpack:///../modules/shadertools/src/utils/shader-utils.js","webpack:///../modules/shadertools/src/modules/picking/picking.js"],"names":["BufferTransform","gl","props","this","currentIndex","feedbackMap","varyings","bindings","resources","_initialize","Object","setupResources","_iterator","_isArray","Array","isArray","_i","Symbol","iterator","_ref","length","next","done","value","binding","_setupTransformFeedback","opts","updateModelProps","assign","getDrawOptions","sourceBuffers","transformFeedback","attributes","swap","_getNextIndex","update","_setupBuffers","getBuffer","feedbackBuffers","bufferOrParams","varyingName","buffer","getData","_temp","delete","name","assert","isWebGL2","_getFeedbackBuffers","sourceName","bufferName","bufferOrRef","sourceBuffer","byteLength","usage","accessor","_createNewBuffer","_props$sourceBuffers","_updateBindings","program","_ref3","model","transform_feedback","buffers","_updateBinding","_this$_swapBuffers","_swapBuffers","nextIndex","srcName","dstName","classes_buffer","getShaderVersion","source","version","words","v","parseInt","Number","transform_transform","vs","fs","SAMPLER_UNIFORM_PREFIX","SIZE_UNIFORM_PREFIX","VS_POS_VARIABLE","updateForTextures","sourceTextureMap","targetTextureVarying","targetTexture","sourceCount","targetTextureType","samplerTextureMap","updatedVs","finalInject","vsLines","updateVsLines","slice","line","index","lines","updated","textureMap","attributeData","getQualifierDetails","getAttributeDefinition","type","updatedLine","_getSamplerDecleratio","textureName","samplerName","sizeName","uniformDeclerations","getSamplerDeclerations","channels","typeToChannelSuffix","sampleInstruction","inject","vs:#decl","vs:#main-start","processAttributeDefinition","combineInjects","varying","qualaiferDetails","getVaryingType","SRC_TEX_PARAMETER_OVERRIDES","_SRC_TEX_PARAMETER_OV","GL","TEXTURE_MIN_FILTER","NEAREST","TEXTURE_MAG_FILTER","TEXTURE_WRAP_S","CLAMP_TO_EDGE","TEXTURE_WRAP_T","TextureTransform","_swapTexture","updatedModelProps","_processVertexShader","_this$bindings$this$c","sourceTextures","framebuffer","uniforms","parameters","discard","hasSourceTextures","hasTargetTexture","sampler","_setSourceTextureParameters","sizeUniforms","_ref2","width","height","_sourceTextureMap$tex","getSizeUniforms","_setupTextures","getTargetTexture","_ref$packed","packed","pixels","readPixelsToArray","ArrayType","constructor","channelCount","typeToChannelCount","packedPixels","packCount","i","j","getFramebuffer","ownTexture","elementIDBuffer","_props","_targetTextureVarying","_createTargetTexture","textureOrReference","texture_2d","refTexture","_targetRefTexName","_createNewTexture","_props2","_props2$_sourceTextur","_sourceTextures","_targetTexture","_updateElementIDBuffer","elementCount","elementIds","Float32Array","_","array","setData","data","size","_this$_swapTextures","_swapTextures","_attachments","_attachments2","attachments","COLOR_ATTACHMENT0","resizeAttachments","classes_framebuffer","id","_parameters","_pixelStore","texture","cloneTextureFrom","pixelStore","UNPACK_FLIP_Y_WEBGL","_this$bindings$this$c2","_updateForTextures","combinedInject","getPassthroughFS","input","inputType","output","modules","concat","Transform","bufferTransform","textureTransform","isSupported","run","_opts$clearRenderTarg","clearRenderTarget","updatedOpts","_updateDrawOptions","color","transform","swapped","filter","Boolean","_iterator2","_isArray2","_i2","resourceTransform","setVertexCount","_iterator3","_isArray3","_i3","_buildResourceTransforms","_updateModelProps","lib_model","drawMode","POINTS","vertexCount","updatedProps","_iterator4","_isArray4","_i4","_ref4","isObjectEmpty","canCreateBufferTransform","buffer_transform_BufferTransform","canCreateTextureTransform","texture_transform_TextureTransform","_iterator5","_isArray5","_i5","_ref5","RED","Uint8Array","ALT_TEXT","log","enable","pickPosition","mousemove","e","offsetX","mouseleave","AppAnimationLoop","_this","_AnimationLoop","call","createFramebuffer","isDemoSupported","getInfo","onInitialize","canvas","trianglePositions","instanceOffsets","NUM_INSTANCES","instanceRotations","instanceColors","pickingColors","Uint8ClampedArray","Math","random","positionBuffer","colorBuffer","offsetBuffer","rotationBuffer","pickingColorBuffer","renderModel","TRIANGLE_FAN","isInstanced","instanceCount","a_position","a_color","divisor","a_offset","a_rotation","instancePickingColors","picking","transform_Transform","onRender","time","useDevicePixels","u_time","depth","blend","blendFunc","SRC_ALPHA","ONE","devicePixels","cssToDevicePixels","pickX","pickY","picking_uActive","sourceX","sourceY","sourceWidth","sourceHeight","sourceFormat","RGBA","sourceType","UNSIGNED_BYTE","pickingSelectedColor","pickingHighlightColor","pickInstance","onFinalize","getAltText","AnimationLoop","window","website","app_AppAnimationLoop","animationLoop","Example","render","react_default","a","createElement","animation_loop_example_page","exampleConfig","pageContext","React","Component","__webpack_require__","defineProperty","exports","_typeof","obj","prototype","isBrowser","addEventListener","timers","Map","isReady","__SEER_INITIALIZED__","throttle","key","delay","get","now","Date","set","send","arguments","undefined","seen","Set","payload","JSON","stringify","has","add","toString","includes","replacer","postMessage","console","listeners","listener","message","_message$data","typeListeners","forEach","cb","init","__SEER_LISTENER__","list","listItem","itemKey","updateItem","path","multiUpdate","deleteItem","addLog","msg","listenFor","Error","push","removeListener","l","clean","removeEventListener","FS100","FS_GLES","FS300","qualifiers","qualifier","definition","_ref$version","outputValue","variable","convertToVec4","DEFAULT_MODULE_OPTIONS","pickingThreshold","pickingActive","__webpack_exports__","getUniforms","selectedColor"],"mappings":"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","file":"component---templates-core-example-transform-jsx-058f4f49495574c76a0d.js","sourcesContent":["import {isWebGL2, Buffer, TransformFeedback} from '@luma.gl/webgl';\nimport {assert} from '../../utils';\n\nexport default class BufferTransform {\n  constructor(gl, props = {}) {\n    this.gl = gl;\n    this.currentIndex = 0;\n    this.feedbackMap = {};\n    this.varyings = null; // varyings array\n    this.bindings = []; // each element is an object : {sourceBuffers, feedbackBuffers, transformFeedback}\n\n    this.resources = {}; // resources to be deleted\n\n    this._initialize(props);\n    Object.seal(this);\n  }\n\n  setupResources(opts) {\n    for (const binding of this.bindings) {\n      this._setupTransformFeedback(binding, opts);\n    }\n  }\n\n  updateModelProps(props = {}) {\n    const {varyings} = this;\n    if (varyings.length > 0) {\n      props = Object.assign({}, props, {varyings});\n    }\n    return props;\n  }\n\n  getDrawOptions(opts = {}) {\n    const binding = this.bindings[this.currentIndex];\n    const {sourceBuffers, transformFeedback} = binding;\n    const attributes = Object.assign({}, sourceBuffers, opts.attributes);\n\n    return {attributes, transformFeedback};\n  }\n\n  swap() {\n    if (this.feedbackMap) {\n      this.currentIndex = this._getNextIndex();\n      return true;\n    }\n    return false;\n  }\n\n  // update source and/or feedbackBuffers\n  update(opts = {}) {\n    this._setupBuffers(opts);\n  }\n\n  // returns current feedbackBuffer of given name\n  getBuffer(varyingName) {\n    const {feedbackBuffers} = this.bindings[this.currentIndex];\n    const bufferOrParams = varyingName ? feedbackBuffers[varyingName] : null;\n    if (!bufferOrParams) {\n      return null;\n    }\n    return bufferOrParams instanceof Buffer ? bufferOrParams : bufferOrParams.buffer;\n  }\n\n  getData({varyingName} = {}) {\n    const buffer = this.getBuffer(varyingName);\n    if (buffer) {\n      return buffer.getData();\n    }\n    return null;\n  }\n\n  // Delete owned resources.\n  delete() {\n    for (const name in this.resources) {\n      this.resources[name].delete();\n    }\n  }\n\n  // Private\n\n  _initialize(props = {}) {\n    this._setupBuffers(props);\n    this.varyings = props.varyings || Object.keys(this.bindings[this.currentIndex].feedbackBuffers);\n    if (this.varyings.length > 0) {\n      // if writting to buffers make sure it is WebGL2\n      assert(isWebGL2(this.gl));\n    }\n  }\n\n  // auto create feedback buffers if requested\n  _getFeedbackBuffers(props) {\n    const {sourceBuffers} = props;\n    const feedbackBuffers = {};\n    if (this.bindings[this.currentIndex]) {\n      // this gurantees a partial feedback buffer set doesn't update\n      // previously set buffers during auto creation mode.\n      Object.assign(feedbackBuffers, this.bindings[this.currentIndex].feedbackBuffers);\n    }\n    if (this.feedbackMap) {\n      // feedbackMap is defined as sourceBuffer as key and feedbackBuffer name as object\n      for (const sourceName in this.feedbackMap) {\n        const feedbackName = this.feedbackMap[sourceName];\n        feedbackBuffers[feedbackName] = sourceName;\n      }\n    }\n    Object.assign(feedbackBuffers, props.feedbackBuffers);\n    for (const bufferName in feedbackBuffers) {\n      const bufferOrRef = feedbackBuffers[bufferName];\n      if (typeof bufferOrRef === 'string' && sourceBuffers[bufferOrRef]) {\n        // Create new buffer with same layout and settings as source buffer\n        const sourceBuffer = sourceBuffers[bufferOrRef];\n        const {byteLength, usage, accessor} = sourceBuffer;\n        feedbackBuffers[bufferName] = this._createNewBuffer(bufferName, {\n          byteLength,\n          usage,\n          accessor\n        });\n      }\n    }\n\n    return feedbackBuffers;\n  }\n\n  _setupBuffers(props = {}) {\n    const {sourceBuffers = null} = props;\n    Object.assign(this.feedbackMap, props.feedbackMap);\n    const feedbackBuffers = this._getFeedbackBuffers(props);\n    this._updateBindings({sourceBuffers, feedbackBuffers});\n  }\n\n  _setupTransformFeedback(binding, {model}) {\n    const {program} = model;\n    binding.transformFeedback = new TransformFeedback(this.gl, {\n      program,\n      buffers: binding.feedbackBuffers\n    });\n  }\n\n  _updateBindings(opts) {\n    this.bindings[this.currentIndex] = this._updateBinding(this.bindings[this.currentIndex], opts);\n    if (this.feedbackMap) {\n      const {sourceBuffers, feedbackBuffers} = this._swapBuffers(this.bindings[this.currentIndex]);\n      const nextIndex = this._getNextIndex();\n      this.bindings[nextIndex] = this._updateBinding(this.bindings[nextIndex], {\n        sourceBuffers,\n        feedbackBuffers\n      });\n    }\n  }\n\n  _updateBinding(binding, opts) {\n    if (!binding) {\n      return {\n        sourceBuffers: Object.assign({}, opts.sourceBuffers),\n        feedbackBuffers: Object.assign({}, opts.feedbackBuffers)\n      };\n    }\n    Object.assign(binding.sourceBuffers, opts.sourceBuffers);\n    Object.assign(binding.feedbackBuffers, opts.feedbackBuffers);\n    if (binding.transformFeedback) {\n      binding.transformFeedback.setBuffers(binding.feedbackBuffers);\n    }\n    return binding;\n  }\n\n  _swapBuffers(opts) {\n    if (!this.feedbackMap) {\n      return null;\n    }\n    const sourceBuffers = Object.assign({}, opts.sourceBuffers);\n    const feedbackBuffers = Object.assign({}, opts.feedbackBuffers);\n    for (const srcName in this.feedbackMap) {\n      const dstName = this.feedbackMap[srcName];\n      sourceBuffers[srcName] = opts.feedbackBuffers[dstName];\n      feedbackBuffers[dstName] = opts.sourceBuffers[srcName];\n\n      // make sure the new destination buffer is a Buffer object\n      assert(feedbackBuffers[dstName] instanceof Buffer);\n    }\n    return {sourceBuffers, feedbackBuffers};\n  }\n\n  // Create a buffer and add to list of buffers to be deleted.\n  _createNewBuffer(name, opts) {\n    const buffer = new Buffer(this.gl, opts);\n    if (this.resources[name]) {\n      this.resources[name].delete();\n    }\n    this.resources[name] = buffer;\n    return buffer;\n  }\n\n  _getNextIndex() {\n    return (this.currentIndex + 1) % 2;\n  }\n}\n","// returns GLSL shader version of given shader string\nexport default function getShaderVersion(source) {\n  let version = 100;\n  const words = source.match(/[^\\s]+/g);\n  if (words.length >= 2 && words[0] === '#version') {\n    const v = parseInt(words[1], 10);\n    if (Number.isFinite(v)) {\n      version = v;\n    }\n  }\n  return version;\n}\n","// Private shader module used by `Transform`\n\nconst vs = `\\\nattribute float transform_elementID;\n\n// returns half of pixel size, used to move the pixel position to center of the pixel.\nvec2 transform_getPixelSizeHalf(vec2 size) {\n  return vec2(1.) / (2. * size);\n}\n\n// returns current elements pixel indeces [x, y],\n// where x ranges in [0 to texSize-1] and y ranges in [0 to texSize-1]\nvec2 transform_getPixelIndices(vec2 texSize, vec2 pixelSizeHalf) {\n  // Add safe offset (half of pixel height) before doing floor\n  float yIndex = floor((transform_elementID / texSize[0]) + pixelSizeHalf[1]);\n  float xIndex = transform_elementID - (yIndex * texSize[0]);\n  return vec2(xIndex, yIndex);\n}\n\n// returns current elementID's texture co-ordianate\nvec2 transform_getTexCoord(vec2 size) {\n  vec2 pixelSizeHalf = transform_getPixelSizeHalf(size);\n  vec2 indices = transform_getPixelIndices(size, pixelSizeHalf);\n  vec2 coord = indices / size + pixelSizeHalf;\n  return coord;\n}\n\n// returns current elementID's position\nvec2 transform_getPos(vec2 size) {\n  vec2 texCoord = transform_getTexCoord(size);\n  // Change from [0 1] range to [-1 1]\n  vec2 pos = (texCoord * (2.0, 2.0)) - (1., 1.);\n  return pos;\n}\n\n// returns current elementID's pixel value\nvec4 transform_getInput(sampler2D texSampler, vec2 size) {\n  vec2 texCoord = transform_getTexCoord(size);\n  vec4 textureColor = texture2D(texSampler, texCoord);\n  return textureColor;\n}\n`;\n\nexport default {\n  name: 'transform',\n  vs,\n  fs: null\n};\n","import {assert} from '../../utils';\nimport {combineInjects, getQualifierDetails, typeToChannelSuffix} from '@luma.gl/shadertools';\n\nconst SAMPLER_UNIFORM_PREFIX = 'transform_uSampler_';\nconst SIZE_UNIFORM_PREFIX = 'transform_uSize_';\nconst VS_POS_VARIABLE = 'transform_position';\n\n// Scan provided vertex shader\n// for each texture attribute, inject sampler instructions and build uniforms for sampler\n// for texture target, get varying type and inject position instruction\nexport function updateForTextures({vs, sourceTextureMap, targetTextureVarying, targetTexture}) {\n  const texAttributeNames = Object.keys(sourceTextureMap);\n  let sourceCount = texAttributeNames.length;\n  let targetTextureType = null;\n  const samplerTextureMap = {};\n  let updatedVs = vs;\n  let finalInject = {};\n\n  if (sourceCount > 0 || targetTextureVarying) {\n    const vsLines = updatedVs.split('\\n');\n    const updateVsLines = vsLines.slice();\n    vsLines.forEach((line, index, lines) => {\n      // TODO add early exit\n      if (sourceCount > 0) {\n        const updated = processAttributeDefinition(line, sourceTextureMap);\n        if (updated) {\n          const {updatedLine, inject} = updated;\n          updateVsLines[index] = updatedLine;\n          // sampleInstructions.push(sampleInstruction);\n          finalInject = combineInjects([finalInject, inject]);\n          Object.assign(samplerTextureMap, updated.samplerTextureMap);\n          sourceCount--;\n        }\n      }\n      if (targetTextureVarying && !targetTextureType) {\n        targetTextureType = getVaryingType(line, targetTextureVarying);\n      }\n    });\n\n    if (targetTextureVarying) {\n      assert(targetTexture);\n      const sizeName = `${SIZE_UNIFORM_PREFIX}${targetTextureVarying}`;\n\n      const uniformDeclaration = `uniform vec2 ${sizeName};\\n`;\n      const posInstructions = `\\\n     vec2 ${VS_POS_VARIABLE} = transform_getPos(${sizeName});\n     gl_Position = vec4(${VS_POS_VARIABLE}, 0, 1.);\\n`;\n      const inject = {\n        'vs:#decl': uniformDeclaration,\n        'vs:#main-start': posInstructions\n      };\n      finalInject = combineInjects([finalInject, inject]);\n    }\n    updatedVs = updateVsLines.join('\\n');\n  }\n  return {\n    // updated vertex shader (commented texture attribute definition)\n    vs: updatedVs,\n    // type (float, vec2, vec3 of vec4) target texture varying\n    targetTextureType,\n    // required vertex and fragment shader injects\n    inject: finalInject,\n    // map of sampler name to texture name, can be used to set attributes\n    // usefull when swapping textures, as source and destination texture change when swap is called.\n    samplerTextureMap\n  };\n}\n\n// builds and returns an object contaning size uniform for each texture\nexport function getSizeUniforms({sourceTextureMap, targetTextureVarying, targetTexture}) {\n  const uniforms = {};\n  let width;\n  let height;\n  if (targetTextureVarying) {\n    ({width, height} = targetTexture);\n    uniforms[`${SIZE_UNIFORM_PREFIX}${targetTextureVarying}`] = [width, height];\n  }\n  for (const textureName in sourceTextureMap) {\n    ({width, height} = sourceTextureMap[textureName]);\n    uniforms[`${SIZE_UNIFORM_PREFIX}${textureName}`] = [width, height];\n  }\n  return uniforms;\n}\n\n// Checks if provided line is defining an attribute, if so returns details otherwise null\nfunction getAttributeDefinition(line) {\n  return getQualifierDetails(line, ['attribute', 'in']);\n}\n\nfunction getSamplerDeclerations(textureName) {\n  const samplerName = `${SAMPLER_UNIFORM_PREFIX}${textureName}`;\n  const sizeName = `${SIZE_UNIFORM_PREFIX}${textureName}`;\n  const uniformDeclerations = `\\\n  uniform sampler2D ${samplerName};\n  uniform vec2 ${sizeName};`;\n  return {samplerName, sizeName, uniformDeclerations};\n}\n\n// Return size (float, vec2 etc) of a given varying, null if doens't exist.\nexport function getVaryingType(line, varying) {\n  const qualaiferDetails = getQualifierDetails(line, ['varying', 'out']);\n  if (!qualaiferDetails) {\n    return null;\n  }\n  return qualaiferDetails.name === varying ? qualaiferDetails.type : null;\n}\n\n// build required definitions, sample instructions for each texture attribute\nexport function processAttributeDefinition(line, textureMap) {\n  const samplerTextureMap = {};\n  const attributeData = getAttributeDefinition(line);\n  if (!attributeData) {\n    return null;\n  }\n  const {type, name} = attributeData;\n  if (name && textureMap[name]) {\n    // eslint-disable-next-line no-useless-escape\n    const updatedLine = `\\// ${line} => Replaced by Transform with a sampler`;\n    const {samplerName, sizeName, uniformDeclerations} = getSamplerDeclerations(name);\n\n    const channels = typeToChannelSuffix(type);\n    const sampleInstruction = `  ${type} ${name} = transform_getInput(${samplerName}, ${sizeName}).${channels};\\n`;\n\n    samplerTextureMap[samplerName] = name;\n    const inject = {\n      'vs:#decl': uniformDeclerations,\n      'vs:#main-start': sampleInstruction\n    };\n\n    // samplerNameMap\n    return {\n      // update vertex shader line.\n      updatedLine,\n      // inject object with sampler instructions.\n      inject,\n      // sampler name to texture name map\n      samplerTextureMap\n    };\n  }\n  return null;\n}\n","import GL from '@luma.gl/constants';\nimport {\n  cloneTextureFrom,\n  readPixelsToArray,\n  getShaderVersion,\n  Buffer,\n  Texture2D,\n  Framebuffer\n} from '@luma.gl/webgl';\nimport {\n  _transform as transformModule,\n  getPassthroughFS,\n  typeToChannelCount,\n  combineInjects\n} from '@luma.gl/shadertools';\nimport {updateForTextures, getSizeUniforms} from './transform-shader-utils';\n\n// TODO: move these constants to transform-shader-utils\n// Texture parameters needed so sample can precisely pick pixel for given element id.\nconst SRC_TEX_PARAMETER_OVERRIDES = {\n  [GL.TEXTURE_MIN_FILTER]: GL.NEAREST,\n  [GL.TEXTURE_MAG_FILTER]: GL.NEAREST,\n  [GL.TEXTURE_WRAP_S]: GL.CLAMP_TO_EDGE,\n  [GL.TEXTURE_WRAP_T]: GL.CLAMP_TO_EDGE\n};\nconst FS_OUTPUT_VARIABLE = 'transform_output';\n\nexport default class TextureTransform {\n  constructor(gl, props = {}) {\n    this.gl = gl;\n    this.currentIndex = 0;\n    this._swapTexture = null;\n    this.targetTextureVarying = null;\n    this.targetTextureType = null;\n    this.samplerTextureMap = null;\n    this.bindings = []; // each element is an object : {sourceTextures, targetTexture, framebuffer}\n\n    this.resources = {}; // resources to be deleted\n\n    this._initialize(props);\n    Object.seal(this);\n  }\n\n  updateModelProps(props = {}) {\n    const updatedModelProps = this._processVertexShader(props);\n    return Object.assign({}, props, updatedModelProps);\n  }\n\n  getDrawOptions(opts = {}) {\n    const {sourceTextures, framebuffer, targetTexture} = this.bindings[this.currentIndex];\n\n    const attributes = Object.assign({}, opts.attributes);\n    const uniforms = Object.assign({}, opts.uniforms);\n    const parameters = Object.assign({}, opts.parameters);\n    let discard = opts.discard;\n\n    if (this.hasSourceTextures || this.hasTargetTexture) {\n      attributes.transform_elementID = this.elementIDBuffer;\n\n      for (const sampler in this.samplerTextureMap) {\n        const textureName = this.samplerTextureMap[sampler];\n        uniforms[sampler] = sourceTextures[textureName];\n      }\n      this._setSourceTextureParameters();\n      // get texture size uniforms\n      const sizeUniforms = getSizeUniforms({\n        sourceTextureMap: sourceTextures,\n        targetTextureVarying: this.targetTextureVarying,\n        targetTexture\n      });\n      Object.assign(uniforms, sizeUniforms);\n    }\n\n    if (this.hasTargetTexture) {\n      discard = false;\n      parameters.viewport = [0, 0, framebuffer.width, framebuffer.height];\n    }\n\n    return {attributes, framebuffer, uniforms, discard, parameters};\n  }\n\n  swap() {\n    if (this._swapTexture) {\n      this.currentIndex = this._getNextIndex();\n      return true;\n    }\n    return false;\n  }\n\n  // update source and/or feedbackBuffers\n  update(opts = {}) {\n    this._setupTextures(opts);\n  }\n\n  // returns current target texture\n  getTargetTexture() {\n    const {targetTexture} = this.bindings[this.currentIndex];\n    return targetTexture;\n  }\n\n  getData({packed = false} = {}) {\n    const {framebuffer} = this.bindings[this.currentIndex];\n    const pixels = readPixelsToArray(framebuffer);\n\n    if (!packed) {\n      return pixels;\n    }\n\n    // readPixels returns 4 elements for each pixel, pack the elements when requested\n    const ArrayType = pixels.constructor;\n    const channelCount = typeToChannelCount(this.targetTextureType);\n    const packedPixels = new ArrayType((pixels.length * channelCount) / 4);\n    let packCount = 0;\n    for (let i = 0; i < pixels.length; i += 4) {\n      for (let j = 0; j < channelCount; j++) {\n        packedPixels[packCount++] = pixels[i + j];\n      }\n    }\n    return packedPixels;\n  }\n\n  // returns current framebuffer object that is being used.\n  getFramebuffer() {\n    const currentResources = this.bindings[this.currentIndex];\n    return currentResources.framebuffer;\n  }\n\n  // Delete owned resources.\n  delete() {\n    if (this.ownTexture) {\n      this.ownTexture.delete();\n    }\n    if (this.elementIDBuffer) {\n      this.elementIDBuffer.delete();\n    }\n  }\n\n  // Private\n\n  _initialize(props = {}) {\n    const {_targetTextureVarying, _swapTexture} = props;\n    this._swapTexture = _swapTexture;\n    this.targetTextureVarying = _targetTextureVarying;\n    this.hasTargetTexture = _targetTextureVarying;\n    this._setupTextures(props);\n  }\n\n  // auto create target texture if requested\n  _createTargetTexture(props) {\n    const {sourceTextures, textureOrReference} = props;\n    if (textureOrReference instanceof Texture2D) {\n      return textureOrReference;\n    }\n    // 'targetTexture' is a reference souce texture.\n    const refTexture = sourceTextures[textureOrReference];\n    if (!refTexture) {\n      return null;\n    }\n\n    // save reference texture name, when corresponding source texture is updated\n    // we also update target texture.\n    this._targetRefTexName = textureOrReference;\n\n    return this._createNewTexture(refTexture);\n  }\n\n  _setupTextures(props = {}) {\n    const {_sourceTextures = {}, _targetTexture} = props;\n    const targetTexture = this._createTargetTexture({\n      sourceTextures: _sourceTextures,\n      textureOrReference: _targetTexture\n    });\n    this.hasSourceTextures =\n      this.hasSourceTextures || (_sourceTextures && Object.keys(_sourceTextures).length > 0);\n    this._updateBindings({sourceTextures: _sourceTextures, targetTexture});\n    if ('elementCount' in props) {\n      this._updateElementIDBuffer(props.elementCount);\n    }\n  }\n\n  _updateElementIDBuffer(elementCount) {\n    if (typeof elementCount !== 'number' || this.elementCount >= elementCount) {\n      return;\n    }\n    // NOTE: using float so this will work with GLSL 1.0 shaders.\n    const elementIds = new Float32Array(elementCount);\n    elementIds.forEach((_, index, array) => {\n      array[index] = index;\n    });\n    if (!this.elementIDBuffer) {\n      this.elementIDBuffer = new Buffer(this.gl, {\n        data: elementIds,\n        accessor: {size: 1}\n      });\n    } else {\n      this.elementIDBuffer.setData({data: elementIds});\n    }\n    this.elementCount = elementCount;\n  }\n\n  _updateBindings(opts) {\n    this.bindings[this.currentIndex] = this._updateBinding(this.bindings[this.currentIndex], opts);\n    if (this._swapTexture) {\n      const {sourceTextures, targetTexture} = this._swapTextures(this.bindings[this.currentIndex]);\n      const nextIndex = this._getNextIndex();\n      this.bindings[nextIndex] = this._updateBinding(this.bindings[nextIndex], {\n        sourceTextures,\n        targetTexture\n      });\n    }\n  }\n\n  _updateBinding(binding, opts) {\n    const {sourceTextures, targetTexture} = opts;\n    if (!binding) {\n      binding = {\n        sourceTextures: {},\n        targetTexture: null\n      };\n    }\n    Object.assign(binding.sourceTextures, sourceTextures);\n    if (targetTexture) {\n      binding.targetTexture = targetTexture;\n\n      const {width, height} = targetTexture;\n      const {framebuffer} = binding;\n      if (framebuffer) {\n        // First update texture without re-sizing attachments\n        framebuffer.update({\n          attachments: {[GL.COLOR_ATTACHMENT0]: targetTexture},\n          resizeAttachments: false\n        });\n        // Resize to new taget texture size\n        framebuffer.resize({width, height});\n      } else {\n        binding.framebuffer = new Framebuffer(this.gl, {\n          id: `${this.id || 'transform'}-framebuffer`,\n          width,\n          height,\n          attachments: {\n            [GL.COLOR_ATTACHMENT0]: targetTexture\n          }\n        });\n      }\n    }\n    return binding;\n  }\n\n  // set texture filtering parameters on source textures.\n  _setSourceTextureParameters() {\n    const index = this.currentIndex;\n    const {sourceTextures} = this.bindings[index];\n    for (const name in sourceTextures) {\n      sourceTextures[name].setParameters(SRC_TEX_PARAMETER_OVERRIDES);\n    }\n  }\n\n  _swapTextures(opts) {\n    if (!this._swapTexture) {\n      return null;\n    }\n    const sourceTextures = Object.assign({}, opts.sourceTextures);\n    sourceTextures[this._swapTexture] = opts.targetTexture;\n\n    const targetTexture = opts.sourceTextures[this._swapTexture];\n\n    return {sourceTextures, targetTexture};\n  }\n\n  // Create a buffer and add to list of buffers to be deleted.\n  _createNewTexture(refTexture) {\n    const texture = cloneTextureFrom(refTexture, {\n      parameters: {\n        [GL.TEXTURE_MIN_FILTER]: GL.NEAREST,\n        [GL.TEXTURE_MAG_FILTER]: GL.NEAREST,\n        [GL.TEXTURE_WRAP_S]: GL.CLAMP_TO_EDGE,\n        [GL.TEXTURE_WRAP_T]: GL.CLAMP_TO_EDGE\n      },\n      pixelStore: {\n        [GL.UNPACK_FLIP_Y_WEBGL]: false\n      }\n    });\n\n    // thre can only be one target texture\n    if (this.ownTexture) {\n      this.ownTexture.delete();\n    }\n    this.ownTexture = texture;\n\n    return texture;\n  }\n\n  _getNextIndex() {\n    return (this.currentIndex + 1) % 2;\n  }\n\n  // build and return shader releated parameters\n  _processVertexShader(props = {}) {\n    const {sourceTextures, targetTexture} = this.bindings[this.currentIndex];\n    const {vs, uniforms, targetTextureType, inject, samplerTextureMap} = updateForTextures({\n      vs: props.vs,\n      sourceTextureMap: sourceTextures,\n      targetTextureVarying: this.targetTextureVarying,\n      targetTexture\n    });\n    const combinedInject = combineInjects([props.inject || {}, inject]);\n    this.targetTextureType = targetTextureType;\n    this.samplerTextureMap = samplerTextureMap;\n    const fs =\n      props._fs ||\n      getPassthroughFS({\n        version: getShaderVersion(vs),\n        input: this.targetTextureVarying,\n        inputType: targetTextureType,\n        output: FS_OUTPUT_VARIABLE\n      });\n    const modules =\n      this.hasSourceTextures || this.targetTextureVarying\n        ? [transformModule].concat(props.modules || [])\n        : props.modules;\n    return {vs, fs, modules, uniforms, inject: combinedInject};\n  }\n}\n","import GL from '@luma.gl/constants';\nimport {getPassthroughFS} from '@luma.gl/shadertools';\nimport BufferTransform from './buffer-transform';\nimport TextureTransform from './texture-transform';\n\nimport {isWebGL2, getShaderVersion} from '@luma.gl/webgl';\nimport {assert, isObjectEmpty} from '../../utils';\nimport Model from '../model';\n\n// takes source and target buffers/textures and setsup the pipeline\nexport default class Transform {\n  static isSupported(gl) {\n    // TODO : differentiate writting to buffer vs not\n    return isWebGL2(gl);\n  }\n\n  constructor(gl, props = {}) {\n    this.gl = gl;\n    this.model = null;\n    this.elementCount = 0;\n    this.bufferTransform = null;\n    this.textureTransform = null;\n    this.elementIDBuffer = null;\n    this._initialize(props);\n    Object.seal(this);\n  }\n\n  // Delete owned resources.\n  delete() {\n    const {model, bufferTransform, textureTransform} = this;\n    if (model) {\n      model.delete();\n    }\n    if (bufferTransform) {\n      bufferTransform.delete();\n    }\n    if (textureTransform) {\n      textureTransform.delete();\n    }\n  }\n\n  // Run one transform loop.\n  run(opts = {}) {\n    const {clearRenderTarget = true} = opts;\n\n    const updatedOpts = this._updateDrawOptions(opts);\n\n    if (clearRenderTarget && updatedOpts.framebuffer) {\n      updatedOpts.framebuffer.clear({color: true});\n    }\n\n    this.model.transform(updatedOpts);\n  }\n\n  // swap resources if a map is provided\n  swap() {\n    let swapped = false;\n    const resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);\n    for (const resourceTransform of resourceTransforms) {\n      swapped = swapped || resourceTransform.swap();\n    }\n    assert(swapped, 'Nothing to swap');\n  }\n\n  // Return Buffer object for given varying name.\n  getBuffer(varyingName = null) {\n    return this.bufferTransform && this.bufferTransform.getBuffer(varyingName);\n  }\n\n  // Return data either from Buffer or from Texture\n  getData(opts = {}) {\n    const resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);\n    for (const resourceTransform of resourceTransforms) {\n      const data = resourceTransform.getData(opts);\n      if (data) {\n        return data;\n      }\n    }\n    return null;\n  }\n\n  // Return framebuffer object if rendering to textures\n  getFramebuffer() {\n    return this.textureTransform && this.textureTransform.getFramebuffer();\n  }\n\n  // Update some or all buffer/texture bindings.\n  update(opts = {}) {\n    if (opts.elementCount) {\n      this.model.setVertexCount(opts.elementCount);\n    }\n    const resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);\n    for (const resourceTransform of resourceTransforms) {\n      resourceTransform.update(opts);\n    }\n  }\n\n  // Private\n\n  _initialize(props = {}) {\n    const {gl} = this;\n    this._buildResourceTransforms(gl, props);\n\n    props = this._updateModelProps(props);\n    this.model = new Model(\n      gl,\n      Object.assign({}, props, {\n        fs: props.fs || getPassthroughFS({version: getShaderVersion(props.vs)}),\n        id: props.id || 'transform-model',\n        drawMode: props.drawMode || GL.POINTS,\n        vertexCount: props.elementCount\n      })\n    );\n\n    /* eslint-disable no-unused-expressions */\n    this.bufferTransform && this.bufferTransform.setupResources({model: this.model});\n    /* eslint-enable no-unused-expressions */\n  }\n\n  _updateModelProps(props) {\n    let updatedProps = Object.assign({}, props);\n    const resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);\n    for (const resourceTransform of resourceTransforms) {\n      updatedProps = resourceTransform.updateModelProps(updatedProps);\n    }\n    return updatedProps;\n  }\n\n  _buildResourceTransforms(gl, props) {\n    if (canCreateBufferTransform(props)) {\n      this.bufferTransform = new BufferTransform(gl, props);\n    }\n    if (canCreateTextureTransform(props)) {\n      this.textureTransform = new TextureTransform(gl, props);\n    }\n    assert(\n      this.bufferTransform || this.textureTransform,\n      'must provide source/feedback buffers or source/target textures'\n    );\n  }\n\n  _updateDrawOptions(opts) {\n    let updatedOpts = Object.assign({}, opts);\n    const resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);\n    for (const resourceTransform of resourceTransforms) {\n      updatedOpts = Object.assign(updatedOpts, resourceTransform.getDrawOptions(updatedOpts));\n    }\n    return updatedOpts;\n  }\n}\n\n// Helper Methods\n\nfunction canCreateBufferTransform(props) {\n  if (\n    !isObjectEmpty(props.sourceBuffers) ||\n    !isObjectEmpty(props.feedbackBuffers) ||\n    (props.varyings && props.varyings.length > 0)\n  ) {\n    return true;\n  }\n  return false;\n}\n\nfunction canCreateTextureTransform(props) {\n  if (\n    !isObjectEmpty(props._sourceTextures) ||\n    props._targetTexture ||\n    props._targetTextureVarying\n  ) {\n    return true;\n  }\n\n  return false;\n}\n","/* global window */\nimport {\n  AnimationLoop,\n  Buffer,\n  Model,\n  picking,\n  Transform,\n  isWebGL2,\n  readPixelsToArray\n} from '@luma.gl/core';\nimport {cssToDevicePixels} from '@luma.gl/webgl';\nimport {Log} from 'probe.gl';\n\nconst RED = new Uint8Array([255, 0, 0, 255]);\n\n/* eslint-disable max-len */\nconst INFO_HTML = `\n<p>\n  Instanced triangles animated on the GPU using a luma.gl <code>Transform</code> object.\n\n  This is a port of an example from\n  <a href=\"https://github.com/WebGLSamples/WebGL2Samples/blob/master/samples/transform_feedback_instanced.html\">\n    WebGL2Samples\n  </a>\n`;\n/* eslint-enable max-len */\n\n// Text to be displayed on environments when this demos is not supported.\nconst ALT_TEXT = \"THIS DEMO REQUIRES WEBGL2, BUT YOUR BROWSER DOESN'T SUPPORT IT\";\n\nconst EMIT_VS = `\\\n#version 300 es\n#define OFFSET_LOCATION 0\n#define ROTATION_LOCATION 1\n\n#define M_2PI 6.28318530718\n\n// We simulate the wandering of agents using transform feedback in this vertex shader\n// The simulation goes like this:\n// Assume there's a circle in front of the agent whose radius is WANDER_CIRCLE_R\n// the origin of which has a offset to the agent's pivot point, which is WANDER_CIRCLE_OFFSET\n// Each frame we pick a random point on this circle\n// And the agent moves MOVE_DELTA toward this target point\n// We also record the rotation facing this target point, so it will be the base rotation\n// for our next frame, which means the WANDER_CIRCLE_OFFSET vector will be on this direction\n// Thus we fake a smooth wandering behavior\n\n#define MAP_HALF_LENGTH 1.01\n#define WANDER_CIRCLE_R 0.01\n#define WANDER_CIRCLE_OFFSET 0.04\n#define MOVE_DELTA 0.001\nprecision highp float;\nprecision highp int;\nuniform float u_time;\nlayout(location = OFFSET_LOCATION) in vec2 a_offset;\nlayout(location = ROTATION_LOCATION) in float a_rotation;\nout vec2 v_offset;\nout float v_rotation;\n\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvoid main()\n{\n    float theta = M_2PI * rand(vec2(u_time, a_rotation + a_offset.x + a_offset.y));\n    float cos_r = cos(a_rotation);\n    float sin_r = sin(a_rotation);\n    mat2 rot = mat2(\n        cos_r, sin_r,\n        -sin_r, cos_r\n    );\n\n    vec2 p = WANDER_CIRCLE_R * vec2(cos(theta), sin(theta)) + vec2(WANDER_CIRCLE_OFFSET, 0.0);\n    vec2 move = normalize(rot * p);\n    v_rotation = atan(move.y, move.x);\n    v_offset = a_offset + MOVE_DELTA * move;\n\n    // wrapping at edges\n    v_offset = vec2 (\n        v_offset.x > MAP_HALF_LENGTH ? - MAP_HALF_LENGTH :\n          ( v_offset.x < - MAP_HALF_LENGTH ? MAP_HALF_LENGTH : v_offset.x ) ,\n        v_offset.y > MAP_HALF_LENGTH ? - MAP_HALF_LENGTH :\n          ( v_offset.y < - MAP_HALF_LENGTH ? MAP_HALF_LENGTH : v_offset.y )\n        );\n\n    gl_Position = vec4(v_offset, 0.0, 1.0);\n}\n`;\n\nconst DRAW_VS = `\\\n#version 300 es\n#define OFFSET_LOCATION 0\n#define ROTATION_LOCATION 1\n#define POSITION_LOCATION 2\n#define COLOR_LOCATION 3\nprecision highp float;\nprecision highp int;\nlayout(location = POSITION_LOCATION) in vec2 a_position;\nlayout(location = ROTATION_LOCATION) in float a_rotation;\nlayout(location = OFFSET_LOCATION) in vec2 a_offset;\nlayout(location = COLOR_LOCATION) in vec3 a_color;\nin vec2 instancePickingColors;\nout vec3 v_color;\nvoid main()\n{\n    v_color = a_color;\n\n    float cos_r = cos(a_rotation);\n    float sin_r = sin(a_rotation);\n    mat2 rot = mat2(\n        cos_r, sin_r,\n        -sin_r, cos_r\n    );\n    gl_Position = vec4(rot * a_position + a_offset, 0.0, 1.0);\n    picking_setPickingColor(vec3(0., instancePickingColors));\n}\n`;\n\nconst DRAW_FS = `\\\n#version 300 es\n#define ALPHA 0.9\nprecision highp float;\nprecision highp int;\nin vec3 v_color;\nout vec4 color;\nvoid main()\n{\n    color = vec4(v_color * ALPHA, ALPHA);\n    color = picking_filterColor(color);\n}\n`;\n\nconst NUM_INSTANCES = 1000;\nconst log = new Log({id: 'transform'}).enable();\n\n// TODO PIKCING TEMPORARILY DISABLED\nlet pickPosition = [0, 0];\n\nfunction mousemove(e) {\n  pickPosition = [e.offsetX, e.offsetY];\n}\n\nfunction mouseleave(e) {\n  pickPosition = null;\n}\n\nexport default class AppAnimationLoop extends AnimationLoop {\n  static getInfo() {\n    return INFO_HTML;\n  }\n\n  constructor(props = {}) {\n    super(Object.assign(props, {createFramebuffer: true}));\n    // Default value is true, so GL context is always created to verify wheter it is WebGL2 or not.\n    this.isDemoSupported = true;\n  }\n  /* eslint-disable max-statements */\n  onInitialize({canvas, gl}) {\n    this.isDemoSupported = isWebGL2(gl);\n    if (!this.isDemoSupported) {\n      log.error(ALT_TEXT)();\n      return {};\n    }\n    gl.canvas.addEventListener('mousemove', mousemove);\n    gl.canvas.addEventListener('mouseleave', mouseleave);\n\n    // -- Initialize data\n    const trianglePositions = new Float32Array([0.015, 0.0, -0.01, 0.01, -0.01, -0.01]);\n\n    const instanceOffsets = new Float32Array(NUM_INSTANCES * 2);\n    const instanceRotations = new Float32Array(NUM_INSTANCES);\n    const instanceColors = new Float32Array(NUM_INSTANCES * 3);\n    const pickingColors = new Uint8ClampedArray(NUM_INSTANCES * 2);\n\n    for (let i = 0; i < NUM_INSTANCES; ++i) {\n      instanceOffsets[i * 2] = Math.random() * 2.0 - 1.0;\n      instanceOffsets[i * 2 + 1] = Math.random() * 2.0 - 1.0;\n\n      instanceRotations[i] = Math.random() * 2 * Math.PI;\n\n      const randValue = Math.random();\n      if (randValue > 0.5) {\n        instanceColors[i * 3 + 1] = 1.0;\n        instanceColors[i * 3 + 2] = 1.0;\n      } else {\n        instanceColors[i * 3] = 1.0;\n        instanceColors[i * 3 + 2] = 1.0;\n      }\n\n      pickingColors[i * 2] = Math.floor(i / 255);\n      pickingColors[i * 2 + 1] = i - 255 * pickingColors[i * 2];\n    }\n\n    const positionBuffer = new Buffer(gl, trianglePositions);\n    const colorBuffer = new Buffer(gl, instanceColors);\n    const offsetBuffer = new Buffer(gl, instanceOffsets);\n    const rotationBuffer = new Buffer(gl, instanceRotations);\n    const pickingColorBuffer = new Buffer(gl, pickingColors);\n\n    const renderModel = new Model(gl, {\n      id: 'RenderModel',\n      vs: DRAW_VS,\n      fs: DRAW_FS,\n      drawMode: gl.TRIANGLE_FAN,\n      vertexCount: 3,\n      isInstanced: true,\n      instanceCount: NUM_INSTANCES,\n      attributes: {\n        a_position: positionBuffer,\n        a_color: [colorBuffer, {divisor: 1}],\n        a_offset: [offsetBuffer, {divisor: 1}],\n        a_rotation: [rotationBuffer, {divisor: 1}],\n        instancePickingColors: [pickingColorBuffer, {divisor: 1}]\n      },\n      modules: [picking]\n    });\n\n    const transform = new Transform(gl, {\n      vs: EMIT_VS,\n      elementCount: NUM_INSTANCES,\n      sourceBuffers: {\n        a_offset: offsetBuffer,\n        a_rotation: rotationBuffer\n      },\n      feedbackMap: {\n        a_offset: 'v_offset',\n        a_rotation: 'v_rotation'\n      }\n    });\n\n    return {\n      positionBuffer,\n      rotationBuffer,\n      colorBuffer,\n      offsetBuffer,\n      renderModel,\n      transform\n    };\n  }\n  /* eslint-enable max-statements */\n\n  onRender({\n    gl,\n    width,\n    height,\n    renderModel,\n    positionBuffer,\n    colorBuffer,\n    transform,\n    framebuffer,\n    useDevicePixels,\n    time\n  }) {\n    if (!this.isDemoSupported) {\n      return;\n    }\n    transform.run({\n      uniforms: {\n        u_time: time\n      }\n    });\n\n    transform.swap();\n\n    const offsetBuffer = transform.getBuffer('v_offset');\n    const rotationBuffer = transform.getBuffer('v_rotation');\n\n    offsetBuffer.setAccessor({divisor: 1});\n    rotationBuffer.setAccessor({divisor: 1});\n\n    renderModel.clear({color: [0.0, 0.0, 0.0, 1.0], depth: true});\n    renderModel.draw({\n      attributes: {\n        a_offset: offsetBuffer,\n        a_rotation: rotationBuffer\n      },\n      parameters: {\n        blend: true,\n        blendFunc: [gl.SRC_ALPHA, gl.ONE]\n      }\n    });\n\n    offsetBuffer.setAccessor({divisor: 0});\n    rotationBuffer.setAccessor({divisor: 0});\n\n    if (pickPosition) {\n      // use the center pixel location in device pixel range\n      const devicePixels = cssToDevicePixels(gl, pickPosition);\n      const deviceX = devicePixels.x + Math.floor(devicePixels.width / 2);\n      const deviceY = devicePixels.y + Math.floor(devicePixels.height / 2);\n\n      pickInstance(gl, deviceX, deviceY, renderModel, framebuffer);\n    }\n  }\n\n  onFinalize({renderModel, transform}) {\n    if (renderModel) {\n      renderModel.delete();\n    }\n    if (transform) {\n      transform.delete();\n    }\n  }\n\n  isSupported() {\n    return this.isDemoSupported;\n  }\n\n  getAltText() {\n    return ALT_TEXT;\n  }\n}\n\nfunction pickInstance(gl, pickX, pickY, model, framebuffer) {\n  framebuffer.clear({color: true, depth: true});\n  // Render picking colors\n  /* eslint-disable camelcase */\n  model.setUniforms({picking_uActive: 1});\n  model.draw({framebuffer});\n  model.setUniforms({picking_uActive: 0});\n\n  const color = readPixelsToArray(framebuffer, {\n    sourceX: pickX,\n    sourceY: pickY,\n    sourceWidth: 1,\n    sourceHeight: 1,\n    sourceFormat: gl.RGBA,\n    sourceType: gl.UNSIGNED_BYTE\n  });\n\n  if (color[0] + color[1] + color[2] > 0) {\n    model.updateModuleSettings({\n      pickingSelectedColor: color,\n      pickingHighlightColor: RED\n    });\n  } else {\n    model.updateModuleSettings({\n      pickingSelectedColor: null\n    });\n  }\n}\n\n/* global window */\nif (typeof window !== 'undefined' && !window.website) {\n  const animationLoop = new AppAnimationLoop();\n  animationLoop.start();\n}\n","import React from 'react';\nimport AnimationLoopExamplePage from '../../src/components/animation-loop-example-page';\nimport AnimationLoop from '../../../examples/core/transform/app';\n\nexport default class Example extends React.Component {\n  render() {\n    return (\n      <AnimationLoopExamplePage AnimationLoop={AnimationLoop} exampleConfig={this.props.pageContext.exampleConfig} />\n    );\n  }\n}\n","'use strict';\n\nrequire(\"core-js/modules/es6.array.filter\");\n\nrequire(\"core-js/modules/es6.array.for-each\");\n\nrequire(\"core-js/modules/es6.set\");\n\nrequire(\"core-js/modules/es6.regexp.to-string\");\n\nrequire(\"core-js/modules/es6.date.to-string\");\n\nrequire(\"core-js/modules/es7.array.includes\");\n\nrequire(\"core-js/modules/es6.string.includes\");\n\nrequire(\"core-js/modules/es6.date.now\");\n\nrequire(\"core-js/modules/web.dom.iterable\");\n\nrequire(\"core-js/modules/es6.array.iterator\");\n\nrequire(\"core-js/modules/es6.object.to-string\");\n\nrequire(\"core-js/modules/es6.string.iterator\");\n\nrequire(\"core-js/modules/es6.map\");\n\nrequire(\"core-js/modules/es7.symbol.async-iterator\");\n\nrequire(\"core-js/modules/es6.symbol\");\n\nrequire(\"core-js/modules/es6.object.define-property\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n}; // Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n\nvar isBrowser = typeof window !== 'undefined' && window.addEventListener;\nvar timers = new Map();\n/**\n * Ready check for Seer initialization\n *\n * @returns {Boolean}\n */\n\nvar isReady = function isReady() {\n  return isBrowser && window.__SEER_INITIALIZED__;\n};\n/**\n * Utility method allowing to throttle a user action based on a key and a minimun delay.\n *\n * @param key {String} A unique key\n * @param delay {Number} The minimal delay to throttle\n * @returns {Boolean}\n */\n\n\nvar throttle = function throttle(key, delay) {\n  var time = timers.get(key);\n  var now = Date.now();\n\n  if (time && now - time < delay) {\n    return true;\n  }\n\n  timers.set(key, now);\n  return false;\n};\n\nvar replacer = function replacer(seen) {\n  return function (key, value) {\n    if (value && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && seen.has(value)) {\n      return;\n    }\n\n    seen.add(value);\n    var isArray = Object.prototype.toString.call(value).slice(8, -1).includes('Array');\n\n    if (isArray) {\n      return Array.prototype.slice.call(value, 0, 20);\n    }\n\n    return value;\n  };\n};\n/**\n * Low-level api leveraging window.postMessage\n *\n * @param type {String} The action type\n * @param payload {Any} The action payload\n */\n\n\nvar send = function send(type) {\n  var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (!isBrowser || !isReady()) {\n    return;\n  }\n\n  var seen = new Set();\n  var payload = JSON.stringify(data, replacer(seen));\n\n  try {\n    window.postMessage({\n      type: type,\n      payload: payload,\n      source: 'seer-agent'\n    }, '*');\n  } catch (e) {\n    if (throttle('seer-log', 2E3)) {\n      return;\n    }\n\n    console.log(e); // eslint-disable-line\n  }\n};\n\nvar listeners = new Map();\n\nvar listener = function listener(message) {\n  if (!message || !message.data || message.data.source !== 'seer-core') {\n    return;\n  }\n\n  var _message$data = message.data,\n      type = _message$data.type,\n      payload = _message$data.payload;\n  var typeListeners = listeners.get(type);\n\n  if (typeListeners) {\n    typeListeners.forEach(function (cb) {\n      return cb(payload);\n    });\n  }\n};\n/**\n * Initilize window listener. There will be only one for the whole process\n * to prevent too many registrations.\n *\n * This method will be called automatically if you use the `listenFor` method.\n */\n\n\nvar init = function init() {\n  if (!isBrowser || window.__SEER_LISTENER__) {\n    return;\n  }\n\n  window.addEventListener('message', listener);\n  window.__SEER_LISTENER__ = true;\n};\n/**\n * Clean listener. Can be useful in case you want to unregister upcoming events\n * or liberate memory.\n */\n\n\nvar clean = function clean() {\n  if (!isBrowser || !window.__SEER_LISTENER__) {\n    return;\n  }\n\n  window.removeEventListener('message', listener);\n  delete window.__SEER_LISTENER__;\n};\n/**\n * Create a listener that will be called upon events of the given key.\n *\n * @param key {String} The unique tab key\n * @param cb {Function} A callback that will receive the message payload\n */\n\n\nvar listenFor = function listenFor(type, cb) {\n  if (!isBrowser) {\n    return;\n  }\n\n  if (!type || !cb) {\n    throw new Error('Please provide a type and callback');\n  }\n\n  if (!listeners.has(type)) {\n    listeners.set(type, []);\n  }\n\n  if (!window.__SEER_LISTENER__) {\n    init();\n  }\n\n  listeners.get(type).push(cb);\n};\n/**\n * Remove an identity listener\n *\n * @param cb {Function} The callback to remove\n */\n\n\nvar removeListener = function removeListener(cb) {\n  listeners.forEach(function (typeListeners, key) {\n    listeners.set(key, typeListeners.filter(function (l) {\n      return l !== cb;\n    }));\n  });\n};\n/**\n * Creates a new indexed list.\n * It works by index to get O(1) accessing and performance.\n *\n * @param key {String} The key of the tab\n * @param data {Object} The indexed object\n */\n\n\nvar list = function list(key, data) {\n  return send('LIST', {\n    key: key,\n    data: data\n  });\n};\n/**\n * Creates an element in the indexed list, based on the itemKey.\n *\n * @param key {String} The key of the tab\n * @param itemKey {String} The key of the item\n * @param data {Any} The value of the item\n */\n\n\nvar listItem = function listItem(key, itemKey) {\n  var data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  return send('LIST_ITEM', {\n    key: key,\n    itemKey: itemKey,\n    data: data\n  });\n};\n/**\n * Update an item property, can be deeply nested.\n *\n * @param key {String} The key of the tab\n * @param itemKey {String} The key of the item\n * @param path {String} The path of the variable you want to update\n * @param data {Object} The new value\n */\n\n\nvar updateItem = function updateItem(key, itemKey, path, data) {\n  return send('UPDATE_ITEM', {\n    key: key,\n    itemKey: itemKey,\n    path: path,\n    data: data\n  });\n};\n/**\n * Similar to updateItem, but allows to pass an array with {path,data} pairs for\n * multiple update of the same item without having to send multiple messages.\n *\n * @param key {String} The key of the tab\n * @param itemKey {String} The key of the item\n * @param array {Array} The array of updates\n * @param array.path {String} The path for this update\n * @param array.data {Object} The value of this update\n */\n\n\nvar multiUpdate = function multiUpdate(key, itemKey, array) {\n  return send('MULTI_UPDATE_ITEM', {\n    key: key,\n    itemKey: itemKey,\n    array: array\n  });\n};\n/**\n * Remove a specific item in a specific tab.\n *\n * @param key {String} They key of the tab\n * @param itemKey {String} The key of the item\n */\n\n\nvar deleteItem = function deleteItem(key, itemKey) {\n  return send('DELETE_ITEM', {\n    key: key,\n    itemKey: itemKey\n  });\n};\n/**\n * Will create a log message to an item, that will be displayde with the current time.\n *\n * @param key {String} The key of the tab\n * @param itemKey {String} The key of the item\n * @param msg {String} The message to display\n */\n\n\nvar addLog = function addLog(key, itemKey, msg) {\n  return send('ADD_LOG', {\n    key: key,\n    itemKey: itemKey,\n    msg: msg\n  });\n};\n\nexports[\"default\"] = {\n  send: send,\n  throttle: throttle,\n  isReady: isReady,\n  list: list,\n  listItem: listItem,\n  updateItem: updateItem,\n  multiUpdate: multiUpdate,\n  deleteItem: deleteItem,\n  addLog: addLog,\n  listeners: listeners,\n  listenFor: listenFor,\n  removeListener: removeListener,\n  init: init,\n  clean: clean\n};","import {assert} from '../utils';\nconst FS100 = `void main() {gl_FragColor = vec4(0);}`;\nconst FS_GLES = `\\\nout vec4 transform_output;\nvoid main() {\n  transform_output = vec4(0);\n}`;\nconst FS300 = `#version 300 es\\n${FS_GLES}`;\n\n// Prase given glsl line and return qualifier details or null\nexport function getQualifierDetails(line, qualifiers) {\n  qualifiers = Array.isArray(qualifiers) ? qualifiers : [qualifiers];\n  const words = line.replace(/^\\s+/, '').split(/\\s+/);\n  // TODO add support for precession qualifiers (highp, mediump and lowp)\n  const [qualifier, type, definition] = words;\n  if (!qualifiers.includes(qualifier) || !type || !definition) {\n    return null;\n  }\n  const name = definition.split(';')[0];\n  return {qualifier, type, name};\n}\n\n// Given the shader version, input and output variable names,\n// builds and return a pass through fragment shader.\nexport function getPassthroughFS({version = 100, input, inputType, output} = {}) {\n  if (!input) {\n    if (version === 300) {\n      // Fast-path for WebGL 2.0\n      return FS300;\n    } else if (version > 300) {\n      // Use the supplied version for OpenGL/ES 3.2+\n      return `#version ${version}\\n${FS_GLES}`;\n    }\n    // Fast-path for WebGL 1.0\n    return FS100;\n  }\n  const outputValue = convertToVec4(input, inputType);\n  if (version >= 300) {\n    // If version is 300, assume WebGL 2.0\n    return `\\\n#version ${version} ${version === 300 ? 'es' : ''}\nin ${inputType} ${input};\nout vec4 ${output};\nvoid main() {\n  ${output} = ${outputValue};\n}`;\n  }\n  // WebGL 1.0\n  return `\\\nvarying ${inputType} ${input};\nvoid main() {\n  gl_FragColor = ${outputValue};\n}`;\n}\n\n// convert glsl type to suffix\nexport function typeToChannelSuffix(type) {\n  switch (type) {\n    case 'float':\n      return 'x';\n    case 'vec2':\n      return 'xy';\n    case 'vec3':\n      return 'xyz';\n    case 'vec4':\n      return 'xyzw';\n    default:\n      assert(false);\n      return null;\n  }\n}\n\n// convert glsl type to channel count\nexport function typeToChannelCount(type) {\n  switch (type) {\n    case 'float':\n      return 1;\n    case 'vec2':\n      return 2;\n    case 'vec3':\n      return 3;\n    case 'vec4':\n      return 4;\n    default:\n      assert(false);\n      return null;\n  }\n}\n\n// Returns glsl instruction for converting to vec4\nexport function convertToVec4(variable, type) {\n  switch (type) {\n    case 'float':\n      return `vec4(${variable}, 0.0, 0.0, 1.0)`;\n    case 'vec2':\n      return `vec4(${variable}, 0.0, 1.0)`;\n    case 'vec3':\n      return `vec4(${variable}, 1.0)`;\n    case 'vec4':\n      return variable;\n    default:\n      assert(false);\n      return null;\n  }\n}\n","const DEFAULT_HIGHLIGHT_COLOR = new Uint8Array([0, 255, 255, 255]);\n\nconst DEFAULT_MODULE_OPTIONS = {\n  pickingSelectedColor: null, //  Set to a picking color to visually highlight that item\n  pickingHighlightColor: DEFAULT_HIGHLIGHT_COLOR, // Color of visual highlight of \"selected\" item\n  pickingThreshold: 1.0,\n  pickingActive: false // Set to true when rendering to off-screen \"picking\" buffer\n};\n\n/* eslint-disable camelcase */\nfunction getUniforms(opts = DEFAULT_MODULE_OPTIONS) {\n  const uniforms = {};\n  if (opts.pickingSelectedColor !== undefined) {\n    if (opts.pickingSelectedColor === null) {\n      uniforms.picking_uSelectedColorValid = 0;\n    } else {\n      const selectedColor = [\n        opts.pickingSelectedColor[0],\n        opts.pickingSelectedColor[1],\n        opts.pickingSelectedColor[2]\n      ];\n      uniforms.picking_uSelectedColorValid = 1;\n      uniforms.picking_uSelectedColor = selectedColor;\n    }\n  }\n  if (opts.pickingHighlightColor !== undefined) {\n    uniforms.picking_uHighlightColor = opts.pickingHighlightColor;\n  }\n  // TODO - major hack - decide on normalization and remove\n  if (opts.pickingThreshold !== undefined) {\n    uniforms.picking_uThreshold = opts.pickingThreshold;\n  }\n  if (opts.pickingActive !== undefined) {\n    uniforms.picking_uActive = opts.pickingActive ? 1 : 0;\n  }\n  return uniforms;\n}\n\nconst vs = `\\\nuniform vec3 picking_uSelectedColor;\nuniform float picking_uThreshold;\nuniform bool picking_uSelectedColorValid;\n\nout vec4 picking_vRGBcolor_Aselected;\n\nconst float COLOR_SCALE = 1. / 255.;\n\nbool isVertexPicked(vec3 vertexColor) {\n  return\n    picking_uSelectedColorValid &&\n    abs(vertexColor.r - picking_uSelectedColor.r) < picking_uThreshold &&\n    abs(vertexColor.g - picking_uSelectedColor.g) < picking_uThreshold &&\n    abs(vertexColor.b - picking_uSelectedColor.b) < picking_uThreshold;\n}\n\nvoid picking_setPickingColor(vec3 pickingColor) {\n  // Do the comparison with selected item color in vertex shader as it should mean fewer compares\n  picking_vRGBcolor_Aselected.a =\n    float(isVertexPicked(pickingColor));\n\n  // Stores the picking color so that the fragment shader can render it during picking\n  picking_vRGBcolor_Aselected.rgb = pickingColor * COLOR_SCALE;\n}\n`;\n\nconst fs = `\\\nuniform bool picking_uActive; // true during rendering to offscreen picking buffer\nuniform vec3 picking_uSelectedColor;\nuniform vec4 picking_uHighlightColor;\n\nin vec4 picking_vRGBcolor_Aselected;\n\nconst float COLOR_SCALE = 1. / 255.;\n\n/*\n * Returns highlight color if this item is selected.\n */\nvec4 picking_filterHighlightColor(vec4 color) {\n  bool selected = bool(picking_vRGBcolor_Aselected.a);\n\n  if (selected) {\n    vec4 highLightColor = picking_uHighlightColor * COLOR_SCALE;\n\n    float highLightAlpha = highLightColor.a;\n    float blendedAlpha = highLightAlpha + color.a * (1.0 - highLightAlpha);\n    float highLightRatio = highLightAlpha / blendedAlpha;\n\n    vec3 blendedRGB = mix(color.rgb, highLightColor.rgb, highLightRatio);\n    return vec4(blendedRGB, blendedAlpha);\n  } else {\n    return color;\n  }\n}\n\n/*\n * Returns picking color if picking enabled else unmodified argument.\n */\nvec4 picking_filterPickingColor(vec4 color) {\n  vec3 pickingColor = picking_vRGBcolor_Aselected.rgb;\n  if (picking_uActive && length(pickingColor) < 0.001) {\n    discard;\n  }\n  return picking_uActive ? vec4(pickingColor, 1.0) : color;\n}\n\n/*\n * Returns picking color if picking is enabled if not\n * highlight color if this item is selected, otherwise unmodified argument.\n */\nvec4 picking_filterColor(vec4 color) {\n  vec4 highightColor = picking_filterHighlightColor(color);\n  return picking_filterPickingColor(highightColor);\n}\n\n`;\n\nexport default {\n  name: 'picking',\n  vs,\n  fs,\n  getUniforms\n};\n"],"sourceRoot":""}