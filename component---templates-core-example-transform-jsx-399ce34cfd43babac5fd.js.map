{"version":3,"sources":["webpack:///../modules/shadertools/src/utils/shader-utils.js","webpack:///../modules/core/src/lib/transform/buffer-transform.js","webpack:///../modules/webgl/src/glsl-utils/get-shader-version.js","webpack:///../modules/shadertools/src/modules/transform/transform.js","webpack:///../modules/core/src/lib/transform/transform-shader-utils.js","webpack:///../modules/core/src/lib/transform/texture-transform.js","webpack:///../modules/core/src/lib/transform/transform.js","webpack:///../examples/core/transform/app.js","webpack:///./templates/core/example-transform.jsx","webpack:///../modules/shadertools/src/modules/picking/picking.js"],"names":["FS100","FS_GLES","FS300","getQualifierDetails","line","qualifiers","Array","words","qualifier","type","definition","name","getPassthroughFS","version","input","inputType","output","outputValue","variable","assert","convertToVec4","typeToChannelSuffix","typeToChannelCount","BufferTransform","props","this","gl","currentIndex","feedbackMap","varyings","bindings","resources","_initialize","Object","setupResources","binding","_setupTransformFeedback","updateModelProps","getDrawOptions","opts","sourceBuffers","transformFeedback","attributes","swap","update","_setupBuffers","getBuffer","feedbackBuffers","bufferOrParams","varyingName","getData","buffer","delete","length","isWebGL2","_getFeedbackBuffers","bufferOrRef","sourceBuffer","byteLength","usage","accessor","_createNewBuffer","bufferName","_updateBindings","program","model","buffers","_updateBinding","_swapBuffers","nextIndex","dstName","_getNextIndex","getShaderVersion","source","v","parseInt","Number","vs","fs","SAMPLER_UNIFORM_PREFIX","SIZE_UNIFORM_PREFIX","VS_POS_VARIABLE","updateForTextures","sourceTextureMap","targetTextureVarying","targetTexture","sourceCount","targetTextureType","samplerTextureMap","updatedVs","finalInject","vsLines","updateVsLines","updated","attributeData","getAttributeDefinition","textureMap","updatedLine","textureName","samplerName","sizeName","uniformDeclerations","getSamplerDeclerations","channels","sampleInstruction","inject","processAttributeDefinition","combineInjects","qualaiferDetails","getVaryingType","SRC_TEX_PARAMETER_OVERRIDES","GL","TextureTransform","_swapTexture","updatedModelProps","_processVertexShader","sourceTextures","framebuffer","uniforms","parameters","discard","hasSourceTextures","sizeUniforms","width","height","getSizeUniforms","_setupTextures","getTargetTexture","packed","pixels","readPixelsToArray","ArrayType","channelCount","packedPixels","packCount","i","j","getFramebuffer","ownTexture","elementIDBuffer","_targetTextureVarying","hasTargetTexture","_createTargetTexture","textureOrReference","refTexture","_targetRefTexName","_sourceTextures","_targetTexture","_updateElementIDBuffer","elementCount","elementIds","Float32Array","array","setData","data","size","_swapTextures","attachments","resizeAttachments","id","_setSourceTextureParameters","index","_createNewTexture","texture","cloneTextureFrom","pixelStore","combinedInject","modules","Transform","bufferTransform","textureTransform","isSupported","run","clearRenderTarget","updatedOpts","_updateDrawOptions","color","transform","swapped","resourceTransform","setVertexCount","_buildResourceTransforms","_updateModelProps","drawMode","vertexCount","updatedProps","isObjectEmpty","canCreateBufferTransform","canCreateTextureTransform","RED","Uint8Array","ALT_TEXT","log","pickPosition","mousemove","e","mouseleave","AppAnimationLoop","createFramebuffer","getInfo","onInitialize","canvas","isDemoSupported","trianglePositions","instanceOffsets","NUM_INSTANCES","instanceRotations","instanceColors","pickingColors","Uint8ClampedArray","Math","positionBuffer","colorBuffer","offsetBuffer","rotationBuffer","pickingColorBuffer","renderModel","isInstanced","instanceCount","a_position","a_color","divisor","a_offset","a_rotation","instancePickingColors","picking","onRender","time","useDevicePixels","u_time","depth","blend","blendFunc","devicePixels","cssToDevicePixels","picking_uActive","sourceX","sourceY","sourceWidth","sourceHeight","sourceFormat","sourceType","UNSIGNED_BYTE","pickingSelectedColor","pickingHighlightColor","pickInstance","onFinalize","getAltText","AnimationLoop","window","animationLoop","Example","render","exampleConfig","pageContext","React","Component","DEFAULT_MODULE_OPTIONS","pickingThreshold","pickingActive","getUniforms","selectedColor"],"mappings":"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","file":"component---templates-core-example-transform-jsx-399ce34cfd43babac5fd.js","sourcesContent":["import {assert} from '../utils';\nconst FS100 = `void main() {gl_FragColor = vec4(0);}`;\nconst FS_GLES = `\\\nout vec4 transform_output;\nvoid main() {\n  transform_output = vec4(0);\n}`;\nconst FS300 = `#version 300 es\\n${FS_GLES}`;\n\n// Prase given glsl line and return qualifier details or null\nexport function getQualifierDetails(line, qualifiers) {\n  qualifiers = Array.isArray(qualifiers) ? qualifiers : [qualifiers];\n  const words = line.replace(/^\\s+/, '').split(/\\s+/);\n  // TODO add support for precession qualifiers (highp, mediump and lowp)\n  const [qualifier, type, definition] = words;\n  if (!qualifiers.includes(qualifier) || !type || !definition) {\n    return null;\n  }\n  const name = definition.split(';')[0];\n  return {qualifier, type, name};\n}\n\n// Given the shader version, input and output variable names,\n// builds and return a pass through fragment shader.\nexport function getPassthroughFS({version = 100, input, inputType, output} = {}) {\n  if (!input) {\n    if (version === 300) {\n      // Fast-path for WebGL 2.0\n      return FS300;\n    } else if (version > 300) {\n      // Use the supplied version for OpenGL/ES 3.2+\n      return `#version ${version}\\n${FS_GLES}`;\n    }\n    // Fast-path for WebGL 1.0\n    return FS100;\n  }\n  const outputValue = convertToVec4(input, inputType);\n  if (version >= 300) {\n    // If version is 300, assume WebGL 2.0\n    return `\\\n#version ${version} ${version === 300 ? 'es' : ''}\nin ${inputType} ${input};\nout vec4 ${output};\nvoid main() {\n  ${output} = ${outputValue};\n}`;\n  }\n  // WebGL 1.0\n  return `\\\nvarying ${inputType} ${input};\nvoid main() {\n  gl_FragColor = ${outputValue};\n}`;\n}\n\n// convert glsl type to suffix\nexport function typeToChannelSuffix(type) {\n  switch (type) {\n    case 'float':\n      return 'x';\n    case 'vec2':\n      return 'xy';\n    case 'vec3':\n      return 'xyz';\n    case 'vec4':\n      return 'xyzw';\n    default:\n      assert(false);\n      return null;\n  }\n}\n\n// convert glsl type to channel count\nexport function typeToChannelCount(type) {\n  switch (type) {\n    case 'float':\n      return 1;\n    case 'vec2':\n      return 2;\n    case 'vec3':\n      return 3;\n    case 'vec4':\n      return 4;\n    default:\n      assert(false);\n      return null;\n  }\n}\n\n// Returns glsl instruction for converting to vec4\nexport function convertToVec4(variable, type) {\n  switch (type) {\n    case 'float':\n      return `vec4(${variable}, 0.0, 0.0, 1.0)`;\n    case 'vec2':\n      return `vec4(${variable}, 0.0, 1.0)`;\n    case 'vec3':\n      return `vec4(${variable}, 1.0)`;\n    case 'vec4':\n      return variable;\n    default:\n      assert(false);\n      return null;\n  }\n}\n","import {isWebGL2, Buffer, TransformFeedback} from '@luma.gl/webgl';\nimport {assert} from '../../utils';\n\nexport default class BufferTransform {\n  constructor(gl, props = {}) {\n    this.gl = gl;\n    this.currentIndex = 0;\n    this.feedbackMap = {};\n    this.varyings = null; // varyings array\n    this.bindings = []; // each element is an object : {sourceBuffers, feedbackBuffers, transformFeedback}\n\n    this.resources = {}; // resources to be deleted\n\n    this._initialize(props);\n    Object.seal(this);\n  }\n\n  setupResources(opts) {\n    for (const binding of this.bindings) {\n      this._setupTransformFeedback(binding, opts);\n    }\n  }\n\n  updateModelProps(props = {}) {\n    const {varyings} = this;\n    if (varyings.length > 0) {\n      props = Object.assign({}, props, {varyings});\n    }\n    return props;\n  }\n\n  getDrawOptions(opts = {}) {\n    const binding = this.bindings[this.currentIndex];\n    const {sourceBuffers, transformFeedback} = binding;\n    const attributes = Object.assign({}, sourceBuffers, opts.attributes);\n\n    return {attributes, transformFeedback};\n  }\n\n  swap() {\n    if (this.feedbackMap) {\n      this.currentIndex = this._getNextIndex();\n      return true;\n    }\n    return false;\n  }\n\n  // update source and/or feedbackBuffers\n  update(opts = {}) {\n    this._setupBuffers(opts);\n  }\n\n  // returns current feedbackBuffer of given name\n  getBuffer(varyingName) {\n    const {feedbackBuffers} = this.bindings[this.currentIndex];\n    const bufferOrParams = varyingName ? feedbackBuffers[varyingName] : null;\n    if (!bufferOrParams) {\n      return null;\n    }\n    return bufferOrParams instanceof Buffer ? bufferOrParams : bufferOrParams.buffer;\n  }\n\n  getData({varyingName} = {}) {\n    const buffer = this.getBuffer(varyingName);\n    if (buffer) {\n      return buffer.getData();\n    }\n    return null;\n  }\n\n  // Delete owned resources.\n  delete() {\n    for (const name in this.resources) {\n      this.resources[name].delete();\n    }\n  }\n\n  // Private\n\n  _initialize(props = {}) {\n    this._setupBuffers(props);\n    this.varyings = props.varyings || Object.keys(this.bindings[this.currentIndex].feedbackBuffers);\n    if (this.varyings.length > 0) {\n      // if writting to buffers make sure it is WebGL2\n      assert(isWebGL2(this.gl));\n    }\n  }\n\n  // auto create feedback buffers if requested\n  _getFeedbackBuffers(props) {\n    const {sourceBuffers} = props;\n    const feedbackBuffers = {};\n    if (this.bindings[this.currentIndex]) {\n      // this gurantees a partial feedback buffer set doesn't update\n      // previously set buffers during auto creation mode.\n      Object.assign(feedbackBuffers, this.bindings[this.currentIndex].feedbackBuffers);\n    }\n    if (this.feedbackMap) {\n      // feedbackMap is defined as sourceBuffer as key and feedbackBuffer name as object\n      for (const sourceName in this.feedbackMap) {\n        const feedbackName = this.feedbackMap[sourceName];\n        feedbackBuffers[feedbackName] = sourceName;\n      }\n    }\n    Object.assign(feedbackBuffers, props.feedbackBuffers);\n    for (const bufferName in feedbackBuffers) {\n      const bufferOrRef = feedbackBuffers[bufferName];\n      if (typeof bufferOrRef === 'string' && sourceBuffers[bufferOrRef]) {\n        // Create new buffer with same layout and settings as source buffer\n        const sourceBuffer = sourceBuffers[bufferOrRef];\n        const {byteLength, usage, accessor} = sourceBuffer;\n        feedbackBuffers[bufferName] = this._createNewBuffer(bufferName, {\n          byteLength,\n          usage,\n          accessor\n        });\n      }\n    }\n\n    return feedbackBuffers;\n  }\n\n  _setupBuffers(props = {}) {\n    const {sourceBuffers = null} = props;\n    Object.assign(this.feedbackMap, props.feedbackMap);\n    const feedbackBuffers = this._getFeedbackBuffers(props);\n    this._updateBindings({sourceBuffers, feedbackBuffers});\n  }\n\n  _setupTransformFeedback(binding, {model}) {\n    const {program} = model;\n    binding.transformFeedback = new TransformFeedback(this.gl, {\n      program,\n      buffers: binding.feedbackBuffers\n    });\n  }\n\n  _updateBindings(opts) {\n    this.bindings[this.currentIndex] = this._updateBinding(this.bindings[this.currentIndex], opts);\n    if (this.feedbackMap) {\n      const {sourceBuffers, feedbackBuffers} = this._swapBuffers(this.bindings[this.currentIndex]);\n      const nextIndex = this._getNextIndex();\n      this.bindings[nextIndex] = this._updateBinding(this.bindings[nextIndex], {\n        sourceBuffers,\n        feedbackBuffers\n      });\n    }\n  }\n\n  _updateBinding(binding, opts) {\n    if (!binding) {\n      return {\n        sourceBuffers: Object.assign({}, opts.sourceBuffers),\n        feedbackBuffers: Object.assign({}, opts.feedbackBuffers)\n      };\n    }\n    Object.assign(binding.sourceBuffers, opts.sourceBuffers);\n    Object.assign(binding.feedbackBuffers, opts.feedbackBuffers);\n    if (binding.transformFeedback) {\n      binding.transformFeedback.setBuffers(binding.feedbackBuffers);\n    }\n    return binding;\n  }\n\n  _swapBuffers(opts) {\n    if (!this.feedbackMap) {\n      return null;\n    }\n    const sourceBuffers = Object.assign({}, opts.sourceBuffers);\n    const feedbackBuffers = Object.assign({}, opts.feedbackBuffers);\n    for (const srcName in this.feedbackMap) {\n      const dstName = this.feedbackMap[srcName];\n      sourceBuffers[srcName] = opts.feedbackBuffers[dstName];\n      feedbackBuffers[dstName] = opts.sourceBuffers[srcName];\n\n      // make sure the new destination buffer is a Buffer object\n      assert(feedbackBuffers[dstName] instanceof Buffer);\n    }\n    return {sourceBuffers, feedbackBuffers};\n  }\n\n  // Create a buffer and add to list of buffers to be deleted.\n  _createNewBuffer(name, opts) {\n    const buffer = new Buffer(this.gl, opts);\n    if (this.resources[name]) {\n      this.resources[name].delete();\n    }\n    this.resources[name] = buffer;\n    return buffer;\n  }\n\n  _getNextIndex() {\n    return (this.currentIndex + 1) % 2;\n  }\n}\n","// returns GLSL shader version of given shader string\nexport default function getShaderVersion(source) {\n  let version = 100;\n  const words = source.match(/[^\\s]+/g);\n  if (words.length >= 2 && words[0] === '#version') {\n    const v = parseInt(words[1], 10);\n    if (Number.isFinite(v)) {\n      version = v;\n    }\n  }\n  return version;\n}\n","// Private shader module used by `Transform`\n\nconst vs = `\\\nattribute float transform_elementID;\n\n// returns half of pixel size, used to move the pixel position to center of the pixel.\nvec2 transform_getPixelSizeHalf(vec2 size) {\n  return vec2(1.) / (2. * size);\n}\n\n// returns current elements pixel indeces [x, y],\n// where x ranges in [0 to texSize-1] and y ranges in [0 to texSize-1]\nvec2 transform_getPixelIndices(vec2 texSize, vec2 pixelSizeHalf) {\n  // Add safe offset (half of pixel height) before doing floor\n  float yIndex = floor((transform_elementID / texSize[0]) + pixelSizeHalf[1]);\n  float xIndex = transform_elementID - (yIndex * texSize[0]);\n  return vec2(xIndex, yIndex);\n}\n\n// returns current elementID's texture co-ordianate\nvec2 transform_getTexCoord(vec2 size) {\n  vec2 pixelSizeHalf = transform_getPixelSizeHalf(size);\n  vec2 indices = transform_getPixelIndices(size, pixelSizeHalf);\n  vec2 coord = indices / size + pixelSizeHalf;\n  return coord;\n}\n\n// returns current elementID's position\nvec2 transform_getPos(vec2 size) {\n  vec2 texCoord = transform_getTexCoord(size);\n  // Change from [0 1] range to [-1 1]\n  vec2 pos = (texCoord * (2.0, 2.0)) - (1., 1.);\n  return pos;\n}\n\n// returns current elementID's pixel value\nvec4 transform_getInput(sampler2D texSampler, vec2 size) {\n  vec2 texCoord = transform_getTexCoord(size);\n  vec4 textureColor = texture2D(texSampler, texCoord);\n  return textureColor;\n}\n`;\n\nexport default {\n  name: 'transform',\n  vs,\n  fs: null\n};\n","import {assert} from '../../utils';\nimport {combineInjects, getQualifierDetails, typeToChannelSuffix} from '@luma.gl/shadertools';\n\nconst SAMPLER_UNIFORM_PREFIX = 'transform_uSampler_';\nconst SIZE_UNIFORM_PREFIX = 'transform_uSize_';\nconst VS_POS_VARIABLE = 'transform_position';\n\n// Scan provided vertex shader\n// for each texture attribute, inject sampler instructions and build uniforms for sampler\n// for texture target, get varying type and inject position instruction\nexport function updateForTextures({vs, sourceTextureMap, targetTextureVarying, targetTexture}) {\n  const texAttributeNames = Object.keys(sourceTextureMap);\n  let sourceCount = texAttributeNames.length;\n  let targetTextureType = null;\n  const samplerTextureMap = {};\n  let updatedVs = vs;\n  let finalInject = {};\n\n  if (sourceCount > 0 || targetTextureVarying) {\n    const vsLines = updatedVs.split('\\n');\n    const updateVsLines = vsLines.slice();\n    vsLines.forEach((line, index, lines) => {\n      // TODO add early exit\n      if (sourceCount > 0) {\n        const updated = processAttributeDefinition(line, sourceTextureMap);\n        if (updated) {\n          const {updatedLine, inject} = updated;\n          updateVsLines[index] = updatedLine;\n          // sampleInstructions.push(sampleInstruction);\n          finalInject = combineInjects([finalInject, inject]);\n          Object.assign(samplerTextureMap, updated.samplerTextureMap);\n          sourceCount--;\n        }\n      }\n      if (targetTextureVarying && !targetTextureType) {\n        targetTextureType = getVaryingType(line, targetTextureVarying);\n      }\n    });\n\n    if (targetTextureVarying) {\n      assert(targetTexture);\n      const sizeName = `${SIZE_UNIFORM_PREFIX}${targetTextureVarying}`;\n\n      const uniformDeclaration = `uniform vec2 ${sizeName};\\n`;\n      const posInstructions = `\\\n     vec2 ${VS_POS_VARIABLE} = transform_getPos(${sizeName});\n     gl_Position = vec4(${VS_POS_VARIABLE}, 0, 1.);\\n`;\n      const inject = {\n        'vs:#decl': uniformDeclaration,\n        'vs:#main-start': posInstructions\n      };\n      finalInject = combineInjects([finalInject, inject]);\n    }\n    updatedVs = updateVsLines.join('\\n');\n  }\n  return {\n    // updated vertex shader (commented texture attribute definition)\n    vs: updatedVs,\n    // type (float, vec2, vec3 of vec4) target texture varying\n    targetTextureType,\n    // required vertex and fragment shader injects\n    inject: finalInject,\n    // map of sampler name to texture name, can be used to set attributes\n    // usefull when swapping textures, as source and destination texture change when swap is called.\n    samplerTextureMap\n  };\n}\n\n// builds and returns an object contaning size uniform for each texture\nexport function getSizeUniforms({sourceTextureMap, targetTextureVarying, targetTexture}) {\n  const uniforms = {};\n  let width;\n  let height;\n  if (targetTextureVarying) {\n    ({width, height} = targetTexture);\n    uniforms[`${SIZE_UNIFORM_PREFIX}${targetTextureVarying}`] = [width, height];\n  }\n  for (const textureName in sourceTextureMap) {\n    ({width, height} = sourceTextureMap[textureName]);\n    uniforms[`${SIZE_UNIFORM_PREFIX}${textureName}`] = [width, height];\n  }\n  return uniforms;\n}\n\n// Checks if provided line is defining an attribute, if so returns details otherwise null\nfunction getAttributeDefinition(line) {\n  return getQualifierDetails(line, ['attribute', 'in']);\n}\n\nfunction getSamplerDeclerations(textureName) {\n  const samplerName = `${SAMPLER_UNIFORM_PREFIX}${textureName}`;\n  const sizeName = `${SIZE_UNIFORM_PREFIX}${textureName}`;\n  const uniformDeclerations = `\\\n  uniform sampler2D ${samplerName};\n  uniform vec2 ${sizeName};`;\n  return {samplerName, sizeName, uniformDeclerations};\n}\n\n// Return size (float, vec2 etc) of a given varying, null if doens't exist.\nexport function getVaryingType(line, varying) {\n  const qualaiferDetails = getQualifierDetails(line, ['varying', 'out']);\n  if (!qualaiferDetails) {\n    return null;\n  }\n  return qualaiferDetails.name === varying ? qualaiferDetails.type : null;\n}\n\n// build required definitions, sample instructions for each texture attribute\nexport function processAttributeDefinition(line, textureMap) {\n  const samplerTextureMap = {};\n  const attributeData = getAttributeDefinition(line);\n  if (!attributeData) {\n    return null;\n  }\n  const {type, name} = attributeData;\n  if (name && textureMap[name]) {\n    // eslint-disable-next-line no-useless-escape\n    const updatedLine = `\\// ${line} => Replaced by Transform with a sampler`;\n    const {samplerName, sizeName, uniformDeclerations} = getSamplerDeclerations(name);\n\n    const channels = typeToChannelSuffix(type);\n    const sampleInstruction = `  ${type} ${name} = transform_getInput(${samplerName}, ${sizeName}).${channels};\\n`;\n\n    samplerTextureMap[samplerName] = name;\n    const inject = {\n      'vs:#decl': uniformDeclerations,\n      'vs:#main-start': sampleInstruction\n    };\n\n    // samplerNameMap\n    return {\n      // update vertex shader line.\n      updatedLine,\n      // inject object with sampler instructions.\n      inject,\n      // sampler name to texture name map\n      samplerTextureMap\n    };\n  }\n  return null;\n}\n","import GL from '@luma.gl/constants';\nimport {\n  cloneTextureFrom,\n  readPixelsToArray,\n  getShaderVersion,\n  Buffer,\n  Texture2D,\n  Framebuffer\n} from '@luma.gl/webgl';\nimport {\n  _transform as transformModule,\n  getPassthroughFS,\n  typeToChannelCount,\n  combineInjects\n} from '@luma.gl/shadertools';\nimport {updateForTextures, getSizeUniforms} from './transform-shader-utils';\n\n// TODO: move these constants to transform-shader-utils\n// Texture parameters needed so sample can precisely pick pixel for given element id.\nconst SRC_TEX_PARAMETER_OVERRIDES = {\n  [GL.TEXTURE_MIN_FILTER]: GL.NEAREST,\n  [GL.TEXTURE_MAG_FILTER]: GL.NEAREST,\n  [GL.TEXTURE_WRAP_S]: GL.CLAMP_TO_EDGE,\n  [GL.TEXTURE_WRAP_T]: GL.CLAMP_TO_EDGE\n};\nconst FS_OUTPUT_VARIABLE = 'transform_output';\n\nexport default class TextureTransform {\n  constructor(gl, props = {}) {\n    this.gl = gl;\n    this.currentIndex = 0;\n    this._swapTexture = null;\n    this.targetTextureVarying = null;\n    this.targetTextureType = null;\n    this.samplerTextureMap = null;\n    this.bindings = []; // each element is an object : {sourceTextures, targetTexture, framebuffer}\n\n    this.resources = {}; // resources to be deleted\n\n    this._initialize(props);\n    Object.seal(this);\n  }\n\n  updateModelProps(props = {}) {\n    const updatedModelProps = this._processVertexShader(props);\n    return Object.assign({}, props, updatedModelProps);\n  }\n\n  getDrawOptions(opts = {}) {\n    const {sourceTextures, framebuffer, targetTexture} = this.bindings[this.currentIndex];\n\n    const attributes = Object.assign({}, opts.attributes);\n    const uniforms = Object.assign({}, opts.uniforms);\n    const parameters = Object.assign({}, opts.parameters);\n    let discard = opts.discard;\n\n    if (this.hasSourceTextures || this.hasTargetTexture) {\n      attributes.transform_elementID = this.elementIDBuffer;\n\n      for (const sampler in this.samplerTextureMap) {\n        const textureName = this.samplerTextureMap[sampler];\n        uniforms[sampler] = sourceTextures[textureName];\n      }\n      this._setSourceTextureParameters();\n      // get texture size uniforms\n      const sizeUniforms = getSizeUniforms({\n        sourceTextureMap: sourceTextures,\n        targetTextureVarying: this.targetTextureVarying,\n        targetTexture\n      });\n      Object.assign(uniforms, sizeUniforms);\n    }\n\n    if (this.hasTargetTexture) {\n      discard = false;\n      parameters.viewport = [0, 0, framebuffer.width, framebuffer.height];\n    }\n\n    return {attributes, framebuffer, uniforms, discard, parameters};\n  }\n\n  swap() {\n    if (this._swapTexture) {\n      this.currentIndex = this._getNextIndex();\n      return true;\n    }\n    return false;\n  }\n\n  // update source and/or feedbackBuffers\n  update(opts = {}) {\n    this._setupTextures(opts);\n  }\n\n  // returns current target texture\n  getTargetTexture() {\n    const {targetTexture} = this.bindings[this.currentIndex];\n    return targetTexture;\n  }\n\n  getData({packed = false} = {}) {\n    const {framebuffer} = this.bindings[this.currentIndex];\n    const pixels = readPixelsToArray(framebuffer);\n\n    if (!packed) {\n      return pixels;\n    }\n\n    // readPixels returns 4 elements for each pixel, pack the elements when requested\n    const ArrayType = pixels.constructor;\n    const channelCount = typeToChannelCount(this.targetTextureType);\n    const packedPixels = new ArrayType((pixels.length * channelCount) / 4);\n    let packCount = 0;\n    for (let i = 0; i < pixels.length; i += 4) {\n      for (let j = 0; j < channelCount; j++) {\n        packedPixels[packCount++] = pixels[i + j];\n      }\n    }\n    return packedPixels;\n  }\n\n  // returns current framebuffer object that is being used.\n  getFramebuffer() {\n    const currentResources = this.bindings[this.currentIndex];\n    return currentResources.framebuffer;\n  }\n\n  // Delete owned resources.\n  delete() {\n    if (this.ownTexture) {\n      this.ownTexture.delete();\n    }\n    if (this.elementIDBuffer) {\n      this.elementIDBuffer.delete();\n    }\n  }\n\n  // Private\n\n  _initialize(props = {}) {\n    const {_targetTextureVarying, _swapTexture} = props;\n    this._swapTexture = _swapTexture;\n    this.targetTextureVarying = _targetTextureVarying;\n    this.hasTargetTexture = _targetTextureVarying;\n    this._setupTextures(props);\n  }\n\n  // auto create target texture if requested\n  _createTargetTexture(props) {\n    const {sourceTextures, textureOrReference} = props;\n    if (textureOrReference instanceof Texture2D) {\n      return textureOrReference;\n    }\n    // 'targetTexture' is a reference souce texture.\n    const refTexture = sourceTextures[textureOrReference];\n    if (!refTexture) {\n      return null;\n    }\n\n    // save reference texture name, when corresponding source texture is updated\n    // we also update target texture.\n    this._targetRefTexName = textureOrReference;\n\n    return this._createNewTexture(refTexture);\n  }\n\n  _setupTextures(props = {}) {\n    const {_sourceTextures = {}, _targetTexture} = props;\n    const targetTexture = this._createTargetTexture({\n      sourceTextures: _sourceTextures,\n      textureOrReference: _targetTexture\n    });\n    this.hasSourceTextures =\n      this.hasSourceTextures || (_sourceTextures && Object.keys(_sourceTextures).length > 0);\n    this._updateBindings({sourceTextures: _sourceTextures, targetTexture});\n    if ('elementCount' in props) {\n      this._updateElementIDBuffer(props.elementCount);\n    }\n  }\n\n  _updateElementIDBuffer(elementCount) {\n    if (typeof elementCount !== 'number' || this.elementCount >= elementCount) {\n      return;\n    }\n    // NOTE: using float so this will work with GLSL 1.0 shaders.\n    const elementIds = new Float32Array(elementCount);\n    elementIds.forEach((_, index, array) => {\n      array[index] = index;\n    });\n    if (!this.elementIDBuffer) {\n      this.elementIDBuffer = new Buffer(this.gl, {\n        data: elementIds,\n        accessor: {size: 1}\n      });\n    } else {\n      this.elementIDBuffer.setData({data: elementIds});\n    }\n    this.elementCount = elementCount;\n  }\n\n  _updateBindings(opts) {\n    this.bindings[this.currentIndex] = this._updateBinding(this.bindings[this.currentIndex], opts);\n    if (this._swapTexture) {\n      const {sourceTextures, targetTexture} = this._swapTextures(this.bindings[this.currentIndex]);\n      const nextIndex = this._getNextIndex();\n      this.bindings[nextIndex] = this._updateBinding(this.bindings[nextIndex], {\n        sourceTextures,\n        targetTexture\n      });\n    }\n  }\n\n  _updateBinding(binding, opts) {\n    const {sourceTextures, targetTexture} = opts;\n    if (!binding) {\n      binding = {\n        sourceTextures: {},\n        targetTexture: null\n      };\n    }\n    Object.assign(binding.sourceTextures, sourceTextures);\n    if (targetTexture) {\n      binding.targetTexture = targetTexture;\n\n      const {width, height} = targetTexture;\n      const {framebuffer} = binding;\n      if (framebuffer) {\n        // First update texture without re-sizing attachments\n        framebuffer.update({\n          attachments: {[GL.COLOR_ATTACHMENT0]: targetTexture},\n          resizeAttachments: false\n        });\n        // Resize to new taget texture size\n        framebuffer.resize({width, height});\n      } else {\n        binding.framebuffer = new Framebuffer(this.gl, {\n          id: `${this.id || 'transform'}-framebuffer`,\n          width,\n          height,\n          attachments: {\n            [GL.COLOR_ATTACHMENT0]: targetTexture\n          }\n        });\n      }\n    }\n    return binding;\n  }\n\n  // set texture filtering parameters on source textures.\n  _setSourceTextureParameters() {\n    const index = this.currentIndex;\n    const {sourceTextures} = this.bindings[index];\n    for (const name in sourceTextures) {\n      sourceTextures[name].setParameters(SRC_TEX_PARAMETER_OVERRIDES);\n    }\n  }\n\n  _swapTextures(opts) {\n    if (!this._swapTexture) {\n      return null;\n    }\n    const sourceTextures = Object.assign({}, opts.sourceTextures);\n    sourceTextures[this._swapTexture] = opts.targetTexture;\n\n    const targetTexture = opts.sourceTextures[this._swapTexture];\n\n    return {sourceTextures, targetTexture};\n  }\n\n  // Create a buffer and add to list of buffers to be deleted.\n  _createNewTexture(refTexture) {\n    const texture = cloneTextureFrom(refTexture, {\n      parameters: {\n        [GL.TEXTURE_MIN_FILTER]: GL.NEAREST,\n        [GL.TEXTURE_MAG_FILTER]: GL.NEAREST,\n        [GL.TEXTURE_WRAP_S]: GL.CLAMP_TO_EDGE,\n        [GL.TEXTURE_WRAP_T]: GL.CLAMP_TO_EDGE\n      },\n      pixelStore: {\n        [GL.UNPACK_FLIP_Y_WEBGL]: false\n      }\n    });\n\n    // thre can only be one target texture\n    if (this.ownTexture) {\n      this.ownTexture.delete();\n    }\n    this.ownTexture = texture;\n\n    return texture;\n  }\n\n  _getNextIndex() {\n    return (this.currentIndex + 1) % 2;\n  }\n\n  // build and return shader releated parameters\n  _processVertexShader(props = {}) {\n    const {sourceTextures, targetTexture} = this.bindings[this.currentIndex];\n    const {vs, uniforms, targetTextureType, inject, samplerTextureMap} = updateForTextures({\n      vs: props.vs,\n      sourceTextureMap: sourceTextures,\n      targetTextureVarying: this.targetTextureVarying,\n      targetTexture\n    });\n    const combinedInject = combineInjects([props.inject || {}, inject]);\n    this.targetTextureType = targetTextureType;\n    this.samplerTextureMap = samplerTextureMap;\n    const fs =\n      props._fs ||\n      getPassthroughFS({\n        version: getShaderVersion(vs),\n        input: this.targetTextureVarying,\n        inputType: targetTextureType,\n        output: FS_OUTPUT_VARIABLE\n      });\n    const modules =\n      this.hasSourceTextures || this.targetTextureVarying\n        ? [transformModule].concat(props.modules || [])\n        : props.modules;\n    return {vs, fs, modules, uniforms, inject: combinedInject};\n  }\n}\n","import GL from '@luma.gl/constants';\nimport {getPassthroughFS} from '@luma.gl/shadertools';\nimport BufferTransform from './buffer-transform';\nimport TextureTransform from './texture-transform';\n\nimport {isWebGL2, getShaderVersion} from '@luma.gl/webgl';\nimport {assert, isObjectEmpty} from '../../utils';\nimport Model from '../model';\n\n// takes source and target buffers/textures and setsup the pipeline\nexport default class Transform {\n  static isSupported(gl) {\n    // TODO : differentiate writting to buffer vs not\n    return isWebGL2(gl);\n  }\n\n  constructor(gl, props = {}) {\n    this.gl = gl;\n    this.model = null;\n    this.elementCount = 0;\n    this.bufferTransform = null;\n    this.textureTransform = null;\n    this.elementIDBuffer = null;\n    this._initialize(props);\n    Object.seal(this);\n  }\n\n  // Delete owned resources.\n  delete() {\n    const {model, bufferTransform, textureTransform} = this;\n    if (model) {\n      model.delete();\n    }\n    if (bufferTransform) {\n      bufferTransform.delete();\n    }\n    if (textureTransform) {\n      textureTransform.delete();\n    }\n  }\n\n  // Run one transform loop.\n  run(opts = {}) {\n    const {clearRenderTarget = true} = opts;\n\n    const updatedOpts = this._updateDrawOptions(opts);\n\n    if (clearRenderTarget && updatedOpts.framebuffer) {\n      updatedOpts.framebuffer.clear({color: true});\n    }\n\n    this.model.transform(updatedOpts);\n  }\n\n  // swap resources if a map is provided\n  swap() {\n    let swapped = false;\n    const resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);\n    for (const resourceTransform of resourceTransforms) {\n      swapped = swapped || resourceTransform.swap();\n    }\n    assert(swapped, 'Nothing to swap');\n  }\n\n  // Return Buffer object for given varying name.\n  getBuffer(varyingName = null) {\n    return this.bufferTransform && this.bufferTransform.getBuffer(varyingName);\n  }\n\n  // Return data either from Buffer or from Texture\n  getData(opts = {}) {\n    const resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);\n    for (const resourceTransform of resourceTransforms) {\n      const data = resourceTransform.getData(opts);\n      if (data) {\n        return data;\n      }\n    }\n    return null;\n  }\n\n  // Return framebuffer object if rendering to textures\n  getFramebuffer() {\n    return this.textureTransform && this.textureTransform.getFramebuffer();\n  }\n\n  // Update some or all buffer/texture bindings.\n  update(opts = {}) {\n    if (opts.elementCount) {\n      this.model.setVertexCount(opts.elementCount);\n    }\n    const resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);\n    for (const resourceTransform of resourceTransforms) {\n      resourceTransform.update(opts);\n    }\n  }\n\n  // Private\n\n  _initialize(props = {}) {\n    const {gl} = this;\n    this._buildResourceTransforms(gl, props);\n\n    props = this._updateModelProps(props);\n    this.model = new Model(\n      gl,\n      Object.assign({}, props, {\n        fs: props.fs || getPassthroughFS({version: getShaderVersion(props.vs)}),\n        id: props.id || 'transform-model',\n        drawMode: props.drawMode || GL.POINTS,\n        vertexCount: props.elementCount\n      })\n    );\n\n    /* eslint-disable no-unused-expressions */\n    this.bufferTransform && this.bufferTransform.setupResources({model: this.model});\n    /* eslint-enable no-unused-expressions */\n  }\n\n  _updateModelProps(props) {\n    let updatedProps = Object.assign({}, props);\n    const resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);\n    for (const resourceTransform of resourceTransforms) {\n      updatedProps = resourceTransform.updateModelProps(updatedProps);\n    }\n    return updatedProps;\n  }\n\n  _buildResourceTransforms(gl, props) {\n    if (canCreateBufferTransform(props)) {\n      this.bufferTransform = new BufferTransform(gl, props);\n    }\n    if (canCreateTextureTransform(props)) {\n      this.textureTransform = new TextureTransform(gl, props);\n    }\n    assert(\n      this.bufferTransform || this.textureTransform,\n      'must provide source/feedback buffers or source/target textures'\n    );\n  }\n\n  _updateDrawOptions(opts) {\n    let updatedOpts = Object.assign({}, opts);\n    const resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);\n    for (const resourceTransform of resourceTransforms) {\n      updatedOpts = Object.assign(updatedOpts, resourceTransform.getDrawOptions(updatedOpts));\n    }\n    return updatedOpts;\n  }\n}\n\n// Helper Methods\n\nfunction canCreateBufferTransform(props) {\n  if (\n    !isObjectEmpty(props.sourceBuffers) ||\n    !isObjectEmpty(props.feedbackBuffers) ||\n    (props.varyings && props.varyings.length > 0)\n  ) {\n    return true;\n  }\n  return false;\n}\n\nfunction canCreateTextureTransform(props) {\n  if (\n    !isObjectEmpty(props._sourceTextures) ||\n    props._targetTexture ||\n    props._targetTextureVarying\n  ) {\n    return true;\n  }\n\n  return false;\n}\n","/* global window */\nimport {\n  AnimationLoop,\n  Buffer,\n  Model,\n  picking,\n  Transform,\n  isWebGL2,\n  readPixelsToArray\n} from '@luma.gl/core';\nimport {cssToDevicePixels} from '@luma.gl/webgl';\nimport {Log} from 'probe.gl';\n\nconst RED = new Uint8Array([255, 0, 0, 255]);\n\n/* eslint-disable max-len */\nconst INFO_HTML = `\n<p>\n  Instanced triangles animated on the GPU using a luma.gl <code>Transform</code> object.\n\n  This is a port of an example from\n  <a href=\"https://github.com/WebGLSamples/WebGL2Samples/blob/master/samples/transform_feedback_instanced.html\">\n    WebGL2Samples\n  </a>\n`;\n/* eslint-enable max-len */\n\n// Text to be displayed on environments when this demos is not supported.\nconst ALT_TEXT = \"THIS DEMO REQUIRES WEBGL2, BUT YOUR BROWSER DOESN'T SUPPORT IT\";\n\nconst EMIT_VS = `\\\n#version 300 es\n#define OFFSET_LOCATION 0\n#define ROTATION_LOCATION 1\n\n#define M_2PI 6.28318530718\n\n// We simulate the wandering of agents using transform feedback in this vertex shader\n// The simulation goes like this:\n// Assume there's a circle in front of the agent whose radius is WANDER_CIRCLE_R\n// the origin of which has a offset to the agent's pivot point, which is WANDER_CIRCLE_OFFSET\n// Each frame we pick a random point on this circle\n// And the agent moves MOVE_DELTA toward this target point\n// We also record the rotation facing this target point, so it will be the base rotation\n// for our next frame, which means the WANDER_CIRCLE_OFFSET vector will be on this direction\n// Thus we fake a smooth wandering behavior\n\n#define MAP_HALF_LENGTH 1.01\n#define WANDER_CIRCLE_R 0.01\n#define WANDER_CIRCLE_OFFSET 0.04\n#define MOVE_DELTA 0.001\nprecision highp float;\nprecision highp int;\nuniform float u_time;\nlayout(location = OFFSET_LOCATION) in vec2 a_offset;\nlayout(location = ROTATION_LOCATION) in float a_rotation;\nout vec2 v_offset;\nout float v_rotation;\n\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvoid main()\n{\n    float theta = M_2PI * rand(vec2(u_time, a_rotation + a_offset.x + a_offset.y));\n    float cos_r = cos(a_rotation);\n    float sin_r = sin(a_rotation);\n    mat2 rot = mat2(\n        cos_r, sin_r,\n        -sin_r, cos_r\n    );\n\n    vec2 p = WANDER_CIRCLE_R * vec2(cos(theta), sin(theta)) + vec2(WANDER_CIRCLE_OFFSET, 0.0);\n    vec2 move = normalize(rot * p);\n    v_rotation = atan(move.y, move.x);\n    v_offset = a_offset + MOVE_DELTA * move;\n\n    // wrapping at edges\n    v_offset = vec2 (\n        v_offset.x > MAP_HALF_LENGTH ? - MAP_HALF_LENGTH :\n          ( v_offset.x < - MAP_HALF_LENGTH ? MAP_HALF_LENGTH : v_offset.x ) ,\n        v_offset.y > MAP_HALF_LENGTH ? - MAP_HALF_LENGTH :\n          ( v_offset.y < - MAP_HALF_LENGTH ? MAP_HALF_LENGTH : v_offset.y )\n        );\n\n    gl_Position = vec4(v_offset, 0.0, 1.0);\n}\n`;\n\nconst DRAW_VS = `\\\n#version 300 es\n#define OFFSET_LOCATION 0\n#define ROTATION_LOCATION 1\n#define POSITION_LOCATION 2\n#define COLOR_LOCATION 3\nprecision highp float;\nprecision highp int;\nlayout(location = POSITION_LOCATION) in vec2 a_position;\nlayout(location = ROTATION_LOCATION) in float a_rotation;\nlayout(location = OFFSET_LOCATION) in vec2 a_offset;\nlayout(location = COLOR_LOCATION) in vec3 a_color;\nin vec2 instancePickingColors;\nout vec3 v_color;\nvoid main()\n{\n    v_color = a_color;\n\n    float cos_r = cos(a_rotation);\n    float sin_r = sin(a_rotation);\n    mat2 rot = mat2(\n        cos_r, sin_r,\n        -sin_r, cos_r\n    );\n    gl_Position = vec4(rot * a_position + a_offset, 0.0, 1.0);\n    picking_setPickingColor(vec3(0., instancePickingColors));\n}\n`;\n\nconst DRAW_FS = `\\\n#version 300 es\n#define ALPHA 0.9\nprecision highp float;\nprecision highp int;\nin vec3 v_color;\nout vec4 color;\nvoid main()\n{\n    color = vec4(v_color * ALPHA, ALPHA);\n    color = picking_filterColor(color);\n}\n`;\n\nconst NUM_INSTANCES = 1000;\nconst log = new Log({id: 'transform'}).enable();\n\n// TODO PIKCING TEMPORARILY DISABLED\nlet pickPosition = [0, 0];\n\nfunction mousemove(e) {\n  pickPosition = [e.offsetX, e.offsetY];\n}\n\nfunction mouseleave(e) {\n  pickPosition = null;\n}\n\nexport default class AppAnimationLoop extends AnimationLoop {\n  static getInfo() {\n    return INFO_HTML;\n  }\n\n  constructor(props = {}) {\n    super(Object.assign(props, {createFramebuffer: true}));\n    // Default value is true, so GL context is always created to verify wheter it is WebGL2 or not.\n    this.isDemoSupported = true;\n  }\n  /* eslint-disable max-statements */\n  onInitialize({canvas, gl}) {\n    this.isDemoSupported = isWebGL2(gl);\n    if (!this.isDemoSupported) {\n      log.error(ALT_TEXT)();\n      return {};\n    }\n    gl.canvas.addEventListener('mousemove', mousemove);\n    gl.canvas.addEventListener('mouseleave', mouseleave);\n\n    // -- Initialize data\n    const trianglePositions = new Float32Array([0.015, 0.0, -0.01, 0.01, -0.01, -0.01]);\n\n    const instanceOffsets = new Float32Array(NUM_INSTANCES * 2);\n    const instanceRotations = new Float32Array(NUM_INSTANCES);\n    const instanceColors = new Float32Array(NUM_INSTANCES * 3);\n    const pickingColors = new Uint8ClampedArray(NUM_INSTANCES * 2);\n\n    for (let i = 0; i < NUM_INSTANCES; ++i) {\n      instanceOffsets[i * 2] = Math.random() * 2.0 - 1.0;\n      instanceOffsets[i * 2 + 1] = Math.random() * 2.0 - 1.0;\n\n      instanceRotations[i] = Math.random() * 2 * Math.PI;\n\n      const randValue = Math.random();\n      if (randValue > 0.5) {\n        instanceColors[i * 3 + 1] = 1.0;\n        instanceColors[i * 3 + 2] = 1.0;\n      } else {\n        instanceColors[i * 3] = 1.0;\n        instanceColors[i * 3 + 2] = 1.0;\n      }\n\n      pickingColors[i * 2] = Math.floor(i / 255);\n      pickingColors[i * 2 + 1] = i - 255 * pickingColors[i * 2];\n    }\n\n    const positionBuffer = new Buffer(gl, trianglePositions);\n    const colorBuffer = new Buffer(gl, instanceColors);\n    const offsetBuffer = new Buffer(gl, instanceOffsets);\n    const rotationBuffer = new Buffer(gl, instanceRotations);\n    const pickingColorBuffer = new Buffer(gl, pickingColors);\n\n    const renderModel = new Model(gl, {\n      id: 'RenderModel',\n      vs: DRAW_VS,\n      fs: DRAW_FS,\n      drawMode: gl.TRIANGLE_FAN,\n      vertexCount: 3,\n      isInstanced: true,\n      instanceCount: NUM_INSTANCES,\n      attributes: {\n        a_position: positionBuffer,\n        a_color: [colorBuffer, {divisor: 1}],\n        a_offset: [offsetBuffer, {divisor: 1}],\n        a_rotation: [rotationBuffer, {divisor: 1}],\n        instancePickingColors: [pickingColorBuffer, {divisor: 1}]\n      },\n      modules: [picking]\n    });\n\n    const transform = new Transform(gl, {\n      vs: EMIT_VS,\n      elementCount: NUM_INSTANCES,\n      sourceBuffers: {\n        a_offset: offsetBuffer,\n        a_rotation: rotationBuffer\n      },\n      feedbackMap: {\n        a_offset: 'v_offset',\n        a_rotation: 'v_rotation'\n      }\n    });\n\n    return {\n      positionBuffer,\n      rotationBuffer,\n      colorBuffer,\n      offsetBuffer,\n      renderModel,\n      transform\n    };\n  }\n  /* eslint-enable max-statements */\n\n  onRender({\n    gl,\n    width,\n    height,\n    renderModel,\n    positionBuffer,\n    colorBuffer,\n    transform,\n    framebuffer,\n    useDevicePixels,\n    time\n  }) {\n    if (!this.isDemoSupported) {\n      return;\n    }\n    transform.run({\n      uniforms: {\n        u_time: time\n      }\n    });\n\n    transform.swap();\n\n    const offsetBuffer = transform.getBuffer('v_offset');\n    const rotationBuffer = transform.getBuffer('v_rotation');\n\n    offsetBuffer.setAccessor({divisor: 1});\n    rotationBuffer.setAccessor({divisor: 1});\n\n    renderModel.clear({color: [0.0, 0.0, 0.0, 1.0], depth: true});\n    renderModel.draw({\n      attributes: {\n        a_offset: offsetBuffer,\n        a_rotation: rotationBuffer\n      },\n      parameters: {\n        blend: true,\n        blendFunc: [gl.SRC_ALPHA, gl.ONE]\n      }\n    });\n\n    offsetBuffer.setAccessor({divisor: 0});\n    rotationBuffer.setAccessor({divisor: 0});\n\n    if (pickPosition) {\n      // use the center pixel location in device pixel range\n      const devicePixels = cssToDevicePixels(gl, pickPosition);\n      const deviceX = devicePixels.x + Math.floor(devicePixels.width / 2);\n      const deviceY = devicePixels.y + Math.floor(devicePixels.height / 2);\n\n      pickInstance(gl, deviceX, deviceY, renderModel, framebuffer);\n    }\n  }\n\n  onFinalize({renderModel, transform}) {\n    if (renderModel) {\n      renderModel.delete();\n    }\n    if (transform) {\n      transform.delete();\n    }\n  }\n\n  isSupported() {\n    return this.isDemoSupported;\n  }\n\n  getAltText() {\n    return ALT_TEXT;\n  }\n}\n\nfunction pickInstance(gl, pickX, pickY, model, framebuffer) {\n  framebuffer.clear({color: true, depth: true});\n  // Render picking colors\n  /* eslint-disable camelcase */\n  model.setUniforms({picking_uActive: 1});\n  model.draw({framebuffer});\n  model.setUniforms({picking_uActive: 0});\n\n  const color = readPixelsToArray(framebuffer, {\n    sourceX: pickX,\n    sourceY: pickY,\n    sourceWidth: 1,\n    sourceHeight: 1,\n    sourceFormat: gl.RGBA,\n    sourceType: gl.UNSIGNED_BYTE\n  });\n\n  if (color[0] + color[1] + color[2] > 0) {\n    model.updateModuleSettings({\n      pickingSelectedColor: color,\n      pickingHighlightColor: RED\n    });\n  } else {\n    model.updateModuleSettings({\n      pickingSelectedColor: null\n    });\n  }\n}\n\n/* global window */\nif (typeof window !== 'undefined' && !window.website) {\n  const animationLoop = new AppAnimationLoop();\n  animationLoop.start();\n}\n","import React from 'react';\nimport AnimationLoopExamplePage from '../../src/components/animation-loop-example-page';\nimport AnimationLoop from '../../../examples/core/transform/app';\n\nexport default class Example extends React.Component {\n  render() {\n    return (\n      <AnimationLoopExamplePage AnimationLoop={AnimationLoop} exampleConfig={this.props.pageContext.exampleConfig} />\n    );\n  }\n}\n","const DEFAULT_HIGHLIGHT_COLOR = new Uint8Array([0, 255, 255, 255]);\n\nconst DEFAULT_MODULE_OPTIONS = {\n  pickingSelectedColor: null, //  Set to a picking color to visually highlight that item\n  pickingHighlightColor: DEFAULT_HIGHLIGHT_COLOR, // Color of visual highlight of \"selected\" item\n  pickingThreshold: 1.0,\n  pickingActive: false // Set to true when rendering to off-screen \"picking\" buffer\n};\n\n/* eslint-disable camelcase */\nfunction getUniforms(opts = DEFAULT_MODULE_OPTIONS) {\n  const uniforms = {};\n  if (opts.pickingSelectedColor !== undefined) {\n    if (opts.pickingSelectedColor === null) {\n      uniforms.picking_uSelectedColorValid = 0;\n    } else {\n      const selectedColor = [\n        opts.pickingSelectedColor[0],\n        opts.pickingSelectedColor[1],\n        opts.pickingSelectedColor[2]\n      ];\n      uniforms.picking_uSelectedColorValid = 1;\n      uniforms.picking_uSelectedColor = selectedColor;\n    }\n  }\n  if (opts.pickingHighlightColor !== undefined) {\n    uniforms.picking_uHighlightColor = opts.pickingHighlightColor;\n  }\n  // TODO - major hack - decide on normalization and remove\n  if (opts.pickingThreshold !== undefined) {\n    uniforms.picking_uThreshold = opts.pickingThreshold;\n  }\n  if (opts.pickingActive !== undefined) {\n    uniforms.picking_uActive = opts.pickingActive ? 1 : 0;\n  }\n  return uniforms;\n}\n\nconst vs = `\\\nuniform vec3 picking_uSelectedColor;\nuniform float picking_uThreshold;\nuniform bool picking_uSelectedColorValid;\n\nout vec4 picking_vRGBcolor_Aselected;\n\nconst float COLOR_SCALE = 1. / 255.;\n\nbool isVertexPicked(vec3 vertexColor) {\n  return\n    picking_uSelectedColorValid &&\n    abs(vertexColor.r - picking_uSelectedColor.r) < picking_uThreshold &&\n    abs(vertexColor.g - picking_uSelectedColor.g) < picking_uThreshold &&\n    abs(vertexColor.b - picking_uSelectedColor.b) < picking_uThreshold;\n}\n\nvoid picking_setPickingColor(vec3 pickingColor) {\n  // Do the comparison with selected item color in vertex shader as it should mean fewer compares\n  picking_vRGBcolor_Aselected.a =\n    float(isVertexPicked(pickingColor));\n\n  // Stores the picking color so that the fragment shader can render it during picking\n  picking_vRGBcolor_Aselected.rgb = pickingColor * COLOR_SCALE;\n}\n`;\n\nconst fs = `\\\nuniform bool picking_uActive; // true during rendering to offscreen picking buffer\nuniform vec3 picking_uSelectedColor;\nuniform vec4 picking_uHighlightColor;\n\nin vec4 picking_vRGBcolor_Aselected;\n\nconst float COLOR_SCALE = 1. / 255.;\n\n/*\n * Returns highlight color if this item is selected.\n */\nvec4 picking_filterHighlightColor(vec4 color) {\n  bool selected = bool(picking_vRGBcolor_Aselected.a);\n\n  if (selected) {\n    vec4 highLightColor = picking_uHighlightColor * COLOR_SCALE;\n\n    float highLightAlpha = highLightColor.a;\n    float blendedAlpha = highLightAlpha + color.a * (1.0 - highLightAlpha);\n    float highLightRatio = highLightAlpha / blendedAlpha;\n\n    vec3 blendedRGB = mix(color.rgb, highLightColor.rgb, highLightRatio);\n    return vec4(blendedRGB, blendedAlpha);\n  } else {\n    return color;\n  }\n}\n\n/*\n * Returns picking color if picking enabled else unmodified argument.\n */\nvec4 picking_filterPickingColor(vec4 color) {\n  vec3 pickingColor = picking_vRGBcolor_Aselected.rgb;\n  if (picking_uActive && length(pickingColor) < 0.001) {\n    discard;\n  }\n  return picking_uActive ? vec4(pickingColor, 1.0) : color;\n}\n\n/*\n * Returns picking color if picking is enabled if not\n * highlight color if this item is selected, otherwise unmodified argument.\n */\nvec4 picking_filterColor(vec4 color) {\n  vec4 highightColor = picking_filterHighlightColor(color);\n  return picking_filterPickingColor(highightColor);\n}\n\n`;\n\nexport default {\n  name: 'picking',\n  vs,\n  fs,\n  getUniforms\n};\n"],"sourceRoot":""}