{"version":3,"sources":["webpack:///../examples/lessons/10/world.js","webpack:///../examples/lessons/10/app.js","webpack:///./templates/lessons/example-10.jsx","webpack:///../modules/core/src/geometry/geometry.js","webpack:///../modules/shadertools/src/utils/webgl-info.js","webpack:///../modules/shadertools/src/utils/is-old-ie.js","webpack:///../modules/shadertools/src/lib/platform-defines.js","webpack:///../modules/shadertools/src/lib/assemble-shaders.js","webpack:///../modules/shadertools/src/lib/shader-module-registry.js","webpack:///../modules/shadertools/src/lib/resolve-modules.js","webpack:///../modules/core/src/scenegraph/nodes/scenegraph-node.js","webpack:///../modules/core/src/lib/model-utils.js","webpack:///../modules/core/src/resource-management/program-manager.js","webpack:///../modules/webgl/src/utils/format-value.js","webpack:///../modules/webgl/src/debug/debug-vertex-array.js","webpack:///../modules/webgl/src/debug/debug-uniforms.js","webpack:///../modules/webgl/src/debug/debug-program-configuration.js","webpack:///../modules/core/src/debug/seer-integration.js","webpack:///../modules/core/src/lib/base-model.js","webpack:///../modules/core/src/lib/model.js","webpack:///../modules/shadertools/src/lib/transpile-shader.js","webpack:///../modules/shadertools/src/lib/filters/prop-types.js","webpack:///../modules/shadertools/src/lib/shader-module.js","webpack:///../modules/shadertools/src/lib/inject-shader.js","webpack:///../modules/shadertools/src/modules/module-injectors.js","webpack:///../modules/shadertools/src/index.js","webpack:///../modules/shadertools/src/shaders/modular-vertex.glsl.js","webpack:///../modules/shadertools/src/shaders/modular-fragment.glsl.js","webpack:///../modules/shadertools/src/lib/constants.js","webpack:///../modules/core/src/scenegraph/nodes/model-node.js","webpack:///../modules/shadertools/src/utils/assert.js","webpack:///../modules/webgl/src/classes/transform-feedback.js"],"names":["VERTEX_SHADER","FRAGMENT_SHADER","World","_ModelNode","opts","program","classes_program","gl","fs","vs","call","this","geometry","uniforms","uSampler","texture","model_node","cameraInfo","pitch","pitchRate","yaw","yawRate","xPos","yPos","zPos","speed","joggingAngle","direction","timeLine","lastTime","currentlyPressedKeys","AppAnimationLoop","getInfo","onInitialize","_parameters","canvas","_ref","eventManager","esm","addKeyboardHandler","keydown","e","keyup","mouseDown","currentX","currentY","panstart","panend","panmove","dx","dy","addMouseHandler","setParameters","clearColor","clearDepth","depthTest","texture_2d","data","parameters","TEXTURE_WRAP_S","MIRRORED_REPEAT","TEXTURE_WRAP_T","Object","load_file","then","file","lines","vertexPositions","vertexTextureCoords","i","vals","parseFloat","geometry_geometry","vertexCount","attributes","positions","Float32Array","texCoords","loadWorldGeometry","world","world_World","onRender","_ref2","aspect","tick","eyePos","centerPos","matrix4","rotateX","radians","rotateY","transform","map","val","uMVMatrix","lookAt","eye","center","up","Equal","Minus","KeyA","KeyD","KeyW","KeyS","handleKeys","timeNow","Date","getTime","elapsed","Math","animate","GL","setUniforms","uPMatrix","perspective","fov","PI","near","far","draw","onFinalize","destroy","AnimationLoop","window","website","app_AppAnimationLoop","animationLoop","Example","render","react_default","a","createElement","animation_loop_example_page","exampleConfig","props","pageContext","React","Component","DRAW_MODE","POINTS","LINES","LINE_LOOP","LINE_STRIP","TRIANGLES","TRIANGLE_STRIP","TRIANGLE_FAN","Geometry","_props","_props$id","id","uid","_props$drawMode","drawMode","_props$attributes","_props$indices","indices","_props$vertexCount","userData","_setAttributes","_calculateVertexCount","getVertexCount","getAttributes","assign","_print","attributeName","ArrayBuffer","isView","value","size","attribute","assert","undefined","isIndexed","length","Infinity","constant","Number","GL_VENDOR","GL_RENDERER","GL_VERSION","GL_SHADING_LANGUAGE_VERSION","WEBGL_FEATURES","GLSL_FRAG_DATA","GLSL_FRAG_DEPTH","GLSL_DERIVATIVES","GLSL_TEXTURE_LOD","FEATURES","key","compiledGlslExtensions","canCompileGLGSExtension","cap","feature","navigator","userAgent","isMSIE","isTrident","isOldIE","source","shader","canCompile","COMPILE_STATUS","getFeature","extensionName","Boolean","isWebGL2","hasFeatures","features","Array","every","getPlatformShaderDefines","info","vendor","UNMASKED_VENDOR_WEBGL","renderer","UNMASKED_RENDERER_WEBGL","gpuVendor","identifyGPUVendor","version","shadingLanguageVersion","getContextInfo","debugInfo","toLowerCase","INJECT_SHADER_DECLARATIONS","inject_shader","SHADER_TYPE","_SHADER_TYPE","constants","HOOK_FUNCTIONS","_HOOK_FUNCTIONS","MODULE_INJECTIONS","_MODULE_INJECTIONS","FRAGMENT_SHADER_PROLOGUE","createShaderHook","hook","_hook$split","stage","signature","name","createModuleInjection","moduleName","injection","_opts$order","order","shaderStage","moduleInjections","assembleShaders","modules","resolveModules","assembleShader","type","getUniforms","assembleGetUniforms","assembleModuleMap","_hookFunctions","_moduleInjections","_ref$defines","defines","_ref$hookFunctions","hookFunctions","_ref$moduleInjections","_ref$inject","inject","_ref$prologue","prologue","log","isVertex","sourceLines","glslVersion","versionLine","coreSource","allDefines","module","assembledSource","_ref6","getShaderName","_ref5","toUpperCase","getShaderType","isFragment","versionDefines","behavior","getVersionDefines","count","sourceText","define","getApplicationDefines","injectStandardStubs","hookInjections","mainInjections","_iterator","_isArray","isArray","_i","Symbol","iterator","next","done","injections","_key","result","hookName","hookFunction","header","b","_iterator4","_isArray4","_i4","_ref7","footer","getHookFunctions","injectShader","_iterator2","_isArray2","_i2","_ref3","moduleUniforms","_iterator3","_isArray3","_i3","_ref4","shaderModule","getShaderModule","ShaderModuleRegistry","shaderModules","defaultShaderModules","setDefaultShaderModules","getDefaultShaderModules","registerShaderModules","_ref$ignoreMultipleRe","_temp","ignoreMultipleRegistrations","shaderModuleList","_registerShaderModule","moduleOrName","shader_module","_this","Error","shaderModuleRegistry","shader_module_registry_ShaderModuleRegistry","getShaderDependencies","resolve_modules_getShaderModule","moduleMap","moduleDepth","getDependencyGraph","level","keys","sort","dependencies","ScenegraphNode","constructor","display","position","math_gl__WEBPACK_IMPORTED_MODULE_4__","rotation","scale","matrix","math_gl__WEBPACK_IMPORTED_MODULE_5__","_setScenegraphNodeProps","delete","setProps","toString","setPosition","setRotation","setScale","setMatrix","copyMatrix","copy","setMatrixComponents","_ref$update","update","updateMatrix","pos","rot","identity","translate","rotateXYZ","getCoordinateUniforms","modelMatrix","worldMatrix","viewMatrix","multiplyRight","worldInverse","invert","worldInverseTranspose","transpose","objectMatrix","worldInverseMatrix","worldInverseTransposeMatrix","GLTF_TO_LUMA_ATTRIBUTE_MAP","POSITION","NORMAL","COLOR_0","TEXCOORD_0","TEXCOORD_1","TEXCOORD_2","mapAttributeName","options","_ref$attributeMap","attributeMap","inferAttributeAccessor","category","ProgramManager","_programCache","_getUniforms","_registeredModules","_defaultModules","_hashes","_hashCounter","stateHash","_useCounts","getDefaultProgramManager","defaultProgramManager","addDefaultModule","find","m","push","removeDefaultModule","filter","addModuleInjection","addShaderHook","get","_props$vs","_props$fs","_props$defines","_props$inject","_props$varyings","varyings","_props$bufferMode","bufferMode","_getModuleList","vsHash","_getHash","fsHash","moduleHashes","varyingHashes","v","defineKeys","injectKeys","defineHashes","hash","injectHashes","assembled","x","release","appModules","seen","len","_len","_module","_name","formatValue","_opts$isInteger","isInteger","_opts$maxElts","maxElts","_opts$size","string","formatArrayValue","String","decimal","getDebugTableRow","vertexArray","accessor","marker","verts","bytes","classes_buffer","format","buffer","_buffer$getDebugData","getDebugData","modified","getKey","getGLSLDeclaration","typeAndName","getCompositeGLType","getDebugTableForUniforms","_ref$header","_ref$undefinedOnly","undefinedOnly","uniformLocations","_uniformSetters","table","uniformNames","uniformName","addUniformToTable","_uniformName","_uniformName2","unusedCount","unusedTable","_unusedTable$uniformN","uniform","Type","_table$uniformName","isDefined","isUniformDefined","debug_program_configuration_getGLSLDeclaration","attributeInfo","_attributeInfo$access","models","recursiveSet","obj","path","overrides","Map","seer","payload","model","itemKey","valuePath","__SEER_INITIALIZED__","setOverride","BaseModel","isWebGL","lastLogTime","initialize","shaderCache","programManager","_programManagerState","_managedProgram","_props$program","programProps","_programDirty","needsRedraw","_attributes","animatedUniforms","animated","timerQueryEnabled","timeElapsedQuery","lastQueryReturned","stats","accumulatedFrameTime","averageFrameTime","profileFrameCount","pickable","_checkProgram","_setBaseModelProps","getModuleUniforms","moduleSettings","removeModel","isAnimated","getProgram","setProgram","overs","getOverrides","_extractAnimatedUniforms","updateModuleSettings","clear","drawGeometry","_opts","_opts$moduleSettings","framebuffer","_opts$uniforms","_opts$attributes","_opts$transformFeedba","transformFeedback","_opts$parameters","_opts$vertexArray","animationProps","setAttributes","_refreshAnimationProps","logPriority","_logDrawCallStart","drawParams","getDrawParams","isInstanced","indexType","indexOffset","instanceCount","noop","_this$props","_this$props$onBeforeR","onBeforeRender","_this$props$onAfterRe","onAfterRender","_timerQueryStart","didDraw","getDrawMode","offset","_timerQueryEnd","_logDrawCallEnd","Query","_setAnimationProps","_animationProps","_animationLoop","_this$programProps","_this$programProps$vs","MODULAR_SHADERS","_this$programProps$fs","vertex_array","_evaluateAnimateUniforms","valueFunction","foundAnimated","newValue","isObjectEmpty","staticUniforms","query","beginTimeElapsedQuery","end","isResultAvailable","elapsedTime","getTimerMilliseconds","lastFrameTime","logDrawTimeout","priority","now","collapsed","attributeTable","configuration","elements","values","attributeLocation","rowHeader","location","getDebugTableForVertexArray","_getDebugTableForUnif","uniformTable","_getDebugTableForUnif2","missingTable","configTable","config","attributeInfos","_table","JSON","varyingInfos","_table2","varyingInfo","getDebugTableForProgramConfiguration","isReady","attributesObject","uniformsObject","logModel","message","Model","_BaseModel","prototype","geometryBuffers","instanced","_setModelProps","_deleteGeometryBuffers","getInstanceCount","setDrawMode","setVertexCount","setInstanceCount","setGeometry","buffers","remappedName","typedArray","Uint32Array","target","ELEMENT_ARRAY_BUFFER","getBuffersFromGeometry","normalizedAttributes","_Object$assign","_opts$discard","discard","feedbackBuffers","_opts$unbindModels","unbindModels","_setFeedbackBuffers","unbindBuffers","bindBuffers","_feedbackBuffers","transform_feedback","setBuffers","transpileShader","targetGLSLVersion","convertVertexShaderTo300","convertFragmentShaderTo300","convertVertexShaderTo100","convertFragmentShaderTo100","TYPE_DEFINITIONS","number","validate","propType","min","array","parsePropType","propDef","getTypeOf","ShaderModule","_ref$dependencies","_ref$deprecations","deprecations","vertexShader","fragmentShader","_parseDeprecationDefinitions","propDefs","propTypes","propName","parsePropTypes","getModuleSource","moduleSource","_defaultGetUniforms","getDefines","checkDeprecations","forEach","def","shaderSource","deprecated","RegExp","old","private","MODULE_INJECTORS","_MODULE_INJECTORS","DECLARATION_INJECT_MARKER","REGEX_START_OF_MAIN","REGEX_END_OF_MAIN","fragments","_loop","fragmentData","fragmentString","replace","match","combineInjects","injects","__webpack_require__","d","__webpack_exports__","ModelNode","_ScenegraphNode","AfterRender","_lib_model__WEBPACK_IMPORTED_MODULE_0__","_setModelNodeProps","managedResources","resource","_this$model","apply","arguments","_this$model2","_this$model3","_this$model4","condition","TransformFeedback","assertWebGL2Context","_Resource","stubRemovedMethods","isSupported","_this2","unused","bindOnUse","bind","_unbindBuffers","_this3","bufferName","setBuffer","_this4","_getVaryingIndex","locationOrName","_this$_getBufferParam","_getBufferParams","bufferOrParams","byteSize","byteOffset","_bindBuffer","begin","primitiveMode","bindTransformFeedback","TRANSFORM_FEEDBACK","handle","_bindBuffers","beginTransformFeedback","endTransformFeedback","_getVaryingInfo","getVaryingInfo","bufferIndex","_this$_getBufferParam2","bindBufferRange","TRANSFORM_FEEDBACK_BUFFER","index","bindBufferBase","_createHandle","createTransformFeedback","_deleteHandle","deleteTransformFeedback","_bindHandle","Resource"],"mappings":"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","file":"component---templates-lessons-example-10-jsx-039bbff23a5833e8e836.js","sourcesContent":["import {Program, Geometry, ModelNode} from '@luma.gl/core';\n\nconst VERTEX_SHADER = `\\\nattribute vec3 positions;\nattribute vec2 texCoords;\n\nuniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void) {\n  gl_Position = uPMatrix * uMVMatrix * vec4(positions, 1.0);\n  vTextureCoord = texCoords;\n}\n`;\n\nconst FRAGMENT_SHADER = `\\\nprecision highp float;\n\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\n\nvoid main(void) {\n  gl_FragColor = vec4(texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t)).rgb, 1.0);\n}\n`;\n\nfunction loadWorldGeometry(data) {\n  const lines = data.split('\\n');\n  const vertexPositions = [];\n  const vertexTextureCoords = [];\n  for (const i in lines) {\n    const vals = lines[i].replace(/^\\s+/, '').split(/\\s+/);\n    if (vals.length === 5 && vals[0] !== '//') {\n      // It is a line describing a vertex; get X, Y and Z first\n      vertexPositions.push(parseFloat(vals[0]));\n      vertexPositions.push(parseFloat(vals[1]));\n      vertexPositions.push(parseFloat(vals[2]));\n      // And then the texture coords\n      vertexTextureCoords.push(parseFloat(vals[3]));\n      vertexTextureCoords.push(parseFloat(vals[4]));\n    }\n  }\n  return new Geometry({\n    vertexCount: vertexPositions.length / 3,\n    attributes: {\n      positions: new Float32Array(vertexPositions),\n      texCoords: new Float32Array(vertexTextureCoords)\n    }\n  });\n}\n\nexport class World extends ModelNode {\n  constructor(opts = {}) {\n    const program = new Program(opts.gl, {\n      fs: FRAGMENT_SHADER,\n      vs: VERTEX_SHADER\n    });\n\n    super(opts.gl, {\n      program,\n      geometry: opts.geometry,\n      uniforms: {\n        uSampler: opts.texture\n      }\n    });\n  }\n}\n\nexport {loadWorldGeometry};\n","import GL from '@luma.gl/constants';\nimport {AnimationLoop, Texture2D, loadFile, setParameters} from '@luma.gl/core';\nimport {Matrix4, radians} from 'math.gl';\nimport {loadWorldGeometry, World} from './world';\nimport {EventManager} from 'mjolnir.js';\n/* eslint-disable complexity */\n\n/*\n  Cave texture from: http://texturelib.com/texture/?path=/Textures/rock/cave/rock_cave_0019\n  \"Free for personal and commercial use.\" http://texturelib.com/about/\n*/\n\nconst INFO_HTML = `\n<p>\n  <a href=\"http://learningwebgl.com/blog/?p=1067\" target=\"_blank\">\n    Loading a world, and the most basic kind of camera\n  </a>\n\n  </br>\n  </br>\n  Use the cursor keys or WASD to run around, and <code>+</code>/<code>-</code> to look up and down.\n<p>\nThe classic WebGL Lessons in luma.gl\n`;\n\nconst cameraInfo = {\n  pitch: 0,\n  pitchRate: 0,\n  yaw: 0,\n  yawRate: 0,\n  xPos: 0,\n  yPos: 0.4,\n  zPos: 0,\n  speed: 0,\n  joggingAngle: 0, // Used to make us \"jog\" up and down as we move forward.\n  direction: [0, 0, -1]\n};\n\nconst timeLine = {\n  lastTime: 0\n};\n\nconst currentlyPressedKeys = {};\n\nexport default class AppAnimationLoop extends AnimationLoop {\n  static getInfo() {\n    return INFO_HTML;\n  }\n\n  onInitialize({canvas, gl}) {\n    // Use mjolnir.js (hammer.js)'s EventManager to handle gestures on both\n    // desktop and mobile\n    this.eventManager = new EventManager(canvas);\n    addKeyboardHandler(this.eventManager);\n    addMouseHandler(this.eventManager);\n\n    setParameters(gl, {\n      clearColor: [0, 0, 0, 1],\n      clearDepth: 1,\n      depthTest: true\n    });\n\n    const texture = new Texture2D(gl, {\n      data: 'cave.jpg',\n      parameters: {\n        [gl.TEXTURE_WRAP_S]: gl.MIRRORED_REPEAT,\n        [gl.TEXTURE_WRAP_T]: gl.MIRRORED_REPEAT\n      }\n    });\n\n    return loadFile('world.txt').then(file => {\n      const geometry = loadWorldGeometry(file);\n      const world = new World({\n        gl,\n        geometry,\n        texture\n      });\n      return {world};\n    });\n  }\n\n  onRender({gl, tick, aspect, world}) {\n    // Update Camera Position\n    const eyePos = [cameraInfo.xPos, cameraInfo.yPos, cameraInfo.zPos];\n    const centerPos = new Matrix4()\n      .rotateX(radians(cameraInfo.pitch))\n      .rotateY(radians(cameraInfo.yaw))\n      .transform(cameraInfo.direction)\n      .map((val, i) => val + eyePos[i]);\n\n    const uMVMatrix = new Matrix4().lookAt({eye: eyePos, center: centerPos, up: [0, 1, 0]});\n\n    handleKeys(cameraInfo, currentlyPressedKeys);\n    animate(cameraInfo, timeLine);\n\n    gl.clear(GL.COLOR_BUFFER_BIT | GL.DEPTH_BUFFER_BIT);\n\n    return world\n      .setUniforms({\n        uMVMatrix,\n        uPMatrix: new Matrix4().perspective({\n          fov: (45 * Math.PI) / 180,\n          aspect,\n          near: 0.1,\n          far: 100\n        })\n      })\n      .draw();\n  }\n\n  onFinalize() {\n    this.eventManager.destroy();\n  }\n}\n\nfunction addKeyboardHandler(eventManager) {\n  eventManager.on({\n    keydown(e) {\n      currentlyPressedKeys[e.srcEvent.code] = true;\n    },\n    keyup(e) {\n      currentlyPressedKeys[e.srcEvent.code] = false;\n    }\n  });\n}\n\nfunction addMouseHandler(eventManager) {\n  let mouseDown = false;\n  let currentX = 0;\n  let currentY = 0;\n\n  eventManager.on({\n    panstart(e) {\n      mouseDown = true;\n      currentX = e.offsetCenter.x;\n      currentY = e.offsetCenter.y;\n    },\n    panend() {\n      mouseDown = false;\n    },\n    panmove(e) {\n      if (!mouseDown) {\n        return;\n      }\n      const dx = e.offsetCenter.x - currentX;\n      const dy = e.offsetCenter.y - currentY;\n      cameraInfo.yaw += dx * 0.1;\n      cameraInfo.pitch += dy * 0.1;\n      currentX = e.offsetCenter.x;\n      currentY = e.offsetCenter.y;\n    }\n  });\n}\n\nfunction handleKeys() {\n  if (currentlyPressedKeys.PageUp || currentlyPressedKeys.Equal) {\n    cameraInfo.pitchRate = 0.1;\n  } else if (currentlyPressedKeys.PageDown || currentlyPressedKeys.Minus) {\n    cameraInfo.pitchRate = -0.1;\n  } else {\n    cameraInfo.pitchRate = 0;\n  }\n  if (currentlyPressedKeys.ArrowLeft || currentlyPressedKeys.KeyA) {\n    cameraInfo.yawRate = 0.1;\n  } else if (currentlyPressedKeys.ArrowRight || currentlyPressedKeys.KeyD) {\n    cameraInfo.yawRate = -0.1;\n  } else {\n    cameraInfo.yawRate = 0;\n  }\n  if (currentlyPressedKeys.ArrowUp || currentlyPressedKeys.KeyW) {\n    cameraInfo.speed = 0.003;\n  } else if (currentlyPressedKeys.ArrowDown || currentlyPressedKeys.KeyS) {\n    cameraInfo.speed = -0.003;\n  } else {\n    cameraInfo.speed = 0;\n  }\n}\n\nfunction animate() {\n  const timeNow = new Date().getTime();\n  if (timeLine.lastTime !== 0) {\n    const elapsed = timeNow - timeLine.lastTime;\n    if (cameraInfo.speed !== 0) {\n      cameraInfo.xPos -= Math.sin(radians(cameraInfo.yaw)) * cameraInfo.speed * elapsed;\n      cameraInfo.zPos -= Math.cos(radians(cameraInfo.yaw)) * cameraInfo.speed * elapsed;\n      cameraInfo.joggingAngle += elapsed * 0.6; // 0.6 \"fiddle factor\" - feel more realistic :-)\n      cameraInfo.yPos = Math.sin(radians(cameraInfo.joggingAngle)) / 20 + 0.4;\n    }\n    cameraInfo.yaw += cameraInfo.yawRate * elapsed;\n    cameraInfo.pitch += cameraInfo.pitchRate * elapsed;\n  }\n  timeLine.lastTime = timeNow;\n}\n\n/* global window */\nif (typeof window !== 'undefined' && !window.website) {\n  const animationLoop = new AppAnimationLoop();\n  animationLoop.start();\n}\n","import React from 'react';\nimport AnimationLoopExamplePage from '../../src/components/animation-loop-example-page';\nimport AnimationLoop from '../../../examples/lessons/10/app';\n\nexport default class Example extends React.Component {\n  render() {\n    return (\n      <AnimationLoopExamplePage AnimationLoop={AnimationLoop} exampleConfig={this.props.pageContext.exampleConfig} />\n    );\n  }\n}\n","import {uid, assert} from '../utils';\n\n// Rendering primitives - specify how to extract primitives from vertices.\n// NOTE: These are numerically identical to the corresponding WebGL/OpenGL constants\nexport const DRAW_MODE = {\n  POINTS: 0x0000, // draw single points.\n  LINES: 0x0001, // draw lines. Each vertex connects to the one after it.\n  LINE_LOOP: 0x0002, // draw lines. Each set of two vertices is treated as a separate line segment.\n  LINE_STRIP: 0x0003, // draw a connected group of line segments from the first vertex to the last\n  TRIANGLES: 0x0004, // draw triangles. Each set of three vertices creates a separate triangle.\n  TRIANGLE_STRIP: 0x0005, // draw a connected group of triangles.\n  TRIANGLE_FAN: 0x0006 // draw a connected group of triangles.\n  // Each vertex connects to the previous and the first vertex in the fan.\n};\n\nexport default class Geometry {\n  static get DRAW_MODE() {\n    return DRAW_MODE;\n  }\n\n  constructor(props = {}) {\n    const {\n      id = uid('geometry'),\n      drawMode = DRAW_MODE.TRIANGLES,\n      attributes = {},\n      indices = null,\n      vertexCount = null\n    } = props;\n\n    this.id = id;\n    this.drawMode = drawMode | 0;\n    this.attributes = {};\n    this.userData = {};\n\n    this._setAttributes(attributes, indices);\n\n    this.vertexCount = vertexCount || this._calculateVertexCount(this.attributes, this.indices);\n\n    // stubRemovedMethods(this, [\n    //   'setNeedsRedraw', 'needsRedraw', 'setAttributes'\n    // ], 'Immutable');\n\n    // stubRemovedMethods(this, [\n    //   'hasAttribute', 'getAttribute', 'getArray'\n    // ], 'Use geometry.attributes and geometry.indices');\n\n    // deprecateMethods(this, ['getAttributes'])\n  }\n\n  get mode() {\n    return this.drawMode;\n  }\n\n  getVertexCount() {\n    return this.vertexCount;\n  }\n\n  // Return an object with all attributes plus indices added as a field.\n  getAttributes() {\n    return this.indices ? {indices: this.indices, ...this.attributes} : this.attributes;\n  }\n\n  // PRIVATE\n\n  _print(attributeName) {\n    return `Geometry ${this.id} attribute ${attributeName}`;\n  }\n\n  // Attribute\n  // value: typed array\n  // type: indices, vertices, uvs\n  // size: elements per vertex\n  // target: WebGL buffer type (string or constant)\n  _setAttributes(attributes, indices) {\n    if (indices) {\n      this.indices = ArrayBuffer.isView(indices) ? {value: indices, size: 1} : indices;\n    }\n\n    for (const attributeName in attributes) {\n      let attribute = attributes[attributeName];\n\n      // Wrap \"unwrapped\" arrays and try to autodetect their type\n      attribute = ArrayBuffer.isView(attribute) ? {value: attribute} : attribute;\n\n      assert(\n        ArrayBuffer.isView(attribute.value),\n        `${this._print(attributeName)}: must be typed array or object with value as typed array`\n      );\n\n      if ((attributeName === 'POSITION' || attributeName === 'positions') && !attribute.size) {\n        attribute.size = 3;\n      }\n\n      // Move indices to separate field\n      if (attributeName === 'indices') {\n        assert(!this.indices);\n        this.indices = attribute;\n      } else {\n        this.attributes[attributeName] = attribute;\n      }\n    }\n\n    if (this.indices && this.indices.isIndexed !== undefined) {\n      this.indices = Object.assign({}, this.indices);\n      delete this.indices.isIndexed;\n    }\n\n    return this;\n  }\n\n  _calculateVertexCount(attributes, indices) {\n    if (indices) {\n      return indices.value.length;\n    }\n    let vertexCount = Infinity;\n    for (const attributeName in attributes) {\n      const attribute = attributes[attributeName];\n      const {value, size, constant} = attribute;\n      if (!constant && value && size >= 1) {\n        vertexCount = Math.min(vertexCount, value.length / size);\n      }\n    }\n\n    assert(Number.isFinite(vertexCount));\n    return vertexCount;\n  }\n}\n","// Feature detection for WebGL\n//\n// Provides a function that enables simple checking of which WebGL features are\n// available in an WebGL1 or WebGL2 environment.\n\n/* eslint-disable no-inline-comments, max-len */\nimport isOldIE from './is-old-ie';\nimport assert from './assert';\n\nconst GL_VENDOR = 0x1f00;\nconst GL_RENDERER = 0x1f01;\nconst GL_VERSION = 0x1f02;\nconst GL_SHADING_LANGUAGE_VERSION = 0x8b8c;\n\n// Defines luma.gl \"feature\" names and semantics\nconst WEBGL_FEATURES = {\n  // GLSL extensions\n  GLSL_FRAG_DATA: ['WEBGL_draw_buffers', true], // TODO - name makes no sense in GLSL 3.00\n  GLSL_FRAG_DEPTH: ['EXT_frag_depth', true],\n  GLSL_DERIVATIVES: ['OES_standard_derivatives', true],\n  GLSL_TEXTURE_LOD: ['EXT_shader_texture_lod', true]\n};\n\n// Create a key-mirrored FEATURES array\nconst FEATURES = {};\nObject.keys(WEBGL_FEATURES).forEach(key => {\n  FEATURES[key] = key;\n});\n\nexport {FEATURES};\n\nfunction isWebGL2(gl) {\n  return Boolean(gl && gl._version === 2);\n}\n\nexport function getContextInfo(gl) {\n  const info = gl.getExtension('WEBGL_debug_renderer_info');\n  const vendor = gl.getParameter((info && info.UNMASKED_VENDOR_WEBGL) || GL_VENDOR);\n  const renderer = gl.getParameter((info && info.UNMASKED_RENDERER_WEBGL) || GL_RENDERER);\n  const gpuVendor = identifyGPUVendor(vendor, renderer);\n  const gpuInfo = {\n    gpuVendor,\n    vendor,\n    renderer,\n    version: gl.getParameter(GL_VERSION),\n    shadingLanguageVersion: gl.getParameter(GL_SHADING_LANGUAGE_VERSION)\n  };\n  return gpuInfo;\n}\n\nfunction identifyGPUVendor(vendor, renderer) {\n  if (vendor.match(/NVIDIA/i) || renderer.match(/NVIDIA/i)) {\n    return 'NVIDIA';\n  }\n  if (vendor.match(/INTEL/i) || renderer.match(/INTEL/i)) {\n    return 'INTEL';\n  }\n  if (\n    vendor.match(/AMD/i) ||\n    renderer.match(/AMD/i) ||\n    vendor.match(/ATI/i) ||\n    renderer.match(/ATI/i)\n  ) {\n    return 'AMD';\n  }\n  return 'UNKNOWN GPU';\n}\n\nconst compiledGlslExtensions = {};\n\n// Enables feature detection in IE11 due to a bug where gl.getExtension may return true\n// but fail to compile when the extension is enabled in the shader. Specifically,\n// the OES_standard_derivatives and WEBGL_draw_buffers extensions fails to compile in IE11 even though its included\n// in the list of supported extensions.\n// opts allows user agent to be overridden for testing\n/*\n* Inputs :\n*  gl : WebGL context\n*  cap : Key of WEBGL_FEATURES object identifying the extension\n*  opts :\n*   behavior : behavor of extension to be tested, by defualt `enable` is used\n* Returns : true, if shader is compiled successfully, false otherwise\n*/\nexport function canCompileGLGSExtension(gl, cap, opts = {}) {\n  const feature = WEBGL_FEATURES[cap];\n  assert(feature, cap);\n\n  if (!isOldIE(opts)) {\n    return true;\n  }\n\n  if (cap in compiledGlslExtensions) {\n    return compiledGlslExtensions[cap];\n  }\n\n  const extensionName = feature[0];\n  const behavior = opts.behavior || 'enable';\n  const source = `#extension GL_${extensionName} : ${behavior}\\nvoid main(void) {}`;\n\n  const shader = gl.createShader(gl.VERTEX_SHADER);\n  gl.shaderSource(shader, source);\n  gl.compileShader(shader);\n  const canCompile = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\n  gl.deleteShader(shader);\n  compiledGlslExtensions[cap] = canCompile;\n  return canCompile;\n}\n\n// TODO - cache the value\nfunction getFeature(gl, cap) {\n  const feature = WEBGL_FEATURES[cap];\n  assert(feature, cap);\n\n  // Get extension name from table\n  const extensionName = isWebGL2(gl) ? feature[1] || feature[0] : feature[0];\n\n  // Check if the value is dependent on checking an extension\n  const value =\n    typeof extensionName === 'string' ? Boolean(gl.getExtension(extensionName)) : extensionName;\n\n  assert(value === false || value === true);\n\n  return value;\n}\n\nexport function hasFeatures(gl, features) {\n  features = Array.isArray(features) ? features : [features];\n  return features.every(feature => getFeature(gl, feature));\n}\n","/* global window */\n// opts allows user agent to be overridden for testing\nexport default function isOldIE(opts = {}) {\n  const navigator = typeof window !== 'undefined' ? window.navigator || {} : {};\n  const userAgent = opts.userAgent || navigator.userAgent || '';\n  // We only care about older versions of IE (IE 11 and below). Newer versions of IE (Edge)\n  // have much better web standards support.\n  const isMSIE = userAgent.indexOf('MSIE ') !== -1;\n  const isTrident = userAgent.indexOf('Trident/') !== -1;\n  return isMSIE || isTrident;\n}\n","import {getContextInfo, hasFeatures, canCompileGLGSExtension, FEATURES} from '../utils/webgl-info';\n\nexport function getPlatformShaderDefines(gl) {\n  const debugInfo = getContextInfo(gl);\n\n  switch (debugInfo.gpuVendor.toLowerCase()) {\n    case 'nvidia':\n      return `\\\n#define NVIDIA_GPU\n// Nvidia optimizes away the calculation necessary for emulated fp64\n#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1\n`;\n\n    case 'intel':\n      return `\\\n#define INTEL_GPU\n// Intel optimizes away the calculation necessary for emulated fp64\n#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1\n// Intel's built-in 'tan' function doesn't have acceptable precision\n#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1\n// Intel GPU doesn't have full 32 bits precision in same cases, causes overflow\n#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1\n`;\n\n    case 'amd':\n      // AMD Does not eliminate fp64 code\n      return `\\\n#define AMD_GPU\n`;\n\n    default:\n      // We don't know what GPU it is, could be that the GPU driver or\n      // browser is not implementing UNMASKED_RENDERER constant and not\n      // reporting a correct name\n      return `\\\n#define DEFAULT_GPU\n// Prevent driver from optimizing away the calculation necessary for emulated fp64\n#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1\n// Intel's built-in 'tan' function doesn't have acceptable precision\n#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1\n// Intel GPU doesn't have full 32 bits precision in same cases, causes overflow\n#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1\n`;\n  }\n}\n\nexport function getVersionDefines(gl, glslVersion, isFragment) {\n  // Add shadertools defines to let shaders portably v1/v3 check for features\n  let versionDefines = `\\\n#if (__VERSION__ > 120)\n\n# define FRAG_DEPTH\n# define DERIVATIVES\n# define DRAW_BUFFERS\n# define TEXTURE_LOD\n\n#endif // __VERSION\n`;\n\n  if (hasFeatures(gl, FEATURES.GLSL_FRAG_DEPTH)) {\n    versionDefines += `\\\n// FRAG_DEPTH => gl_FragDepth is available\n#ifdef GL_EXT_frag_depth\n#extension GL_EXT_frag_depth : enable\n# define FRAG_DEPTH\n# define gl_FragDepth gl_FragDepthEXT\n#endif\n`;\n  }\n  if (\n    hasFeatures(gl, FEATURES.GLSL_DERIVATIVES) &&\n    canCompileGLGSExtension(gl, FEATURES.GLSL_DERIVATIVES)\n  ) {\n    versionDefines += `\\\n// DERIVATIVES => dxdF, dxdY and fwidth are available\n#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives : enable\n# define DERIVATIVES\n#endif\n`;\n  }\n  if (\n    hasFeatures(gl, FEATURES.GLSL_FRAG_DATA) &&\n    canCompileGLGSExtension(gl, FEATURES.GLSL_FRAG_DATA, {behavior: 'require'})\n  ) {\n    versionDefines += `\\\n// DRAW_BUFFERS => gl_FragData[] is available\n#ifdef GL_EXT_draw_buffers\n#extension GL_EXT_draw_buffers : require\n#define DRAW_BUFFERS\n#endif\n`;\n  }\n  if (hasFeatures(gl, FEATURES.GLSL_TEXTURE_LOD)) {\n    versionDefines += `\\\n// TEXTURE_LOD => texture2DLod etc are available\n#ifdef GL_EXT_shader_texture_lod\n#extension GL_EXT_shader_texture_lod : enable\n# define TEXTURE_LOD\n#define texture2DLod texture2DLodEXT\n#define texture2DProjLod texture2DProjLodEXT\n#define texture2DProjLod texture2DProjLodEXT\n#define textureCubeLod textureCubeLodEXT\n#define texture2DGrad texture2DGradEXT\n#define texture2DProjGrad texture2DProjGradEXT\n#define texture2DProjGrad texture2DProjGradEXT\n#define textureCubeGrad textureCubeGradEXT\n#endif\n`;\n  }\n  return versionDefines;\n}\n","import {VERTEX_SHADER, FRAGMENT_SHADER} from './constants';\nimport {resolveModules, getShaderModule} from './resolve-modules';\nimport {getPlatformShaderDefines, getVersionDefines} from './platform-defines';\nimport injectShader, {DECLARATION_INJECT_MARKER} from './inject-shader';\nimport {assert} from '../utils';\n/* eslint-disable max-depth, complexity */\n\nconst INJECT_SHADER_DECLARATIONS = `\\n\\n${DECLARATION_INJECT_MARKER}\\n\\n`;\n\nconst SHADER_TYPE = {\n  [VERTEX_SHADER]: 'vertex',\n  [FRAGMENT_SHADER]: 'fragment'\n};\n\nconst HOOK_FUNCTIONS = {\n  [VERTEX_SHADER]: {},\n  [FRAGMENT_SHADER]: {}\n};\n\nconst MODULE_INJECTIONS = {\n  [VERTEX_SHADER]: {},\n  [FRAGMENT_SHADER]: {}\n};\n\n// Precision prologue to inject before functions are injected in shader\n// TODO - extract any existing prologue in the fragment source and move it up...\nconst FRAGMENT_SHADER_PROLOGUE = `\\\nprecision highp float;\n\n`;\n\nexport function createShaderHook(hook, opts = {}) {\n  hook = hook.trim();\n  const [stage, signature] = hook.split(':');\n  const name = hook.replace(/\\(.+/, '');\n  HOOK_FUNCTIONS[stage][name] = Object.assign(opts, {signature});\n}\n\nexport function createModuleInjection(moduleName, opts) {\n  const {hook, injection, order = 0} = opts;\n  const shaderStage = hook.slice(0, 2);\n\n  const moduleInjections = MODULE_INJECTIONS[shaderStage];\n  moduleInjections[moduleName] = moduleInjections[moduleName] || {};\n\n  assert(!moduleInjections[moduleName][hook], 'Module injection already created');\n\n  moduleInjections[moduleName][hook] = {\n    injection,\n    order\n  };\n}\n\n// Helpful for tests\nexport function resetGlobalShaderHooks() {\n  HOOK_FUNCTIONS[VERTEX_SHADER] = {};\n  HOOK_FUNCTIONS[FRAGMENT_SHADER] = {};\n\n  MODULE_INJECTIONS[VERTEX_SHADER] = {};\n  MODULE_INJECTIONS[FRAGMENT_SHADER] = {};\n}\n\n// Inject a list of modules\nexport function assembleShaders(gl, opts) {\n  const {vs, fs} = opts;\n  const modules = resolveModules(opts.modules || []);\n  return {\n    gl,\n    vs: assembleShader(gl, Object.assign({}, opts, {source: vs, type: VERTEX_SHADER, modules})),\n    fs: assembleShader(gl, Object.assign({}, opts, {source: fs, type: FRAGMENT_SHADER, modules})),\n    getUniforms: assembleGetUniforms(modules),\n    modules: assembleModuleMap(modules)\n  };\n}\n\n// Pulls together complete source code for either a vertex or a fragment shader\n// adding prologues, requested module chunks, and any final injections.\nfunction assembleShader(\n  gl,\n  {\n    id,\n    source,\n    type,\n    modules,\n    defines = {},\n    hookFunctions = HOOK_FUNCTIONS,\n    moduleInjections = MODULE_INJECTIONS,\n    inject = {},\n    prologue = true,\n    log\n  }\n) {\n  assert(typeof source === 'string', 'shader source must be a string');\n\n  // TODO(Tarek): Supporting global hooks, remove when they're removed.\n  if (hookFunctions !== HOOK_FUNCTIONS) {\n    hookFunctions = {\n      [VERTEX_SHADER]: Object.assign(\n        {},\n        HOOK_FUNCTIONS[VERTEX_SHADER],\n        hookFunctions[VERTEX_SHADER]\n      ),\n      [FRAGMENT_SHADER]: Object.assign(\n        {},\n        HOOK_FUNCTIONS[FRAGMENT_SHADER],\n        hookFunctions[FRAGMENT_SHADER]\n      )\n    };\n  }\n\n  if (moduleInjections !== MODULE_INJECTIONS) {\n    moduleInjections = {\n      [VERTEX_SHADER]: Object.assign(\n        {},\n        MODULE_INJECTIONS[VERTEX_SHADER],\n        moduleInjections[VERTEX_SHADER]\n      ),\n      [FRAGMENT_SHADER]: Object.assign(\n        {},\n        MODULE_INJECTIONS[FRAGMENT_SHADER],\n        moduleInjections[FRAGMENT_SHADER]\n      )\n    };\n  }\n\n  const isVertex = type === VERTEX_SHADER;\n\n  const sourceLines = source.split('\\n');\n  let glslVersion = 100;\n  let versionLine = '';\n  let coreSource = source;\n  // Extract any version directive string from source.\n  // TODO : keep all pre-processor statements at the begining of the shader.\n  if (sourceLines[0].indexOf('#version ') === 0) {\n    glslVersion = 300; // TODO - regexp that matches atual version number\n    versionLine = sourceLines[0];\n    coreSource = sourceLines.slice(1).join('\\n');\n  } else {\n    versionLine = `#version ${glslVersion}`;\n  }\n\n  // Combine Module and Application Defines\n  const allDefines = {};\n  modules.forEach(module => {\n    Object.assign(allDefines, module.getDefines());\n  });\n  Object.assign(allDefines, defines);\n\n  // Add platform defines (use these to work around platform-specific bugs and limitations)\n  // Add common defines (GLSL version compatibility, feature detection)\n  // Add precision declaration for fragment shaders\n  let assembledSource = prologue\n    ? `\\\n${versionLine}\n${getShaderName({id, source, type})}\n${getShaderType({type})}\n${getPlatformShaderDefines(gl)}\n${getVersionDefines(gl, glslVersion, !isVertex)}\n${getApplicationDefines(allDefines)}\n${isVertex ? '' : FRAGMENT_SHADER_PROLOGUE}\n`\n    : `${versionLine}\n`;\n\n  // Add source of dependent modules in resolved order\n  let injectStandardStubs = false;\n  const hookInjections = {};\n  const mainInjections = {};\n\n  for (const key in inject) {\n    const injection =\n      typeof inject[key] === 'string' ? {injection: inject[key], order: 0} : inject[key];\n    if (key.match(/^(v|f)s:/)) {\n      if (key[3] === '#') {\n        mainInjections[key] = [injection];\n      } else {\n        hookInjections[key] = [injection];\n      }\n    } else {\n      // Regex injection\n      mainInjections[key] = [injection];\n    }\n  }\n\n  for (const module of modules) {\n    switch (module.name) {\n      case 'inject':\n        injectStandardStubs = true;\n        break;\n\n      default:\n        if (log) {\n          module.checkDeprecations(coreSource, log);\n        }\n        const moduleSource = module.getModuleSource(type, glslVersion);\n        // Add the module source, and a #define that declares it presence\n        assembledSource += moduleSource;\n\n        if (moduleInjections[type][module.name]) {\n          const injections = moduleInjections[type][module.name];\n          for (const key in injections) {\n            if (key.match(/^(v|f)s:#/)) {\n              mainInjections[key] = mainInjections[key] || [];\n              mainInjections[key].push(injections[key]);\n            } else {\n              hookInjections[key] = hookInjections[key] || [];\n              hookInjections[key].push(injections[key]);\n            }\n          }\n        }\n    }\n  }\n\n  // For injectShader\n  assembledSource += INJECT_SHADER_DECLARATIONS;\n\n  assembledSource += getHookFunctions(hookFunctions[type], hookInjections);\n\n  // Add the version directive and actual source of this shader\n  assembledSource += coreSource;\n\n  // Apply any requested shader injections\n  assembledSource = injectShader(assembledSource, type, mainInjections, injectStandardStubs);\n\n  return assembledSource;\n}\n\n// Returns a combined `getUniforms` covering the options for all the modules,\n// the created function will pass on options to the inidividual `getUniforms`\n// function of each shader module and combine the results into one object that\n// can be passed to setUniforms.\nfunction assembleGetUniforms(modules) {\n  return function getUniforms(opts) {\n    const uniforms = {};\n    for (const module of modules) {\n      // `modules` is already sorted by dependency level. This guarantees that\n      // modules have access to the uniforms that are generated by their dependencies.\n      const moduleUniforms = module.getUniforms(opts, uniforms);\n      Object.assign(uniforms, moduleUniforms);\n    }\n    return uniforms;\n  };\n}\n\n// Returns a map with module names as keys, resolving to their module definitions\n// The presence of a key indicates that the module is available in this program,\n// whether directly included, or through a dependency of some other module\nfunction assembleModuleMap(modules) {\n  const result = {};\n  for (const moduleName of modules) {\n    const shaderModule = getShaderModule(moduleName);\n    result[moduleName] = shaderModule;\n  }\n  return result;\n}\n\nfunction getShaderType({type}) {\n  return `\n#define SHADER_TYPE_${SHADER_TYPE[type].toUpperCase()}\n`;\n}\n\n// Generate \"glslify-compatible\" SHADER_NAME defines\n// These are understood by the GLSL error parsing function\n// If id is provided and no SHADER_NAME constant is present in source, create one\nfunction getShaderName({id, source, type}) {\n  const injectShaderName = id && typeof id === 'string' && source.indexOf('SHADER_NAME') === -1;\n  return injectShaderName\n    ? `\n#define SHADER_NAME ${id}_${SHADER_TYPE[type]}\n\n`\n    : '';\n}\n\n// Generates application defines from an object\nfunction getApplicationDefines(defines = {}) {\n  let count = 0;\n  let sourceText = '';\n  for (const define in defines) {\n    if (count === 0) {\n      sourceText += '\\n// APPLICATION DEFINES\\n';\n    }\n    count++;\n\n    const value = defines[define];\n    if (value || Number.isFinite(value)) {\n      sourceText += `#define ${define.toUpperCase()} ${defines[define]}\\n`;\n    }\n  }\n  if (count === 0) {\n    sourceText += '\\n';\n  }\n  return sourceText;\n}\n\nfunction getHookFunctions(hookFunctions, hookInjections) {\n  let result = '';\n  for (const hookName in hookFunctions) {\n    const hookFunction = hookFunctions[hookName];\n    result += `void ${hookFunction.signature} {\\n`;\n    if (hookFunction.header) {\n      result += `  ${hookFunction.header}`;\n    }\n    if (hookInjections[hookName]) {\n      const injections = hookInjections[hookName];\n      injections.sort((a, b) => a.order - b.order);\n      for (const injection of injections) {\n        result += `  ${injection.injection}\\n`;\n      }\n    }\n    if (hookFunction.footer) {\n      result += `  ${hookFunction.footer}`;\n    }\n    result += '}\\n';\n  }\n\n  return result;\n}\n","import ShaderModule from './shader-module';\nimport {assert} from '../utils';\n\nexport default class ShaderModuleRegistry {\n  constructor() {\n    this.shaderModules = {};\n    this.defaultShaderModules = [];\n  }\n\n  setDefaultShaderModules(modules) {\n    this.defaultShaderModules = this.resolveModules(modules);\n  }\n\n  getDefaultShaderModules() {\n    return this.defaultShaderModules;\n  }\n\n  registerShaderModules(shaderModuleList, {ignoreMultipleRegistrations = false} = {}) {\n    for (const shaderModule of shaderModuleList) {\n      this._registerShaderModule(shaderModule, ignoreMultipleRegistrations);\n    }\n  }\n\n  getShaderModule(moduleOrName) {\n    // Check if \"inline\" module, return it\n    if (moduleOrName instanceof ShaderModule) {\n      return moduleOrName;\n    }\n\n    // Check if module descriptor\n    if (typeof moduleOrName !== 'string') {\n      return this._registerShaderModule(moduleOrName, true);\n    }\n\n    // Module name - Look up module\n    const module = this.shaderModules[moduleOrName];\n    if (!module) {\n      assert(false, `Unknown shader module ${moduleOrName}`);\n    }\n    return module;\n  }\n\n  // registers any supplied modules, resolves any names into modules\n  // returns a list of modules\n  resolveModules(modules) {\n    return modules.map(moduleOrName => this.getShaderModule(moduleOrName));\n  }\n\n  // PRIVATE API\n\n  _registerShaderModule(module, ignoreMultipleRegistrations = false) {\n    // Check if \"inline\" module, return it\n    if (module instanceof ShaderModule) {\n      return module;\n    }\n\n    assert(module.name, 'shader module has no name');\n\n    if (!this.shaderModules[module.name] || ignoreMultipleRegistrations) {\n      // if ignoreMultipleRegistrations = true, we allow module to be re-registered\n      module = new ShaderModule(module);\n      module.dependencies = this.resolveModules(module.dependencies);\n      this.shaderModules[module.name] = module;\n    } else {\n      // TODO - instead verify that definition is not changing...\n      throw new Error(`shader module ${module.name} already registered`);\n    }\n\n    return this.shaderModules[module.name];\n  }\n}\n","import ShaderModuleRegistry from './shader-module-registry';\n\nconst shaderModuleRegistry = new ShaderModuleRegistry();\n\n/**\n * Registers an array of default shader modules. These will be concatenated\n * automatically at the end of any shader module list passed to\n * `assembleShaders` (plus `resolveModules` and `getShaderDependencies`)\n * @param {Object[]} modules - Array of shader modules\n */\nexport function setDefaultShaderModules(modules) {\n  shaderModuleRegistry.setDefaultShaderModules(modules);\n}\n\nexport function getDefaultShaderModules() {\n  return shaderModuleRegistry.getDefaultShaderModules();\n}\n\n/**\n * Registers an array of shader modules\n * @param {Object[]} shaderModuleList - Array of shader modules\n */\nexport function registerShaderModules(\n  shaderModuleList,\n  {ignoreMultipleRegistrations = false} = {}\n) {\n  shaderModuleRegistry.registerShaderModules(shaderModuleList, {ignoreMultipleRegistrations});\n}\n\n// registers any supplied modules and returns a list of module names\nexport function resolveModules(modules) {\n  modules = modules.concat(shaderModuleRegistry.defaultShaderModules);\n  modules = shaderModuleRegistry.resolveModules(modules);\n  return getShaderDependencies(modules);\n}\n\n// Looks up a moduleName among registered modules and returns definition.\n// If \"inline\" module, returns it directly\nexport function getShaderModule(moduleOrName) {\n  return shaderModuleRegistry.getShaderModule(moduleOrName);\n}\n\n/**\n * Takes a list of shader module names and returns a new list of\n * shader module names that includes all dependencies, sorted so\n * that modules that are dependencies of other modules come first.\n *\n * If the shader glsl code from the returned modules is concatenated\n * in the reverse order, it is guaranteed that all functions be resolved and\n * that all function and variable definitions come before use.\n *\n * @param {String[]} modules - Array of modules (inline modules or module names)\n * @return {String[]} - Array of modules\n */\nfunction getShaderDependencies(modules) {\n  const moduleMap = {};\n  const moduleDepth = {};\n  getDependencyGraph({modules, level: 0, moduleMap, moduleDepth});\n\n  // Return a reverse sort so that dependencies come before the modules that use them\n  return Object.keys(moduleDepth)\n    .sort((a, b) => moduleDepth[b] - moduleDepth[a])\n    .map(name => moduleMap[name]);\n}\n\n/**\n * Recursively checks module dpendencies to calculate dependency\n * level of each module.\n *\n * @param {String[]} modules - Array of modules\n * @param {Number} level - Current level\n * @return {result} - Map of module name to its level\n */\n// Adds another level of dependencies to the result map\nfunction getDependencyGraph({modules, level, moduleMap, moduleDepth}) {\n  if (level >= 5) {\n    throw new Error('Possible loop in shader dependency graph');\n  }\n\n  // Update level on all current modules\n  for (const module of modules) {\n    moduleMap[module.name] = module;\n    if (moduleDepth[module.name] === undefined || moduleDepth[module.name] < level) {\n      moduleDepth[module.name] = level;\n    }\n  }\n\n  // Recurse\n  for (const module of modules) {\n    if (module.dependencies) {\n      getDependencyGraph({modules: module.dependencies, level: level + 1, moduleMap, moduleDepth});\n    }\n  }\n}\n\nexport const TEST_EXPORTS = {\n  getShaderDependencies,\n  getDependencyGraph\n};\n","import {Vector3, Matrix4} from 'math.gl';\nimport {assert, uid} from '../../utils';\n\nexport default class ScenegraphNode {\n  constructor(props = {}) {\n    const {id} = props;\n\n    this.id = id || uid(this.constructor.name);\n\n    this.display = true; // whether to display the object at all\n    this.position = new Vector3();\n    this.rotation = new Vector3();\n    this.scale = new Vector3(1, 1, 1);\n    this.matrix = new Matrix4();\n    this.userData = {};\n\n    this.props = {};\n    this._setScenegraphNodeProps(props);\n  }\n\n  delete() {}\n\n  setProps(props) {\n    this._setScenegraphNodeProps(props);\n    return this;\n  }\n\n  toString() {\n    return `{type: ScenegraphNode, id: ${this.id})}`;\n  }\n\n  setPosition(position) {\n    assert(position.length === 3, 'setPosition requires vector argument');\n    this.position = position;\n    return this;\n  }\n\n  setRotation(rotation) {\n    assert(rotation.length === 3, 'setRotation requires vector argument');\n    this.rotation = rotation;\n    return this;\n  }\n\n  setScale(scale) {\n    assert(scale.length === 3, 'setScale requires vector argument');\n    this.scale = scale;\n    return this;\n  }\n\n  setMatrix(matrix, copyMatrix = true) {\n    if (copyMatrix) {\n      this.matrix.copy(matrix);\n    } else {\n      this.matrix = matrix;\n    }\n  }\n\n  setMatrixComponents({position, rotation, scale, update = true}) {\n    if (position) {\n      this.setPosition(position);\n    }\n    if (rotation) {\n      this.setRotation(rotation);\n    }\n    if (scale) {\n      this.setScale(scale);\n    }\n    if (update) {\n      this.updateMatrix();\n    }\n    return this;\n  }\n\n  updateMatrix() {\n    const pos = this.position;\n    const rot = this.rotation;\n    const scale = this.scale;\n\n    this.matrix.identity();\n    this.matrix.translate(pos);\n    this.matrix.rotateXYZ(rot);\n    this.matrix.scale(scale);\n    return this;\n  }\n\n  update({position, rotation, scale} = {}) {\n    if (position) {\n      this.setPosition(position);\n    }\n    if (rotation) {\n      this.setRotation(rotation);\n    }\n    if (scale) {\n      this.setScale(scale);\n    }\n    this.updateMatrix();\n    return this;\n  }\n\n  getCoordinateUniforms(viewMatrix, modelMatrix) {\n    // TODO - solve multiple class problem\n    // assert(viewMatrix instanceof Matrix4);\n    assert(viewMatrix);\n    modelMatrix = modelMatrix || this.matrix;\n    const worldMatrix = new Matrix4(viewMatrix).multiplyRight(modelMatrix);\n    const worldInverse = worldMatrix.invert();\n    const worldInverseTranspose = worldInverse.transpose();\n\n    return {\n      viewMatrix,\n      modelMatrix,\n      objectMatrix: modelMatrix,\n      worldMatrix,\n      worldInverseMatrix: worldInverse,\n      worldInverseTransposeMatrix: worldInverseTranspose\n    };\n  }\n\n  // TODO - copied code, not yet vetted\n  /*\n  transform() {\n    if (!this.parent) {\n      this.endPosition.set(this.position);\n      this.endRotation.set(this.rotation);\n      this.endScale.set(this.scale);\n    } else {\n      const parent = this.parent;\n      this.endPosition.set(this.position.add(parent.endPosition));\n      this.endRotation.set(this.rotation.add(parent.endRotation));\n      this.endScale.set(this.scale.add(parent.endScale));\n    }\n\n    const ch = this.children;\n    for (let i = 0; i < ch.length; ++i) {\n      ch[i].transform();\n    }\n\n    return this;\n  }\n  */\n\n  _setScenegraphNodeProps(props) {\n    if ('display' in props) {\n      this.display = props.display;\n    }\n\n    if ('position' in props) {\n      this.setPosition(props.position);\n    }\n    if ('rotation' in props) {\n      this.setRotation(props.rotation);\n    }\n    if ('scale' in props) {\n      this.setScale(props.scale);\n    }\n\n    // Matrix overwrites other props\n    if ('matrix' in props) {\n      this.setMatrix(props.matrix);\n    }\n\n    Object.assign(this.props, props);\n  }\n}\n","import GL from '@luma.gl/constants';\nimport {Buffer} from '@luma.gl/webgl';\nimport {assert} from '../utils';\n\n// Support for mapping new geometries with glTF attribute names to \"classic\" luma.gl shader names\nconst GLTF_TO_LUMA_ATTRIBUTE_MAP = {\n  POSITION: 'positions',\n  NORMAL: 'normals',\n  COLOR_0: 'colors',\n  TEXCOORD_0: 'texCoords',\n  TEXCOORD_1: 'texCoords1',\n  TEXCOORD_2: 'texCoords2'\n};\n\nexport function getBuffersFromGeometry(gl, geometry, options) {\n  const buffers = {};\n  let indices = geometry.indices;\n\n  for (const name in geometry.attributes) {\n    const attribute = geometry.attributes[name];\n    const remappedName = mapAttributeName(name, options);\n\n    if (name === 'indices') {\n      indices = attribute;\n    } else if (attribute.constant) {\n      buffers[remappedName] = attribute.value;\n    } else {\n      const typedArray = attribute.value;\n      // Create accessor by copying the attribute and removing `value``\n      const accessor = {...attribute};\n      delete accessor.value;\n      buffers[remappedName] = [new Buffer(gl, typedArray), accessor];\n\n      inferAttributeAccessor(name, accessor);\n    }\n  }\n\n  if (indices) {\n    const data = indices.value || indices;\n    assert(\n      data instanceof Uint16Array || data instanceof Uint32Array,\n      'attribute array for \"indices\" must be of integer type'\n    );\n    const accessor = {\n      size: 1,\n      isIndexed: indices.isIndexed === undefined ? true : indices.isIndexed\n    };\n    buffers.indices = [\n      new Buffer(gl, {\n        data,\n        target: GL.ELEMENT_ARRAY_BUFFER\n      }),\n      accessor\n    ];\n  }\n\n  return buffers;\n}\n\nfunction mapAttributeName(name, options) {\n  const {attributeMap = GLTF_TO_LUMA_ATTRIBUTE_MAP} = options || {};\n  return (attributeMap && attributeMap[name]) || name;\n}\n\n// Check for well known attribute names\n// eslint-disable-next-line complexity\nexport function inferAttributeAccessor(attributeName, attribute) {\n  let category;\n  switch (attributeName) {\n    case 'texCoords':\n    case 'texCoord1':\n    case 'texCoord2':\n    case 'texCoord3':\n      category = 'uvs';\n      break;\n    case 'vertices':\n    case 'positions':\n    case 'normals':\n    case 'pickingColors':\n      category = 'vectors';\n      break;\n    default:\n  }\n\n  // Check for categorys\n  switch (category) {\n    case 'vectors':\n      attribute.size = attribute.size || 3;\n      break;\n    case 'uvs':\n      attribute.size = attribute.size || 2;\n      break;\n    default:\n  }\n\n  assert(Number.isFinite(attribute.size), `attribute ${attributeName} needs size`);\n}\n","import {assembleShaders} from '@luma.gl/shadertools';\nimport {Program} from '@luma.gl/webgl';\n\nexport default class ProgramManager {\n  static getDefaultProgramManager(gl) {\n    gl.luma = gl.luma || {};\n    gl.luma.defaultProgramManager = gl.luma.defaultProgramManager || new ProgramManager(gl);\n\n    return gl.luma.defaultProgramManager;\n  }\n\n  constructor(gl) {\n    this.gl = gl;\n\n    this._programCache = {};\n    this._getUniforms = {};\n    this._registeredModules = {};\n    this._moduleInjections = {\n      vs: {},\n      fs: {}\n    };\n    this._hookFunctions = {\n      vs: {},\n      fs: {}\n    };\n    this._defaultModules = [];\n\n    this._hashes = {};\n    this._hashCounter = 0;\n    this.stateHash = 0; // Used change hashing if hooks are modified\n    this._useCounts = {};\n  }\n\n  addDefaultModule(module) {\n    if (!this._defaultModules.find(m => m.name === module.name)) {\n      this._defaultModules.push(module);\n    }\n\n    this.stateHash++;\n  }\n\n  removeDefaultModule(module) {\n    const moduleName = typeof module === 'string' ? module : module.name;\n    this._defaultModules = this._defaultModules.filter(m => m.name !== moduleName);\n    this.stateHash++;\n  }\n\n  addModuleInjection(module, opts) {\n    const moduleName = typeof module === 'string' ? module : module.name;\n    const {hook, injection, order = 0} = opts;\n    const shaderStage = hook.slice(0, 2);\n\n    const moduleInjections = this._moduleInjections[shaderStage];\n    moduleInjections[moduleName] = moduleInjections[moduleName] || {};\n\n    moduleInjections[moduleName][hook] = {\n      injection,\n      order\n    };\n\n    this.stateHash++;\n  }\n\n  addShaderHook(hook, opts = {}) {\n    hook = hook.trim();\n    const [stage, signature] = hook.split(':');\n    const name = hook.replace(/\\(.+/, '');\n    this._hookFunctions[stage][name] = Object.assign(opts, {signature});\n\n    this.stateHash++;\n  }\n\n  get(props = {}) {\n    const {vs = '', fs = '', defines = {}, inject = {}, varyings = [], bufferMode = 0x8c8d} = props; // varyings/bufferMode for xform feedback, 0x8c8d = SEPARATE_ATTRIBS\n\n    const modules = this._getModuleList(props.modules); // Combine with default modules\n\n    const vsHash = this._getHash(vs);\n    const fsHash = this._getHash(fs);\n    const moduleHashes = modules.map(m => this._getHash(typeof m === 'string' ? m : m.name)).sort();\n    const varyingHashes = varyings.map(v => this._getHash(v));\n\n    const defineKeys = Object.keys(defines).sort();\n    const injectKeys = Object.keys(inject).sort();\n    const defineHashes = [];\n    const injectHashes = [];\n\n    for (const key of defineKeys) {\n      defineHashes.push(this._getHash(key));\n      defineHashes.push(this._getHash(defines[key]));\n    }\n\n    for (const key of injectKeys) {\n      defineHashes.push(this._getHash(key));\n      defineHashes.push(this._getHash(inject[key]));\n    }\n\n    const hash = `${vsHash}/${fsHash}D${defineHashes.join('/')}M${moduleHashes.join(\n      '/'\n    )}I${injectHashes.join('/')}V${varyingHashes.join('/')}H${this.stateHash}B${bufferMode}`;\n\n    if (!this._programCache[hash]) {\n      const assembled = assembleShaders(this.gl, {\n        vs,\n        fs,\n        modules,\n        inject,\n        defines,\n        hookFunctions: this._hookFunctions,\n        moduleInjections: this._moduleInjections\n      });\n\n      this._programCache[hash] = new Program(this.gl, {\n        hash,\n        vs: assembled.vs,\n        fs: assembled.fs,\n        varyings,\n        bufferMode\n      });\n\n      this._getUniforms[hash] = assembled.getUniforms || (x => {});\n      this._useCounts[hash] = 0;\n    }\n\n    this._useCounts[hash]++;\n\n    return this._programCache[hash];\n  }\n\n  getUniforms(program) {\n    return this._getUniforms[program.hash] || null;\n  }\n\n  release(program) {\n    const hash = program.hash;\n    this._useCounts[hash]--;\n\n    if (this._useCounts[hash] === 0) {\n      this._programCache[hash].delete();\n      delete this._programCache[hash];\n      delete this._getUniforms[hash];\n      delete this._useCounts[hash];\n    }\n  }\n\n  _getHash(key) {\n    if (this._hashes[key] === undefined) {\n      this._hashes[key] = this._hashCounter++;\n    }\n\n    return this._hashes[key];\n  }\n\n  // Dedup and combine with default modules\n  _getModuleList(appModules = []) {\n    const modules = new Array(this._defaultModules.length + appModules.length);\n    const seen = {};\n    let count = 0;\n\n    for (let i = 0, len = this._defaultModules.length; i < len; ++i) {\n      const module = this._defaultModules[i];\n      const name = typeof module === 'string' ? module : module.name;\n      modules[count++] = module;\n      seen[name] = true;\n    }\n\n    for (let i = 0, len = appModules.length; i < len; ++i) {\n      const module = appModules[i];\n      const name = typeof module === 'string' ? module : module.name;\n      if (!seen[name]) {\n        modules[count++] = module;\n        seen[name] = true;\n      }\n    }\n\n    modules.length = count;\n\n    return modules;\n  }\n}\n","// TODO / DEPRECATED - delete when confident that probe.gl logging implements all opts\n/* eslint-disable no-console */\nfunction formatArrayValue(v, opts) {\n  const {maxElts = 16, size = 1} = opts;\n  let string = '[';\n  for (let i = 0; i < v.length && i < maxElts; ++i) {\n    if (i > 0) {\n      string += `,${i % size === 0 ? ' ' : ''}`;\n    }\n    string += formatValue(v[i], opts);\n  }\n  const terminator = v.length > maxElts ? '...' : ']';\n  return `${string}${terminator}`;\n}\n\nexport function formatValue(v, opts = {}) {\n  const EPSILON = 1e-16;\n  const {isInteger = false} = opts;\n  if (Array.isArray(v) || ArrayBuffer.isView(v)) {\n    return formatArrayValue(v, opts);\n  }\n  if (!Number.isFinite(v)) {\n    return String(v);\n  }\n  if (Math.abs(v) < EPSILON) {\n    return isInteger ? '0' : '0.';\n  }\n  if (isInteger) {\n    return v.toFixed(0);\n  }\n  if (Math.abs(v) > 100 && Math.abs(v) < 10000) {\n    return v.toFixed(0);\n  }\n  const string = v.toPrecision(2);\n  const decimal = string.indexOf('.0');\n  return decimal === string.length - 2 ? string.slice(0, -1) : string;\n}\n","import Buffer from '../classes/buffer';\nimport {getKey} from '../webgl-utils';\nimport {getCompositeGLType} from '../webgl-utils/attribute-utils';\nimport {formatValue} from '../utils';\n\n// Creates object suitable as input for console.table\nexport function getDebugTableForVertexArray({vertexArray, header = 'Attributes'} = {}) {\n  if (!vertexArray.configuration) {\n    return {};\n  }\n\n  const table = {}; // {[header]: {}};\n\n  // Add index (elements) if available\n  if (vertexArray.elements) {\n    // const elements = Object.assign({size: 1}, vertexArray.elements);\n    table.ELEMENT_ARRAY_BUFFER = getDebugTableRow(vertexArray, vertexArray.elements, null, header);\n  }\n\n  // Add used attributes\n  const attributes = vertexArray.values;\n\n  for (const attributeLocation in attributes) {\n    const info = vertexArray._getAttributeInfo(attributeLocation);\n    if (info) {\n      let rowHeader = `${attributeLocation}: ${info.name}`;\n      const accessor = vertexArray.accessors[info.location];\n      if (accessor) {\n        rowHeader = `${attributeLocation}: ${getGLSLDeclaration(info.name, accessor)}`;\n      }\n      table[rowHeader] = getDebugTableRow(\n        vertexArray,\n        attributes[attributeLocation],\n        accessor,\n        header\n      );\n    }\n  }\n\n  return table;\n}\n\n/* eslint-disable max-statements */\nfunction getDebugTableRow(vertexArray, attribute, accessor, header) {\n  const {gl} = vertexArray;\n\n  if (!attribute) {\n    return {\n      [header]: 'null',\n      'Format ': 'N/A'\n    };\n  }\n\n  let type = 'NOT PROVIDED';\n  let size = 'N/A';\n  let verts = 'N/A';\n  let bytes = 'N/A';\n\n  let isInteger;\n  let marker;\n  let value;\n\n  if (accessor) {\n    type = accessor.type;\n    size = accessor.size;\n\n    // Generate a type name by dropping Array from Float32Array etc.\n    type = String(type).replace('Array', '');\n\n    // Look for 'nt' to detect integer types, e.g. Int32Array, Uint32Array\n    isInteger = type.indexOf('nt') !== -1;\n  }\n\n  if (attribute instanceof Buffer) {\n    const buffer = attribute;\n\n    const {data, modified} = buffer.getDebugData();\n    marker = modified ? '*' : '';\n\n    value = data;\n    bytes = buffer.byteLength;\n    verts = bytes / data.BYTES_PER_ELEMENT / size;\n\n    let format;\n\n    if (accessor) {\n      const instanced = accessor.divisor > 0;\n      format = `${instanced ? 'I ' : 'P '} ${verts} (x${size}=${bytes} bytes ${getKey(gl, type)})`;\n    } else {\n      // element buffer\n      isInteger = true;\n      format = `${bytes} bytes`;\n    }\n\n    return {\n      [header]: `${marker}${formatValue(value, {size, isInteger})}`,\n      'Format ': format\n    };\n  }\n\n  // CONSTANT VALUE\n  value = attribute;\n  size = attribute.length;\n  // Generate a type name by dropping Array from Float32Array etc.\n  type = String(attribute.constructor.name).replace('Array', '');\n  // Look for 'nt' to detect integer types, e.g. Int32Array, Uint32Array\n  isInteger = type.indexOf('nt') !== -1;\n\n  return {\n    [header]: `${formatValue(value, {size, isInteger})} (constant)`,\n    'Format ': `${size}x${type} (constant)`\n  };\n}\n/* eslint-ensable max-statements */\n\nfunction getGLSLDeclaration(name, accessor) {\n  const {type, size} = accessor;\n  const typeAndName = getCompositeGLType(type, size);\n  return typeAndName ? `${name} (${typeAndName.name})` : name;\n}\n","import {formatValue, assert} from '../utils';\n\n// Prepares a table suitable for console.table\n/* eslint-disable max-statements, complexity */\nexport function getDebugTableForUniforms({\n  header = 'Uniforms',\n  program,\n  uniforms,\n  undefinedOnly = false\n} = {}) {\n  assert(program);\n\n  const SHADER_MODULE_UNIFORM_REGEXP = '.*_.*';\n  const PROJECT_MODULE_UNIFORM_REGEXP = '.*Matrix'; // TODO - Use explicit list\n\n  const uniformLocations = program._uniformSetters;\n  const table = {}; // {[header]: {}};\n\n  // Add program's provided uniforms (in alphabetical order)\n  const uniformNames = Object.keys(uniformLocations).sort();\n\n  let count = 0;\n\n  // First add non-underscored uniforms (assumed not coming from shader modules)\n  for (const uniformName of uniformNames) {\n    if (\n      !uniformName.match(SHADER_MODULE_UNIFORM_REGEXP) &&\n      !uniformName.match(PROJECT_MODULE_UNIFORM_REGEXP)\n    ) {\n      if (addUniformToTable({table, header, uniforms, uniformName, undefinedOnly})) {\n        count++;\n      }\n    }\n  }\n\n  // add underscored uniforms (assumed from shader modules)\n  for (const uniformName of uniformNames) {\n    if (uniformName.match(PROJECT_MODULE_UNIFORM_REGEXP)) {\n      if (addUniformToTable({table, header, uniforms, uniformName, undefinedOnly})) {\n        count++;\n      }\n    }\n  }\n\n  for (const uniformName of uniformNames) {\n    if (!table[uniformName]) {\n      if (addUniformToTable({table, header, uniforms, uniformName, undefinedOnly})) {\n        count++;\n      }\n    }\n  }\n\n  // Create a table of unused uniforms\n  let unusedCount = 0;\n  const unusedTable = {};\n  if (!undefinedOnly) {\n    for (const uniformName in uniforms) {\n      const uniform = uniforms[uniformName];\n      if (!table[uniformName]) {\n        unusedCount++;\n        unusedTable[uniformName] = {\n          Type: `NOT USED: ${uniform}`,\n          [header]: formatValue(uniform)\n        };\n      }\n    }\n  }\n\n  return {table, count, unusedTable, unusedCount};\n}\n\n// Helper\nfunction addUniformToTable({table, header, uniforms, uniformName, undefinedOnly}) {\n  const value = uniforms[uniformName];\n  const isDefined = isUniformDefined(value);\n  if (!undefinedOnly || !isDefined) {\n    table[uniformName] = {\n      // Add program's unprovided uniforms\n      [header]: isDefined ? formatValue(value) : 'N/A',\n      'Uniform Type': isDefined ? value : 'NOT PROVIDED'\n    };\n    return true;\n  }\n  return false;\n}\n\nfunction isUniformDefined(value) {\n  return value !== undefined && value !== null;\n}\n","import {getCompositeGLType} from '../webgl-utils/attribute-utils';\n\nexport function getDebugTableForProgramConfiguration(config) {\n  const table = {};\n\n  const header = `Accessors for ${config.id}`;\n\n  for (const attributeInfo of config.attributeInfos) {\n    if (attributeInfo) {\n      const glslDeclaration = getGLSLDeclaration(attributeInfo);\n      table[`in ${glslDeclaration}`] = {[header]: JSON.stringify(attributeInfo.accessor)};\n    }\n  }\n\n  for (const varyingInfo of config.varyingInfos) {\n    if (varyingInfo) {\n      const glslDeclaration = getGLSLDeclaration(varyingInfo);\n      table[`out ${glslDeclaration}`] = {[header]: JSON.stringify(varyingInfo.accessor)};\n    }\n  }\n\n  return table;\n}\n\nfunction getGLSLDeclaration(attributeInfo) {\n  const {type, size} = attributeInfo.accessor;\n  const typeAndName = getCompositeGLType(type, size);\n  if (typeAndName) {\n    return `${typeAndName.name} ${attributeInfo.name}`;\n  }\n  return attributeInfo.name;\n}\n","import seer from 'seer';\n\nimport {window} from '../utils';\n\nconst models = {};\n\n/**\n * Add a model to our cache indexed by id\n */\nexport const addModel = model => {\n  if (models[model.id]) {\n    return;\n  }\n  models[model.id] = model;\n\n  seer.listItem('luma.gl', model.id);\n};\n\n/**\n * Log a model uniforms and attributes.\n */\nexport const logModel = (model, uniforms) => {\n  if (!seer.isReady() || seer.throttle(`luma.gl:${model.id}`, 1e3)) {\n    return;\n  }\n\n  const attributesObject = model.geometry\n    ? Object.assign({}, model.geometry.attributes, model.attributes)\n    : model.attributes;\n  const uniformsObject = Object.assign({}, model.uniforms, uniforms);\n\n  seer.multiUpdate('luma.gl', model.id, [\n    {path: 'objects.uniforms', data: uniformsObject},\n    {path: 'objects.attributes', data: attributesObject}\n  ]);\n};\n\n/**\n * Remove a previously set model from the cache\n */\nexport const removeModel = id => {\n  delete models[id];\n  seer.deleteItem('luma.gl', id);\n};\n\n/**\n * Recursively traverse an object given a path of properties and set the given value\n */\nconst recursiveSet = (obj, path, value) => {\n  if (!obj) {\n    return;\n  }\n\n  if (path.length > 1) {\n    recursiveSet(obj[path[0]], path.slice(1), value);\n  } else {\n    obj[path[0]] = value;\n  }\n};\n\nconst overrides = new Map();\n\n/**\n * Create an override on the specify layer, indexed by a valuePath array.\n * Do nothing in case Seer as not been initialized to prevent any preformance drawback.\n */\nexport const setOverride = (id, valuePath, value) => {\n  if (!window.__SEER_INITIALIZED__) {\n    return;\n  }\n\n  if (!overrides.has(id)) {\n    overrides.set(id, new Map());\n  }\n\n  const uniforms = overrides.get(id);\n  uniforms.set(valuePath, value);\n};\n\n/**\n * Apply overrides to a specific model's uniforms\n */\nexport const getOverrides = (id, uniforms) => {\n  if (!window.__SEER_INITIALIZED__ || !id) {\n    return;\n  }\n\n  const overs = overrides.get(id);\n  if (!overs) {\n    return;\n  }\n\n  overs.forEach((value, valuePath) => {\n    recursiveSet(uniforms, valuePath, value);\n  });\n};\n\n/**\n * Listen for luma.gl edit events\n */\nseer.listenFor('luma.gl', payload => {\n  const model = models[payload.itemKey];\n  if (!model || payload.type !== 'edit' || payload.valuePath[0] !== 'uniforms') {\n    return;\n  }\n\n  const valuePath = payload.valuePath.slice(1);\n  setOverride(payload.itemKey, valuePath, payload.value);\n\n  const uniforms = model.getUniforms();\n  recursiveSet(uniforms, valuePath, payload.value);\n  model.setUniforms(uniforms);\n});\n","/* eslint-disable complexity */\n// Shared code between Model and MeshModel\nimport ProgramManager from '../resource-management/program-manager';\nimport {isWebGL, Query, Program, VertexArray, clear} from '@luma.gl/webgl';\nimport {MODULAR_SHADERS} from '@luma.gl/shadertools';\nimport {\n  getDebugTableForUniforms,\n  getDebugTableForVertexArray,\n  getDebugTableForProgramConfiguration\n} from '@luma.gl/webgl';\nimport {addModel, removeModel, logModel, getOverrides} from '../debug/seer-integration';\nimport {log, isObjectEmpty, uid, assert} from '../utils';\n\nconst LOG_DRAW_PRIORITY = 2;\nconst LOG_DRAW_TIMEOUT = 10000;\n\n// Model abstract O3D Class\nexport default class BaseModel {\n  constructor(gl, props = {}) {\n    assert(isWebGL(gl));\n    const {id = uid('base-model')} = props;\n    this.id = id;\n    this.gl = gl;\n    this.id = props.id || uid('Model');\n    this.lastLogTime = 0; // TODO - move to probe.gl\n    this.initialize(props);\n  }\n\n  initialize(props) {\n    this.props = {};\n\n    if (props.shaderCache) {\n      log.warn('ShaderCache property is deprecated')();\n    }\n\n    this.programManager = props.programManager || ProgramManager.getDefaultProgramManager(this.gl);\n    this._programManagerState = -1;\n    this._managedProgram = false;\n\n    const {program = null, vs, fs, modules, defines, inject, varyings, bufferMode} = props;\n\n    this.programProps = {program, vs, fs, modules, defines, inject, varyings, bufferMode};\n    this.program = null;\n    this.vertexArray = null;\n    this._programDirty = true;\n\n    // Initialize state\n    this.userData = {};\n    this.needsRedraw = true;\n\n    // Attributes and buffers\n    // Model manages auto Buffer creation from typed arrays\n    this._attributes = {}; // All attributes\n    this.attributes = {}; // User defined attributes\n\n    // Model manages uniform animation\n    this.uniforms = {};\n    this.animatedUniforms = {};\n    this.animated = false;\n    this.animationLoop = null; // if set, used as source for animationProps\n\n    this.timerQueryEnabled = false;\n    this.timeElapsedQuery = undefined;\n    this.lastQueryReturned = true;\n\n    this.stats = {\n      accumulatedFrameTime: 0,\n      averageFrameTime: 0,\n      profileFrameCount: 0\n    };\n\n    // picking options\n    this.pickable = true;\n\n    this._checkProgram();\n\n    this._setBaseModelProps(props);\n\n    this.setUniforms(\n      Object.assign(\n        {},\n        this.getModuleUniforms(props.moduleSettings) // Get unforms for supplied parameters\n      )\n    );\n  }\n\n  setProps(props) {\n    this._setBaseModelProps(props);\n  }\n\n  delete() {\n    // delete all attributes created by this model\n    // TODO - should buffer deletes be handled by vertex array?\n    for (const key in this._attributes) {\n      if (this._attributes[key] !== this.attributes[key]) {\n        this._attributes[key].delete();\n      }\n    }\n\n    if (this._managedProgram) {\n      this.programManager.release(this.program);\n    }\n\n    this.vertexArray.delete();\n\n    removeModel(this.id);\n  }\n\n  // GETTERS\n\n  isAnimated() {\n    return this.animated;\n  }\n\n  getProgram() {\n    return this.program;\n  }\n\n  setProgram(props) {\n    this.programProps = Object.assign({}, props);\n    this._programDirty = true;\n  }\n\n  getUniforms() {\n    return this.uniforms;\n  }\n\n  // SETTERS\n\n  // TODO - should actually set the uniforms\n  setUniforms(uniforms = {}) {\n    // Let Seer override edited uniforms\n    uniforms = Object.assign({}, uniforms);\n    getOverrides(this.id, uniforms);\n\n    // Resolve any animated uniforms so that we have an initial value\n    uniforms = this._extractAnimatedUniforms(uniforms);\n\n    Object.assign(this.uniforms, uniforms);\n\n    return this;\n  }\n\n  getModuleUniforms(opts) {\n    this._checkProgram();\n\n    const getUniforms = this.programManager.getUniforms(this.program);\n\n    if (getUniforms) {\n      return getUniforms(opts);\n    }\n\n    return {};\n  }\n\n  updateModuleSettings(opts) {\n    const uniforms = this.getModuleUniforms(opts || {});\n    return this.setUniforms(uniforms);\n  }\n\n  // DRAW CALLS\n\n  clear(opts) {\n    clear(this.program.gl, opts);\n    return this;\n  }\n\n  /* eslint-disable max-statements  */\n  drawGeometry(opts = {}) {\n    // Lazy update program and vertex array\n    this._checkProgram();\n\n    const {\n      moduleSettings = null,\n      framebuffer,\n      uniforms = {},\n      attributes = {},\n      transformFeedback = this.transformFeedback,\n      parameters = {},\n      vertexArray = this.vertexArray,\n      animationProps\n    } = opts;\n\n    addModel(this);\n\n    // Update model with any just provided attributes, settings or uniforms\n    this.setAttributes(attributes);\n    this.updateModuleSettings(moduleSettings);\n    this.setUniforms(uniforms);\n\n    // Animate any function valued uniforms\n    this._refreshAnimationProps(animationProps);\n\n    const logPriority = this._logDrawCallStart(2);\n\n    const drawParams = this.vertexArray.getDrawParams(this.props);\n    if (drawParams.isInstanced && !this.isInstanced) {\n      log.warn('Found instanced attributes on non-instanced model', this.id)();\n    }\n\n    const {isIndexed, indexType, indexOffset} = drawParams;\n    const {isInstanced, instanceCount} = this;\n\n    const noop = () => {};\n    const {onBeforeRender = noop, onAfterRender = noop} = this.props;\n\n    onBeforeRender();\n\n    this._timerQueryStart();\n\n    this.program.setUniforms(this.uniforms);\n\n    const didDraw = this.program.draw(\n      Object.assign({}, opts, {\n        logPriority,\n        uniforms: null, // Already set (may contain \"function values\" not understood by Program)\n        framebuffer,\n        parameters,\n        drawMode: this.getDrawMode(),\n        vertexCount: this.getVertexCount(),\n        vertexArray,\n        transformFeedback,\n        isIndexed,\n        indexType,\n        isInstanced,\n        instanceCount,\n        offset: isIndexed ? indexOffset : 0\n      })\n    );\n\n    this._timerQueryEnd();\n\n    onAfterRender();\n\n    this._logDrawCallEnd(logPriority, vertexArray, framebuffer);\n\n    return didDraw;\n  }\n  /* eslint-enable max-statements  */\n\n  // PRIVATE METHODS\n\n  // eslint-disable-next-line max-statements, complexity\n  _setBaseModelProps(props) {\n    Object.assign(this.props, props);\n\n    if ('uniforms' in props) {\n      this.setUniforms(props.uniforms);\n    }\n\n    if ('pickable' in props) {\n      this.pickable = props.pickable;\n    }\n\n    // if ('onBeforeRender' in props) {}\n    // if ('onAfterRender' in props) {}\n\n    // Experimental props\n    if ('timerQueryEnabled' in props) {\n      this.timerQueryEnabled = props.timerQueryEnabled && Query.isSupported(this.gl, ['timers']);\n      if (props.timerQueryEnabled && !this.timerQueryEnabled) {\n        log.warn('GPU timer not supported')();\n      }\n    }\n\n    if ('_animationProps' in props) {\n      this._setAnimationProps(props._animationProps);\n    }\n\n    if ('_animationLoop' in props) {\n      this.animationLoop = props._animationLoop;\n    }\n  }\n\n  _checkProgram(shaderCache = null) {\n    const needsUpdate =\n      this._programDirty || this.programManager.stateHash !== this._programManagerState;\n\n    if (!needsUpdate) {\n      return;\n    }\n\n    let {program} = this.programProps;\n\n    if (program) {\n      this._managedProgram = false;\n    } else {\n      const {\n        // TODO(Tarek): Are these actually used anywhere?\n        vs = MODULAR_SHADERS.vs,\n        fs = MODULAR_SHADERS.fs,\n        modules,\n        inject,\n        defines,\n        varyings,\n        bufferMode\n      } = this.programProps;\n      program = this.programManager.get({vs, fs, modules, inject, defines, varyings, bufferMode});\n      if (this.program && this._managedProgram) {\n        this.programManager.release(this.program);\n      }\n      this._programManagerState = this.programManager.stateHash;\n      this._managedProgram = true;\n    }\n\n    assert(program instanceof Program, 'Model needs a program');\n\n    this._programDirty = false;\n\n    if (program === this.program) {\n      return;\n    }\n\n    this.program = program;\n\n    if (this.vertexArray) {\n      this.vertexArray.setProps({program: this.program, attributes: this.vertexArray.attributes});\n    } else {\n      this.vertexArray = new VertexArray(this.gl, {program: this.program});\n    }\n\n    // Make sure we have some reasonable default uniforms in place\n    this.setUniforms(\n      Object.assign(\n        {},\n        this.getModuleUniforms() // Get all default uniforms,\n      )\n    );\n  }\n\n  // Refreshes animated uniforms, attempting to get animated props from animationLoop if registered\n  _refreshAnimationProps(animationProps) {\n    // Try to read animationProps\n    animationProps = animationProps || (this.animationLoop && this.animationLoop.animationProps);\n    if (animationProps) {\n      this._setAnimationProps(animationProps);\n    }\n  }\n\n  // Calculate new values for any function uniforms based on supplied animationProps\n  _evaluateAnimateUniforms(animationProps) {\n    if (!this.animated) {\n      return {};\n    }\n    const animatedUniforms = {};\n    for (const uniformName in this.animatedUniforms) {\n      const valueFunction = this.animatedUniforms[uniformName];\n      animatedUniforms[uniformName] = valueFunction(animationProps);\n    }\n    return animatedUniforms;\n  }\n\n  // Extracts a list of function valued uniforms, so we can update them before each draw call\n  // Also removes such uniforms from the returned list\n  _extractAnimatedUniforms(uniforms) {\n    let foundAnimated = false;\n\n    // Keep our animatedUniforms map up-to-date\n    for (const uniformName in uniforms) {\n      const newValue = uniforms[uniformName];\n      if (typeof newValue === 'function') {\n        this.animatedUniforms[uniformName] = newValue;\n        foundAnimated = true;\n      } else {\n        delete this.animatedUniforms[uniformName];\n      }\n    }\n\n    // Update animated flag: `Model` is animated if any uniforms are animated (i.e. functions)\n    this.animated = !isObjectEmpty(this.animatedUniforms);\n\n    if (!foundAnimated) {\n      return uniforms;\n    }\n\n    // If animated uniforms were found, remove them from ordinary uniform list\n    // `Program` class can't (and shouldn't) handle function valued uniforms\n    const staticUniforms = {};\n    for (const uniformName in uniforms) {\n      if (!this.animatedUniforms[uniformName]) {\n        staticUniforms[uniformName] = uniforms[uniformName];\n      }\n    }\n    return staticUniforms;\n  }\n\n  // Timer Queries\n\n  _timerQueryStart() {\n    if (this.timerQueryEnabled === true) {\n      if (!this.timeElapsedQuery) {\n        this.timeElapsedQuery = new Query(this.gl);\n      }\n      if (this.lastQueryReturned) {\n        this.lastQueryReturned = false;\n        this.timeElapsedQuery.beginTimeElapsedQuery();\n      }\n    }\n  }\n\n  _timerQueryEnd() {\n    if (this.timerQueryEnabled === true) {\n      this.timeElapsedQuery.end();\n      // TODO: Skip results if 'gl.getParameter(this.ext.GPU_DISJOINT_EXT)' returns false\n      // should this be incorporated into Query object?\n      if (this.timeElapsedQuery.isResultAvailable()) {\n        this.lastQueryReturned = true;\n        const elapsedTime = this.timeElapsedQuery.getTimerMilliseconds();\n\n        // Update stats (e.g. for seer)\n        this.stats.lastFrameTime = elapsedTime;\n        this.stats.accumulatedFrameTime += elapsedTime;\n        this.stats.profileFrameCount++;\n        this.stats.averageFrameTime =\n          this.stats.accumulatedFrameTime / this.stats.profileFrameCount;\n\n        // Log stats\n        log.log(\n          LOG_DRAW_PRIORITY,\n          `\\\nGPU time ${this.program.id}: ${this.stats.lastFrameTime}ms \\\naverage ${this.stats.averageFrameTime}ms \\\naccumulated: ${this.stats.accumulatedFrameTime}ms \\\ncount: ${this.stats.profileFrameCount}`\n        )();\n      }\n    }\n  }\n\n  _logDrawCallStart(priority) {\n    const logDrawTimeout = priority > 3 ? 0 : LOG_DRAW_TIMEOUT;\n    if (log.priority < priority || Date.now() - this.lastLogTime < logDrawTimeout) {\n      return undefined;\n    }\n\n    this.lastLogTime = Date.now();\n\n    log.group(LOG_DRAW_PRIORITY, `>>> DRAWING MODEL ${this.id}`, {collapsed: log.priority <= 2})();\n\n    return priority;\n  }\n\n  _logDrawCallEnd(priority, vertexArray, uniforms, framebuffer) {\n    // HACK: priority === undefined means logDrawCallStart didn't run\n    if (priority === undefined) {\n      return;\n    }\n\n    const attributeTable = getDebugTableForVertexArray({\n      vertexArray,\n      header: `${this.id} attributes`,\n      attributes: this._attributes\n    });\n\n    const {table: uniformTable, unusedTable, unusedCount} = getDebugTableForUniforms({\n      header: `${this.id} uniforms`,\n      program: this.program,\n      uniforms: Object.assign({}, this.program.uniforms, uniforms)\n    });\n\n    // log missing uniforms\n    const {table: missingTable, count: missingCount} = getDebugTableForUniforms({\n      header: `${this.id} uniforms`,\n      program: this.program,\n      uniforms: Object.assign({}, this.program.uniforms, uniforms),\n      undefinedOnly: true\n    });\n\n    if (missingCount > 0) {\n      log.log('MISSING UNIFORMS', Object.keys(missingTable))();\n      // log.table(priority, missingTable)();\n    }\n    if (unusedCount > 0) {\n      log.log('UNUSED UNIFORMS', Object.keys(unusedTable))();\n      // log.log(priority, 'Unused uniforms ', unusedTable)();\n    }\n\n    const configTable = getDebugTableForProgramConfiguration(this.vertexArray.configuration);\n\n    log.table(priority, attributeTable)();\n\n    log.table(priority, uniformTable)();\n\n    log.table(priority + 1, configTable)();\n\n    logModel(this, uniforms);\n\n    if (framebuffer) {\n      framebuffer.log({priority: LOG_DRAW_PRIORITY, message: `Rendered to ${framebuffer.id}`});\n    }\n\n    log.groupEnd(LOG_DRAW_PRIORITY, `>>> DRAWING MODEL ${this.id}`)();\n  }\n}\n","import GL from '@luma.gl/constants';\nimport {TransformFeedback, Buffer} from '@luma.gl/webgl';\nimport {getBuffersFromGeometry} from './model-utils';\nimport BaseModel from './base-model';\nimport {log, isObjectEmpty, uid, assert} from '../utils';\n\nconst ERR_MODEL_PARAMS = 'Model needs drawMode and vertexCount';\n\nexport default class Model extends BaseModel {\n  constructor(gl, props = {}) {\n    // Deduce a helpful id\n    const {id = uid('model')} = props;\n    super(gl, {...props, id});\n  }\n\n  initialize(props) {\n    super.initialize(props);\n\n    this.drawMode = props.drawMode !== undefined ? props.drawMode : GL.TRIANGLES;\n    this.vertexCount = props.vertexCount || 0;\n\n    // Track buffers created by setGeometry\n    this.geometryBuffers = {};\n\n    // geometry might have set drawMode and vertexCount\n    this.isInstanced = props.isInstanced || props.instanced;\n\n    this._setModelProps(props);\n\n    // TODO - just to unbreak deck.gl 7.0-beta, remove as soon as updated\n    this.geometry = {};\n\n    // assert(program || program instanceof Program);\n    assert(this.drawMode !== undefined && Number.isFinite(this.vertexCount), ERR_MODEL_PARAMS);\n  }\n\n  setProps(props) {\n    super.setProps(props);\n    this._setModelProps(props);\n  }\n\n  delete() {\n    super.delete();\n\n    this._deleteGeometryBuffers();\n  }\n\n  // GETTERS\n\n  getDrawMode() {\n    return this.drawMode;\n  }\n\n  getVertexCount() {\n    return this.vertexCount;\n  }\n\n  getInstanceCount() {\n    return this.instanceCount;\n  }\n\n  getAttributes() {\n    return this.attributes;\n  }\n\n  // SETTERS\n\n  setDrawMode(drawMode) {\n    this.drawMode = drawMode;\n    return this;\n  }\n\n  setVertexCount(vertexCount) {\n    assert(Number.isFinite(vertexCount));\n    this.vertexCount = vertexCount;\n    return this;\n  }\n\n  setInstanceCount(instanceCount) {\n    assert(Number.isFinite(instanceCount));\n    this.instanceCount = instanceCount;\n    return this;\n  }\n\n  setGeometry(geometry) {\n    this.drawMode = geometry.drawMode;\n    this.vertexCount = geometry.getVertexCount();\n\n    this._deleteGeometryBuffers();\n\n    this.geometryBuffers = getBuffersFromGeometry(this.gl, geometry);\n    this.vertexArray.setAttributes(this.geometryBuffers);\n    return this;\n  }\n\n  setAttributes(attributes = {}) {\n    // Avoid setting needsRedraw if no attributes\n    if (isObjectEmpty(attributes)) {\n      return this;\n    }\n\n    const normalizedAttributes = {};\n    for (const name in attributes) {\n      const attribute = attributes[name];\n      // The `getValue` call provides support for deck.gl `Attribute` class\n      // TODO - remove once deck refactoring completes\n      normalizedAttributes[name] = attribute.getValue ? attribute.getValue() : attribute;\n    }\n\n    this.vertexArray.setAttributes(normalizedAttributes);\n    return this;\n  }\n\n  // DRAW CALLS\n\n  draw(options = {}) {\n    return this.drawGeometry(options);\n  }\n\n  // Draw call for transform feedback\n  transform(opts = {}) {\n    const {discard = true, feedbackBuffers, unbindModels = []} = opts;\n\n    let {parameters} = opts;\n\n    if (feedbackBuffers) {\n      this._setFeedbackBuffers(feedbackBuffers);\n    }\n\n    if (discard) {\n      parameters = Object.assign({}, parameters, {[GL.RASTERIZER_DISCARD]: discard});\n    }\n\n    unbindModels.forEach(model => model.vertexArray.unbindBuffers());\n    try {\n      this.draw(Object.assign({}, opts, {parameters}));\n    } finally {\n      unbindModels.forEach(model => model.vertexArray.bindBuffers());\n    }\n\n    return this;\n  }\n\n  // DEPRECATED METHODS\n\n  render(uniforms = {}) {\n    log.warn('Model.render() is deprecated. Use Model.setUniforms() and Model.draw()')();\n    return this.setUniforms(uniforms).draw();\n  }\n\n  // PRIVATE METHODS\n\n  _setModelProps(props) {\n    // params\n    // if ('drawMode' in props) {\n    //   this.drawMode = getDrawMode(props.drawMode);\n    // }\n    // if ('vertexCount' in props) {\n    //   this.vertexCount = props.vertexCount;\n    // }\n    if ('instanceCount' in props) {\n      this.instanceCount = props.instanceCount;\n    }\n    if ('geometry' in props) {\n      this.setGeometry(props.geometry);\n    }\n\n    // webgl settings\n    if ('attributes' in props) {\n      this.setAttributes(props.attributes);\n    }\n    if ('_feedbackBuffers' in props) {\n      this._setFeedbackBuffers(props._feedbackBuffers);\n    }\n  }\n\n  _deleteGeometryBuffers() {\n    for (const name in this.geometryBuffers) {\n      // Buffer is raw value (for indices) or first element of [buffer, accessor] pair\n      const buffer = this.geometryBuffers[name][0] || this.geometryBuffers[name];\n      if (buffer instanceof Buffer) {\n        buffer.delete();\n      }\n    }\n  }\n\n  // Updates (evaluates) all function valued uniforms based on a new set of animationProps\n  // experimental\n  _setAnimationProps(animationProps) {\n    if (this.animated) {\n      assert(animationProps, 'Model.draw(): animated uniforms but no animationProps');\n      const animatedUniforms = this._evaluateAnimateUniforms(animationProps);\n      Object.assign(this.uniforms, animatedUniforms);\n    }\n  }\n\n  // Transform Feedback\n\n  _setFeedbackBuffers(feedbackBuffers = {}) {\n    // Avoid setting needsRedraw if no feedbackBuffers\n    if (isObjectEmpty(feedbackBuffers)) {\n      return this;\n    }\n\n    const {gl} = this.program;\n    this.transformFeedback =\n      this.transformFeedback ||\n      new TransformFeedback(gl, {\n        program: this.program\n      });\n\n    this.transformFeedback.setBuffers(feedbackBuffers);\n    return this;\n  }\n}\n","// Transpiles shader source code to target GLSL version\n// Note: We always run transpiler even if same version e.g. 3.00 => 3.00\n// RFC: https://github.com/uber/luma.gl/blob/7.0-release/dev-docs/RFCs/v6.0/portable-glsl-300-rfc.md\nexport default function transpileShader(source, targetGLSLVersion, isVertex) {\n  switch (targetGLSLVersion) {\n    case 300:\n      return isVertex ? convertVertexShaderTo300(source) : convertFragmentShaderTo300(source);\n    case 100:\n      return isVertex ? convertVertexShaderTo100(source) : convertFragmentShaderTo100(source);\n    default:\n      throw new Error(`unknown GLSL version ${targetGLSLVersion}`);\n  }\n}\n\nfunction convertVertexShaderTo300(source) {\n  return source\n    .replace(/attribute\\s+/g, 'in ')\n    .replace(/varying\\s+/g, 'out ')\n    .replace(/texture2D\\(/g, 'texture(')\n    .replace(/textureCube\\(+/g, 'texture(')\n    .replace(/texture2DLodEXT\\(/g, 'textureLod(')\n    .replace(/textureCubeLodEXT\\(/g, 'textureLod(');\n}\n\nfunction convertFragmentShaderTo300(source) {\n  return source\n    .replace(/varying\\s+/g, 'in ')\n    .replace(/texture2D\\(/g, 'texture(')\n    .replace(/textureCube\\(/g, 'texture(')\n    .replace(/texture2DLodEXT\\(/g, 'textureLod(')\n    .replace(/textureCubeLodEXT\\(/g, 'textureLod(');\n\n  // Deal with fragColor\n  // .replace(/gl_fragColor/g, 'fragColor ');\n}\n\nfunction convertVertexShaderTo100(source) {\n  // /gm - treats each line as a string, so that ^ matches after newlines\n  return source\n    .replace(/^in\\s+/gm, 'attribute ')\n    .replace(/^out\\s+/gm, 'varying ')\n    .replace(/texture\\(/g, 'texture2D(');\n}\n\nfunction convertFragmentShaderTo100(source) {\n  // /gm - treats each line as a string, so that ^ matches after newlines\n  return source.replace(/^in\\s+/gm, 'varying ').replace(/texture\\(/g, 'texture2D(');\n\n  // Deal with fragColor\n  // .replace(/^out\\s+/g, 'varying ')\n}\n","const TYPE_DEFINITIONS = {\n  number: {\n    validate(value, propType) {\n      return (\n        Number.isFinite(value) &&\n        (!('max' in propType) || value <= propType.max) &&\n        (!('min' in propType) || value >= propType.min)\n      );\n    }\n  },\n  array: {\n    validate(value, propType) {\n      return Array.isArray(value) || ArrayBuffer.isView(value);\n    }\n  }\n};\n\nexport function parsePropTypes(propDefs) {\n  const propTypes = {};\n  for (const propName in propDefs) {\n    const propDef = propDefs[propName];\n    const propType = parsePropType(propDef);\n    propTypes[propName] = propType;\n  }\n  return propTypes;\n}\n\n// Parses one property definition entry. Either contains:\n// * a valid prop type object ({type, ...})\n// * or just a default value, in which case type and name inference is used\nfunction parsePropType(propDef) {\n  let type = getTypeOf(propDef);\n  if (type === 'object') {\n    if (!propDef) {\n      return {type: 'object', value: null};\n    }\n    if ('type' in propDef) {\n      return Object.assign({}, propDef, TYPE_DEFINITIONS[propDef.type]);\n    }\n    if (!('value' in propDef)) {\n      // If no type and value this object is likely the value\n      return {type: 'object', value: propDef};\n    }\n    type = getTypeOf(propDef.value);\n    return Object.assign({type}, propDef, TYPE_DEFINITIONS[type]);\n  }\n  return Object.assign({type, value: propDef}, TYPE_DEFINITIONS[type]);\n}\n\n// improved version of javascript typeof that can distinguish arrays and null values\nfunction getTypeOf(value) {\n  if (Array.isArray(value) || ArrayBuffer.isView(value)) {\n    return 'array';\n  }\n  return typeof value;\n}\n","import transpileShader from './transpile-shader';\nimport {assert} from '../utils';\nimport {parsePropTypes} from './filters/prop-types';\n\nconst VERTEX_SHADER = 'vs';\nconst FRAGMENT_SHADER = 'fs';\n\nexport default class ShaderModule {\n  constructor({\n    name,\n    vs,\n    fs,\n    dependencies = [],\n    uniforms,\n    getUniforms,\n    deprecations = [],\n    defines = {},\n    // DEPRECATED\n    vertexShader,\n    fragmentShader\n  }) {\n    assert(typeof name === 'string');\n    this.name = name;\n    this.vs = vs || vertexShader;\n    this.fs = fs || fragmentShader;\n    this.getModuleUniforms = getUniforms;\n    this.dependencies = dependencies;\n    this.deprecations = this._parseDeprecationDefinitions(deprecations);\n    this.defines = defines;\n\n    if (uniforms) {\n      this.uniforms = parsePropTypes(uniforms);\n    }\n  }\n\n  // Extracts the source code chunk for the specified shader type from the named shader module\n  getModuleSource(type, targetGLSLVersion) {\n    let moduleSource;\n    switch (type) {\n      case VERTEX_SHADER:\n        moduleSource = transpileShader(this.vs || '', targetGLSLVersion, true);\n        break;\n      case FRAGMENT_SHADER:\n        moduleSource = transpileShader(this.fs || '', targetGLSLVersion, false);\n        break;\n      default:\n        assert(false);\n    }\n\n    return `\\\n#define MODULE_${this.name.toUpperCase()}\n${moduleSource}\\\n// END MODULE_${this.name}\n\n`;\n  }\n\n  getUniforms(opts, uniforms) {\n    if (this.getModuleUniforms) {\n      return this.getModuleUniforms(opts, uniforms);\n    }\n    // Build uniforms from the uniforms array\n    if (this.uniforms) {\n      return this._defaultGetUniforms(opts);\n    }\n    return {};\n  }\n\n  getDefines() {\n    return this.defines;\n  }\n\n  // Warn about deprecated uniforms or functions\n  checkDeprecations(shaderSource, log) {\n    this.deprecations.forEach(def => {\n      if (def.regex.test(shaderSource)) {\n        if (def.deprecated) {\n          log.deprecated(def.old, def.new)();\n        } else {\n          log.removed(def.old, def.new)();\n        }\n      }\n    });\n  }\n\n  _parseDeprecationDefinitions(deprecations) {\n    deprecations.forEach(def => {\n      switch (def.type) {\n        case 'function':\n          def.regex = new RegExp(`\\\\b${def.old}\\\\(`);\n          break;\n        default:\n          def.regex = new RegExp(`${def.type} ${def.old};`);\n      }\n    });\n\n    return deprecations;\n  }\n\n  _defaultGetUniforms(opts = {}) {\n    const uniforms = {};\n    const propTypes = this.uniforms;\n\n    for (const key in propTypes) {\n      const propDef = propTypes[key];\n      if (key in opts && !propDef.private) {\n        if (propDef.validate) {\n          assert(propDef.validate(opts[key], propDef), `${this.name}: invalid ${key}`);\n        }\n        uniforms[key] = opts[key];\n      } else {\n        uniforms[key] = propDef.value;\n      }\n    }\n\n    return uniforms;\n  }\n}\n\n// This utility mutates the original module\n// Keeping for backward compatibility\n// TODO - remove in v8\nexport function normalizeShaderModule(module) {\n  if (!module.normalized) {\n    module.normalized = true;\n    if (module.uniforms && !module.getUniforms) {\n      const shaderModule = new ShaderModule(module);\n      module.getUniforms = shaderModule.getUniforms.bind(shaderModule);\n    }\n  }\n  return module;\n}\n","import {MODULE_INJECTORS_VS, MODULE_INJECTORS_FS} from '../modules/module-injectors';\nimport {VERTEX_SHADER, FRAGMENT_SHADER} from './constants';\nimport {assert} from '../utils';\n\n// TODO - experimental\nconst MODULE_INJECTORS = {\n  [VERTEX_SHADER]: MODULE_INJECTORS_VS,\n  [FRAGMENT_SHADER]: MODULE_INJECTORS_FS\n};\n\nexport const DECLARATION_INJECT_MARKER = '__LUMA_INJECT_DECLARATIONS__'; // Uniform/attribute declarations\n\nconst REGEX_START_OF_MAIN = /void main\\s*\\([^)]*\\)\\s*\\{\\n?/; // Beginning of main\nconst REGEX_END_OF_MAIN = /}\\n?[^{}]*$/; // End of main, assumes main is last function\nconst fragments = [];\n\n// A minimal shader injection/templating system.\n// RFC: https://github.com/uber/luma.gl/blob/7.0-release/dev-docs/RFCs/v6.0/shader-injection-rfc.md\n/* eslint-disable complexity */\nexport default function injectShader(source, type, inject, injectStandardStubs) {\n  const isVertex = type === VERTEX_SHADER;\n\n  for (const key in inject) {\n    const fragmentData = inject[key];\n    fragmentData.sort((a, b) => a.order - b.order);\n    fragments.length = fragmentData.length;\n    for (let i = 0, len = fragmentData.length; i < len; ++i) {\n      fragments[i] = fragmentData[i].injection;\n    }\n    const fragmentString = `${fragments.join('\\n')}\\n`;\n    switch (key) {\n      // declarations are injected before the main function\n      case 'vs:#decl':\n        if (isVertex) {\n          source = source.replace(DECLARATION_INJECT_MARKER, fragmentString);\n        }\n        break;\n      // main code is injected at the end of main function\n      case 'vs:#main-start':\n        if (isVertex) {\n          source = source.replace(REGEX_START_OF_MAIN, match => match + fragmentString);\n        }\n        break;\n      case 'vs:#main-end':\n        if (isVertex) {\n          source = source.replace(REGEX_END_OF_MAIN, match => fragmentString + match);\n        }\n        break;\n      case 'fs:#decl':\n        if (!isVertex) {\n          source = source.replace(DECLARATION_INJECT_MARKER, fragmentString);\n        }\n        break;\n      case 'fs:#main-start':\n        if (!isVertex) {\n          source = source.replace(REGEX_START_OF_MAIN, match => match + fragmentString);\n        }\n        break;\n      case 'fs:#main-end':\n        if (!isVertex) {\n          source = source.replace(REGEX_END_OF_MAIN, match => fragmentString + match);\n        }\n        break;\n\n      default:\n        // TODO(Tarek): I think this usage should be deprecated.\n\n        // inject code after key, leaving key in place\n        source = source.replace(key, match => match + fragmentString);\n    }\n  }\n\n  // Remove if it hasn't already been replaced\n  source = source.replace(DECLARATION_INJECT_MARKER, '');\n\n  // Finally, if requested, insert an automatic module injector chunk\n  if (injectStandardStubs) {\n    source = source.replace(/\\}\\s*$/, match => match + MODULE_INJECTORS[type]);\n  }\n\n  return source;\n}\n\n/* eslint-enable complexity */\n\n// Takes an array of inject objects and combines them into one\nexport function combineInjects(injects) {\n  const result = {};\n  assert(Array.isArray(injects) && injects.length > 1);\n  injects.forEach(inject => {\n    for (const key in inject) {\n      result[key] = result[key] ? `${result[key]}\\n${inject[key]}` : inject[key];\n    }\n  });\n  return result;\n}\n","export const MODULE_INJECTORS_VS = `\\\n#ifdef MODULE_LOGDEPTH\n  logdepth_adjustPosition(gl_Position);\n#endif\n`;\n\nexport const MODULE_INJECTORS_FS = `\\\n#ifdef MODULE_MATERIAL\n  gl_FragColor = material_filterColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_LIGHTING\n  gl_FragColor = lighting_filterColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_FOG\n  gl_FragColor = fog_filterColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_PICKING\n  gl_FragColor = picking_filterHighlightColor(gl_FragColor);\n  gl_FragColor = picking_filterPickingColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_LOGDEPTH\n  logdepth_setFragDepth();\n#endif\n`;\n","// shadertools exports\n\n// DEFAULT SHADERS\n// A set of base shaders that leverage the shader module system,\n// dynamically enabling features depending on which modules are included\nimport MODULAR_VS from './shaders/modular-vertex.glsl';\nimport MODULAR_FS from './shaders/modular-fragment.glsl';\n\n// DOCUMENTED APIS\nexport {\n  registerShaderModules,\n  setDefaultShaderModules,\n  getDefaultShaderModules\n} from './lib/resolve-modules';\nexport {\n  assembleShaders,\n  createShaderHook,\n  createModuleInjection,\n  resetGlobalShaderHooks\n} from './lib/assemble-shaders';\n\n// HELPERS\nexport {combineInjects} from './lib/inject-shader';\nexport {normalizeShaderModule} from './lib/shader-module';\n\n// UTILS\nexport {\n  getQualifierDetails,\n  getPassthroughFS,\n  typeToChannelSuffix,\n  typeToChannelCount,\n  convertToVec4\n} from './utils/shader-utils';\n\n// SHADER MODULES\nexport * from './modules';\n\nexport const MODULAR_SHADERS = {\n  vs: MODULAR_VS,\n  fs: MODULAR_FS,\n  uniforms: {}\n};\n","export default `\\\n#define SHADER_NAME luma_modular_vertex\n\n// object attributes\nattribute vec3 positions;\nattribute vec3 normals;\nattribute vec4 colors;\nattribute vec2 texCoords;\nattribute vec3 pickingColors;\n\nvoid main(void) {\n\n  // Set up position\n#ifdef MODULE_GEOMETRY\n  geometry_setPosition(positions);\n  geometry_setNormal(normals);\n#endif\n\n#ifdef MODULE_PROJECT\n  project_setPositionAndNormal_Model(positions, normals);\n  gl_Position = project_model_to_clipspace(positions);\n#endif\n\n  // Set up depth\n#ifdef MODULE_LOGDEPTH\n  logdepth_adjustPosition(gl_Position);\n#endif\n\n#ifdef MODULE_DIFFUSE\n  diffuse_setTextureCoordinate(texCoords);\n#endif\n\n  // Set up color calculations\n#ifdef MODULE_MATERIAL\n  material_setDiffuseColor(colors);\n  material_setDiffuseTextureCoordinates(texCoords);\n#endif\n\n#ifdef MODULE_LIGHTING\n  lighting_setPositionAndNormal(positions, normals);\n  lighting_apply_light(positions);\n  lighting_apply_reflection(positions);\n#endif\n\n#ifdef MODULE_PICKING\n  picking_setPickingColor(pickingColors);\n#endif\n\n}\n`;\n","export default `\\\n#define SHADER_NAME luma-modular-fragment\n\nprecision highp float;\n\n// varyings\nvarying vec4 vColor;\n\nvoid main(){\n  gl_FragColor = vec4(1., 0., 1., 1.);\n\n#ifdef MODULE_DIFFUSE\n  gl_FragColor = diffuse_filterColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_MATERIAL\n  gl_FragColor = material_filterColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_LIGHTING\n  gl_FragColor = lighting_filterColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_FOG\n  gl_FragColor = fog_filterColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_PICKING\n  gl_FragColor = picking_filterHighlightColor(gl_FragColor);\n  gl_FragColor = picking_filterPickingColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_LOGDEPTH\n  logdepth_setFragDepth(gl_Position);\n#endif\n}\n`;\n","export const VERTEX_SHADER = 'vs';\nexport const FRAGMENT_SHADER = 'fs';\n","import Model from '../../lib/model';\nimport ScenegraphNode from './scenegraph-node';\n\nexport default class ModelNode extends ScenegraphNode {\n  constructor(gl, props = {}) {\n    super(props);\n\n    // pverride callbacks to make sure we call them with this\n    this.onBeforeRender = null;\n    this.AfterRender = null;\n\n    // Create new Model or used supplied Model\n    if (gl instanceof Model) {\n      this.model = gl;\n      this._setModelNodeProps(props);\n    } else {\n      this.model = new Model(gl, props);\n    }\n\n    this.managedResources = props.managedResources || [];\n  }\n\n  setProps(props) {\n    super.setProps(props);\n    this._setModelNodeProps(props);\n    return this;\n  }\n\n  delete() {\n    if (this.model) {\n      this.model.delete();\n      this.model = null;\n    }\n\n    this.managedResources.forEach(resource => resource.delete());\n    this.managedResources = [];\n  }\n\n  // Forward node methods\n  draw(...args) {\n    // Return value indicates if something was actually drawn\n    return this.model.draw(...args);\n  }\n\n  setUniforms(...args) {\n    this.model.setUniforms(...args);\n    return this;\n  }\n\n  setAttributes(...args) {\n    this.model.setAttributes(...args);\n    return this;\n  }\n\n  updateModuleSettings(...args) {\n    this.model.updateModuleSettings(...args);\n    return this;\n  }\n\n  // PRIVATE\n\n  _setModelNodeProps(props) {\n    this.model.setProps(props);\n  }\n}\n","// Recommendation is to ignore message but current test suite checks agains the\n// message so keep it for now.\nexport default function assert(condition, message) {\n  if (!condition) {\n    throw new Error(message || 'shadertools: assertion failed.');\n  }\n}\n","import GL from '@luma.gl/constants';\nimport Resource from './resource';\nimport Buffer from './buffer';\nimport {isWebGL2, assertWebGL2Context} from '../webgl-utils';\nimport {log, isObjectEmpty} from '../utils';\n\n// NOTE: The `bindOnUse` flag is a major workaround:\n// See https://github.com/KhronosGroup/WebGL/issues/2346\n\nexport default class TransformFeedback extends Resource {\n  static isSupported(gl) {\n    return isWebGL2(gl);\n  }\n\n  constructor(gl, props = {}) {\n    assertWebGL2Context(gl);\n    super(gl, props);\n\n    this.initialize(props);\n    this.stubRemovedMethods('TransformFeedback', 'v6.0', ['pause', 'resume']);\n    Object.seal(this);\n  }\n\n  initialize(props = {}) {\n    this.buffers = {};\n    this.unused = {};\n    this.configuration = null;\n    this.bindOnUse = true;\n\n    // Unbind any currently bound buffers\n    if (!isObjectEmpty(this.buffers)) {\n      this.bind(() => this._unbindBuffers());\n    }\n\n    this.setProps(props);\n    return this;\n  }\n\n  setProps(props) {\n    if ('program' in props) {\n      this.configuration = props.program && props.program.configuration;\n    }\n    if ('configuration' in props) {\n      this.configuration = props.configuration;\n    }\n    if ('bindOnUse' in props) {\n      props = props.bindOnUse;\n    }\n    if ('buffers' in props) {\n      this.setBuffers(props.buffers);\n    }\n  }\n\n  setBuffers(buffers = {}) {\n    this.bind(() => {\n      for (const bufferName in buffers) {\n        this.setBuffer(bufferName, buffers[bufferName]);\n      }\n    });\n    return this;\n  }\n\n  setBuffer(locationOrName, bufferOrParams) {\n    const location = this._getVaryingIndex(locationOrName);\n    const {buffer, byteSize, byteOffset} = this._getBufferParams(bufferOrParams);\n\n    if (location < 0) {\n      this.unused[locationOrName] = buffer;\n      log.warn(() => `${this.id} unused varying buffer ${locationOrName}`)();\n      return this;\n    }\n\n    this.buffers[location] = bufferOrParams;\n\n    // Need to avoid chrome bug where buffer that is already bound to a different target\n    // cannot be bound to 'TRANSFORM_FEEDBACK_BUFFER' target.\n    if (!this.bindOnUse) {\n      this._bindBuffer(location, buffer, byteOffset, byteSize);\n    }\n\n    return this;\n  }\n\n  begin(primitiveMode = GL.POINTS) {\n    this.gl.bindTransformFeedback(GL.TRANSFORM_FEEDBACK, this.handle);\n    this._bindBuffers();\n    this.gl.beginTransformFeedback(primitiveMode);\n    return this;\n  }\n\n  end() {\n    this.gl.endTransformFeedback();\n    this._unbindBuffers();\n    this.gl.bindTransformFeedback(GL.TRANSFORM_FEEDBACK, null);\n    return this;\n  }\n\n  // PRIVATE METHODS\n\n  _getBufferParams(bufferOrParams) {\n    let byteOffset;\n    let byteSize;\n    let buffer;\n    if (bufferOrParams instanceof Buffer === false) {\n      buffer = bufferOrParams.buffer;\n      byteSize = bufferOrParams.byteSize;\n      byteOffset = bufferOrParams.byteOffset;\n    } else {\n      buffer = bufferOrParams;\n    }\n    // to use bindBufferRange, either offset or size must be specified, use default value for the other.\n    if (byteOffset !== undefined || byteSize !== undefined) {\n      byteOffset = byteOffset || 0;\n      byteSize = byteSize || buffer.byteLength - byteOffset;\n    }\n    return {buffer, byteOffset, byteSize};\n  }\n\n  _getVaryingInfo(locationOrName) {\n    return this.configuration && this.configuration.getVaryingInfo(locationOrName);\n  }\n\n  _getVaryingIndex(locationOrName) {\n    if (this.configuration) {\n      return this.configuration.getVaryingInfo(locationOrName).location;\n    }\n    const location = Number(locationOrName);\n    return Number.isFinite(location) ? location : -1;\n  }\n\n  // Need to avoid chrome bug where buffer that is already bound to a different target\n  // cannot be bound to 'TRANSFORM_FEEDBACK_BUFFER' target.\n  _bindBuffers() {\n    if (this.bindOnUse) {\n      for (const bufferIndex in this.buffers) {\n        const {buffer, byteSize, byteOffset} = this._getBufferParams(this.buffers[bufferIndex]);\n        this._bindBuffer(bufferIndex, buffer, byteOffset, byteSize);\n      }\n    }\n  }\n\n  _unbindBuffers() {\n    if (this.bindOnUse) {\n      for (const bufferIndex in this.buffers) {\n        this._bindBuffer(bufferIndex, null);\n      }\n    }\n  }\n\n  _bindBuffer(index, buffer, byteOffset = 0, byteSize) {\n    const handle = buffer && buffer.handle;\n    if (!handle || byteSize === undefined) {\n      this.gl.bindBufferBase(GL.TRANSFORM_FEEDBACK_BUFFER, index, handle);\n    } else {\n      this.gl.bindBufferRange(GL.TRANSFORM_FEEDBACK_BUFFER, index, handle, byteOffset, byteSize);\n    }\n    return this;\n  }\n\n  // RESOURCE METHODS\n\n  _createHandle() {\n    return this.gl.createTransformFeedback();\n  }\n\n  _deleteHandle() {\n    this.gl.deleteTransformFeedback(this.handle);\n  }\n\n  _bindHandle(handle) {\n    this.gl.bindTransformFeedback(GL.TRANSFORM_FEEDBACK, this.handle);\n  }\n}\n"],"sourceRoot":""}