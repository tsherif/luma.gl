{"version":3,"sources":["webpack:///../examples/lessons/11/app.js","webpack:///./templates/lessons/example-11.jsx","webpack:///../modules/core/src/geometry/geometry.js","webpack:///../modules/shadertools/src/utils/webgl-info.js","webpack:///../modules/shadertools/src/utils/is-old-ie.js","webpack:///../modules/shadertools/src/lib/platform-defines.js","webpack:///../modules/shadertools/src/lib/assemble-shaders.js","webpack:///../modules/shadertools/src/lib/shader-module-registry.js","webpack:///../modules/shadertools/src/lib/resolve-modules.js","webpack:///../modules/core/src/lib/model-utils.js","webpack:///../modules/core/src/resource-management/program-manager.js","webpack:///../modules/webgl/src/utils/format-value.js","webpack:///../modules/webgl/src/debug/debug-vertex-array.js","webpack:///../modules/webgl/src/debug/debug-uniforms.js","webpack:///../modules/webgl/src/debug/debug-program-configuration.js","webpack:///../modules/core/src/debug/seer-integration.js","webpack:///../modules/core/src/lib/base-model.js","webpack:///../modules/core/src/lib/model.js","webpack:///../modules/shadertools/src/lib/transpile-shader.js","webpack:///../modules/shadertools/src/lib/filters/prop-types.js","webpack:///../modules/shadertools/src/lib/shader-module.js","webpack:///../modules/shadertools/src/lib/inject-shader.js","webpack:///../modules/shadertools/src/modules/module-injectors.js","webpack:///../modules/shadertools/src/index.js","webpack:///../modules/shadertools/src/shaders/modular-vertex.glsl.js","webpack:///../modules/shadertools/src/shaders/modular-fragment.glsl.js","webpack:///../modules/shadertools/src/lib/constants.js","webpack:///../modules/shadertools/src/utils/assert.js","webpack:///../modules/webgl/src/classes/transform-feedback.js","webpack:///../modules/core/src/geometries/sphere-geometry.js"],"names":["appState","mouseDown","lastMouseX","lastMouseY","moonRotationMatrix","matrix4","AppAnimationLoop","getInfo","onInitialize","canvas","_ref","gl","this","eventManager","esm","addMouseHandler","panstart","event","panmove","undefined","radiansX","radiansY","newMatrix","rotateX","rotateY","panend","e","setParameters","clearColor","clearDepth","depthTest","moon","model","fs","vs","geometry","sphere_geometry","nlat","nlong","radius","uniforms","uSampler","texture_2d","onRender","_ref2","aspect","tick","GL","uMMatrix","multiplyRight","uVMatrix","lookAt","eye","center","up","_getControlValues","getElementValue","id","defaultValue","element","document","parseFloat","value","lighting","checked","ambientColor","vector3","lightingDirection","directionalColor","getControlValues","uUseLighting","uAmbientColor","uLightingDirection","uDirectionalColor","setUniforms","uPMatrix","perspective","fov","Math","PI","near","far","draw","onFinalize","destroy","AnimationLoop","window","website","app_AppAnimationLoop","animationLoop","Example","render","react_default","a","createElement","animation_loop_example_page","exampleConfig","props","pageContext","React","Component","DRAW_MODE","POINTS","LINES","LINE_LOOP","LINE_STRIP","TRIANGLES","TRIANGLE_STRIP","TRIANGLE_FAN","Geometry","_props","_props$id","uid","_props$drawMode","drawMode","_props$attributes","attributes","_props$indices","indices","_props$vertexCount","vertexCount","userData","_setAttributes","_calculateVertexCount","getVertexCount","getAttributes","Object","assign","_print","attributeName","ArrayBuffer","isView","size","attribute","assert","isIndexed","length","Infinity","constant","Number","GL_VENDOR","GL_RENDERER","GL_VERSION","GL_SHADING_LANGUAGE_VERSION","WEBGL_FEATURES","GLSL_FRAG_DATA","GLSL_FRAG_DEPTH","GLSL_DERIVATIVES","GLSL_TEXTURE_LOD","FEATURES","key","compiledGlslExtensions","canCompileGLGSExtension","cap","opts","feature","navigator","userAgent","isMSIE","isTrident","isOldIE","source","shader","VERTEX_SHADER","canCompile","COMPILE_STATUS","getFeature","extensionName","Boolean","isWebGL2","hasFeatures","features","Array","every","getPlatformShaderDefines","info","vendor","UNMASKED_VENDOR_WEBGL","renderer","UNMASKED_RENDERER_WEBGL","gpuVendor","identifyGPUVendor","version","shadingLanguageVersion","getContextInfo","debugInfo","toLowerCase","INJECT_SHADER_DECLARATIONS","inject_shader","SHADER_TYPE","_SHADER_TYPE","constants","HOOK_FUNCTIONS","_HOOK_FUNCTIONS","MODULE_INJECTIONS","_MODULE_INJECTIONS","FRAGMENT_SHADER_PROLOGUE","createShaderHook","hook","_hook$split","stage","signature","name","createModuleInjection","moduleName","injection","_opts$order","order","shaderStage","moduleInjections","assembleShaders","modules","resolveModules","assembleShader","type","getUniforms","assembleGetUniforms","assembleModuleMap","_hookFunctions","_moduleInjections","_ref$defines","defines","_ref$hookFunctions","hookFunctions","_ref$moduleInjections","_ref$inject","inject","_ref$prologue","prologue","log","isVertex","sourceLines","glslVersion","versionLine","coreSource","allDefines","module","assembledSource","_ref6","getShaderName","_ref5","toUpperCase","getShaderType","isFragment","versionDefines","behavior","getVersionDefines","count","sourceText","define","getApplicationDefines","injectStandardStubs","hookInjections","mainInjections","_iterator","_isArray","isArray","_i","Symbol","iterator","next","done","injections","_key","result","hookName","hookFunction","header","b","_iterator4","_isArray4","_i4","_ref7","footer","getHookFunctions","injectShader","_iterator2","_isArray2","_i2","_ref3","moduleUniforms","_iterator3","_isArray3","_i3","_ref4","shaderModule","getShaderModule","ShaderModuleRegistry","shaderModules","defaultShaderModules","setDefaultShaderModules","getDefaultShaderModules","registerShaderModules","_ref$ignoreMultipleRe","_temp","ignoreMultipleRegistrations","shaderModuleList","_registerShaderModule","moduleOrName","shader_module","_this","map","Error","shaderModuleRegistry","shader_module_registry_ShaderModuleRegistry","getShaderDependencies","resolve_modules_getShaderModule","moduleMap","moduleDepth","getDependencyGraph","level","keys","sort","dependencies","GLTF_TO_LUMA_ATTRIBUTE_MAP","POSITION","NORMAL","COLOR_0","TEXCOORD_0","TEXCOORD_1","TEXCOORD_2","mapAttributeName","options","_ref$attributeMap","attributeMap","inferAttributeAccessor","category","ProgramManager","_programCache","_getUniforms","_registeredModules","_defaultModules","_hashes","_hashCounter","stateHash","_useCounts","getDefaultProgramManager","defaultProgramManager","addDefaultModule","find","m","push","removeDefaultModule","filter","addModuleInjection","addShaderHook","get","_props$vs","_props$fs","_props$defines","_props$inject","_props$varyings","varyings","_props$bufferMode","bufferMode","_getModuleList","vsHash","_getHash","fsHash","moduleHashes","varyingHashes","v","defineKeys","injectKeys","defineHashes","hash","injectHashes","assembled","classes_program","x","program","release","delete","appModules","seen","i","len","_len","_module","_name","formatValue","_opts$isInteger","isInteger","_opts$maxElts","maxElts","_opts$size","string","formatArrayValue","String","decimal","getDebugTableRow","vertexArray","accessor","marker","verts","bytes","classes_buffer","format","buffer","_buffer$getDebugData","getDebugData","data","modified","getKey","getGLSLDeclaration","typeAndName","getCompositeGLType","getDebugTableForUniforms","_ref$header","_ref$undefinedOnly","undefinedOnly","uniformLocations","_uniformSetters","table","uniformNames","uniformName","addUniformToTable","_uniformName","_uniformName2","unusedCount","unusedTable","_unusedTable$uniformN","uniform","Type","_table$uniformName","isDefined","isUniformDefined","debug_program_configuration_getGLSLDeclaration","attributeInfo","_attributeInfo$access","models","recursiveSet","obj","path","overrides","Map","seer","payload","itemKey","valuePath","__SEER_INITIALIZED__","setOverride","BaseModel","isWebGL","lastLogTime","initialize","shaderCache","programManager","_programManagerState","_managedProgram","_props$program","programProps","_programDirty","needsRedraw","_attributes","animatedUniforms","animated","timerQueryEnabled","timeElapsedQuery","lastQueryReturned","stats","accumulatedFrameTime","averageFrameTime","profileFrameCount","pickable","_checkProgram","_setBaseModelProps","getModuleUniforms","moduleSettings","setProps","removeModel","isAnimated","getProgram","setProgram","overs","getOverrides","_extractAnimatedUniforms","updateModuleSettings","clear","drawGeometry","_opts","_opts$moduleSettings","framebuffer","_opts$uniforms","_opts$attributes","_opts$transformFeedba","transformFeedback","_opts$parameters","parameters","_opts$vertexArray","animationProps","setAttributes","_refreshAnimationProps","logPriority","_logDrawCallStart","drawParams","getDrawParams","isInstanced","indexType","indexOffset","instanceCount","noop","_this$props","_this$props$onBeforeR","onBeforeRender","_this$props$onAfterRe","onAfterRender","_timerQueryStart","didDraw","getDrawMode","offset","_timerQueryEnd","_logDrawCallEnd","Query","_setAnimationProps","_animationProps","_animationLoop","_this$programProps","_this$programProps$vs","MODULAR_SHADERS","_this$programProps$fs","vertex_array","_evaluateAnimateUniforms","valueFunction","foundAnimated","newValue","isObjectEmpty","staticUniforms","query","beginTimeElapsedQuery","end","isResultAvailable","elapsedTime","getTimerMilliseconds","lastFrameTime","logDrawTimeout","priority","Date","now","collapsed","attributeTable","configuration","elements","values","attributeLocation","rowHeader","location","getDebugTableForVertexArray","_getDebugTableForUnif","uniformTable","_getDebugTableForUnif2","missingTable","configTable","config","attributeInfos","_table","JSON","varyingInfos","_table2","varyingInfo","getDebugTableForProgramConfiguration","isReady","attributesObject","uniformsObject","logModel","message","Model","_BaseModel","call","prototype","geometryBuffers","instanced","_setModelProps","_deleteGeometryBuffers","getInstanceCount","setDrawMode","setVertexCount","setInstanceCount","setGeometry","buffers","remappedName","typedArray","Uint32Array","target","ELEMENT_ARRAY_BUFFER","getBuffersFromGeometry","normalizedAttributes","transform","_Object$assign","_opts$discard","discard","feedbackBuffers","_opts$unbindModels","unbindModels","_setFeedbackBuffers","unbindBuffers","bindBuffers","_feedbackBuffers","transform_feedback","setBuffers","transpileShader","targetGLSLVersion","convertVertexShaderTo300","convertFragmentShaderTo300","convertVertexShaderTo100","convertFragmentShaderTo100","TYPE_DEFINITIONS","number","validate","propType","min","array","parsePropType","propDef","getTypeOf","ShaderModule","_ref$dependencies","_ref$deprecations","deprecations","vertexShader","fragmentShader","_parseDeprecationDefinitions","propDefs","propTypes","propName","parsePropTypes","getModuleSource","moduleSource","_defaultGetUniforms","getDefines","checkDeprecations","forEach","def","shaderSource","deprecated","RegExp","old","private","MODULE_INJECTORS","_MODULE_INJECTORS","DECLARATION_INJECT_MARKER","REGEX_START_OF_MAIN","REGEX_END_OF_MAIN","fragments","_loop","fragmentData","fragmentString","replace","match","combineInjects","injects","__webpack_require__","d","__webpack_exports__","FRAGMENT_SHADER","condition","TransformFeedback","assertWebGL2Context","_Resource","stubRemovedMethods","isSupported","_this2","unused","bindOnUse","bind","_unbindBuffers","_this3","bufferName","setBuffer","_this4","_getVaryingIndex","locationOrName","_this$_getBufferParam","_getBufferParams","bufferOrParams","byteSize","byteOffset","_bindBuffer","begin","primitiveMode","bindTransformFeedback","TRANSFORM_FEEDBACK","handle","_bindBuffers","beginTransformFeedback","endTransformFeedback","_getVaryingInfo","getVaryingInfo","bufferIndex","_this$_getBufferParam2","bindBufferRange","TRANSFORM_FEEDBACK_BUFFER","index","bindBufferBase","_createHandle","createTransformFeedback","_deleteHandle","deleteTransformFeedback","_bindHandle","Resource","SphereGeometry","_tesselateSphere","_props$nlat","_props$nlong","_props$radius","latRange","longRange","numVertices","n1","n2","n3","u","positions","Float32Array","normals","texCoords","Uint16Array","y","i2","i3","theta","phi","sinTheta","cosTheta","sinPhi","cosPhi","ux","uy","uz","r","numVertsAround","_y","_x","tesselateSphere","_Geometry"],"mappings":"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","file":"component---templates-lessons-example-11-jsx-2c95d0cc33873c39164d.js","sourcesContent":["import GL from '@luma.gl/constants';\nimport {AnimationLoop, setParameters, Texture2D, Model, SphereGeometry} from '@luma.gl/core';\nimport {Vector3, Matrix4} from 'math.gl';\nimport {EventManager} from 'mjolnir.js';\n/* eslint-disable complexity */\n\nconst INFO_HTML = `\n<p>\n  <a href=\"http://learningwebgl.com/blog/?p=1253\" target=\"_blank\">\n  Models, rotation matrices, and mouse events\n  </a>\n<br/>\n<br/>\n  (Rotate the moon with the mouse)\n<p>\n  The classic WebGL Lessons in luma.gl\n`;\n\nconst VERTEX_SHADER = `\\\nattribute vec3 positions;\nattribute vec3 normals;\nattribute vec2 texCoords;\n\nuniform mat4 uMMatrix;\nuniform mat4 uVMatrix;\nuniform mat4 uPMatrix;\n\nuniform vec3 uAmbientColor;\n\nuniform vec3 uLightingDirection;\nuniform vec3 uDirectionalColor;\n\nuniform bool uUseLighting;\n\nvarying vec2 vTextureCoord;\nvarying vec3 vLightWeighting;\n\nvoid main(void) {\n    gl_Position = uPMatrix * uVMatrix * uMMatrix * vec4(positions, 1.0);\n    vTextureCoord = texCoords;\n\n    if (!uUseLighting) {\n        vLightWeighting = vec3(1.0, 1.0, 1.0);\n    } else {\n        vec4 transformedNormal = uMMatrix * vec4(normals, 1.0);\n        vec3 newNormal = transformedNormal.xyz / transformedNormal.w;\n        float directionalLightWeighting = max(dot(newNormal, uLightingDirection), 0.0);\n        vLightWeighting = uAmbientColor + uDirectionalColor * directionalLightWeighting;\n    }\n}\n`;\n\nconst FRAGMENT_SHADER = `\\\nprecision highp float;\n\nvarying vec2 vTextureCoord;\nvarying vec3 vLightWeighting;\n\nuniform sampler2D uSampler;\n\nvoid main(void) {\n  vec4 textureColor = texture2D(uSampler, vec2(1.0 - vTextureCoord.s, 1.0 - vTextureCoord.t));\n  gl_FragColor = vec4(textureColor.rgb * vLightWeighting, textureColor.a);\n}\n`;\n\nconst appState = {\n  mouseDown: false,\n  lastMouseX: null,\n  lastMouseY: null,\n  moonRotationMatrix: new Matrix4()\n};\n\nexport default class AppAnimationLoop extends AnimationLoop {\n  static getInfo() {\n    return INFO_HTML;\n  }\n\n  onInitialize({canvas, gl}) {\n    // Use mjolnir.js (hammer.js)'s EventManager to handle gestures on both\n    // desktop and mobile\n    this.eventManager = new EventManager(canvas);\n    addMouseHandler(this.eventManager);\n\n    setParameters(gl, {\n      clearColor: [0, 0, 0, 1],\n      clearDepth: 1,\n      depthTest: true\n    });\n\n    return {\n      moon: new Model(gl, {\n        fs: FRAGMENT_SHADER,\n        vs: VERTEX_SHADER,\n        geometry: new SphereGeometry({\n          nlat: 30,\n          nlong: 30,\n          radius: 2\n        }),\n        uniforms: {\n          uSampler: new Texture2D(gl, 'moon.gif')\n        }\n      })\n    };\n  }\n\n  // eslint-disable-next-line complexity\n  onRender({gl, tick, aspect, moon}) {\n    // Update Camera Position\n    const eyePos = [0, 0, 6];\n\n    gl.clear(GL.COLOR_BUFFER_BIT | GL.DEPTH_BUFFER_BIT);\n\n    const uMMatrix = new Matrix4().multiplyRight(appState.moonRotationMatrix);\n    const uVMatrix = new Matrix4().lookAt({eye: eyePos, center: [0, 0, 0], up: [0, 1, 0]});\n\n    // Read controls\n    const {lighting, ambientColor, lightingDirection, directionalColor} = getControlValues();\n\n    moon.setUniforms({uUseLighting: lighting});\n\n    if (lighting) {\n      lightingDirection.normalize();\n      lightingDirection.scale(-1);\n\n      moon.setUniforms({\n        uAmbientColor: ambientColor,\n        uLightingDirection: lightingDirection,\n        uDirectionalColor: directionalColor\n      });\n    }\n\n    return moon\n      .setUniforms({\n        uMMatrix,\n        uVMatrix,\n        uPMatrix: new Matrix4().perspective({\n          fov: (45 * Math.PI) / 180,\n          aspect,\n          near: 0.1,\n          far: 100\n        })\n      })\n      .draw();\n  }\n\n  onFinalize() {\n    this.eventManager.destroy();\n  }\n}\n\nfunction addMouseHandler(eventManager) {\n  eventManager.on({\n    panstart(event) {\n      appState.mouseDown = true;\n      appState.lastMouseX = event.offsetCenter.x;\n      appState.lastMouseY = event.offsetCenter.y;\n    },\n    panmove(event) {\n      if (!appState.mouseDown) {\n        return;\n      }\n\n      if (appState.lastMouseX !== undefined) {\n        const radiansX = (event.offsetCenter.x - appState.lastMouseX) / 300;\n        const radiansY = (event.offsetCenter.y - appState.lastMouseY) / 300;\n\n        const newMatrix = new Matrix4().rotateX(radiansY).rotateY(radiansX);\n\n        appState.moonRotationMatrix.multiplyLeft(newMatrix);\n      }\n\n      appState.lastMouseX = event.offsetCenter.x;\n      appState.lastMouseY = event.offsetCenter.y;\n    },\n\n    panend(e) {\n      appState.mouseDown = false;\n    }\n  });\n}\n\nfunction getControlValues() {\n  /* global document */\n  function getElementValue(id, defaultValue) {\n    const element = document.getElementById(id);\n    return element ? parseFloat(element.value) : defaultValue;\n  }\n\n  const element = document.getElementById('lighting');\n  const lighting = element ? element.checked : true;\n\n  const ambientColor =\n    lighting &&\n    new Vector3(\n      getElementValue('ambientR', 0.2),\n      getElementValue('ambientG', 0.2),\n      getElementValue('ambientB', 0.2)\n    );\n\n  const lightingDirection =\n    lighting &&\n    new Vector3(\n      getElementValue('lightDirectionX', -1),\n      getElementValue('lightDirectionY', -1),\n      getElementValue('lightDirectionZ', -1)\n    );\n\n  const directionalColor =\n    lighting &&\n    new Vector3(\n      getElementValue('directionalR', 0.8),\n      getElementValue('directionalG', 0.8),\n      getElementValue('directionalB', 0.8)\n    );\n\n  return {lighting, ambientColor, lightingDirection, directionalColor};\n}\n\n/* global window */\nif (typeof window !== 'undefined' && !window.website) {\n  const animationLoop = new AppAnimationLoop();\n  animationLoop.start();\n}\n","import React from 'react';\nimport AnimationLoopExamplePage from '../../src/components/animation-loop-example-page';\nimport AnimationLoop from '../../../examples/lessons/11/app';\n\nexport default class Example extends React.Component {\n  render() {\n    return (\n      <AnimationLoopExamplePage AnimationLoop={AnimationLoop} exampleConfig={this.props.pageContext.exampleConfig} />\n    );\n  }\n}\n","import {uid, assert} from '../utils';\n\n// Rendering primitives - specify how to extract primitives from vertices.\n// NOTE: These are numerically identical to the corresponding WebGL/OpenGL constants\nexport const DRAW_MODE = {\n  POINTS: 0x0000, // draw single points.\n  LINES: 0x0001, // draw lines. Each vertex connects to the one after it.\n  LINE_LOOP: 0x0002, // draw lines. Each set of two vertices is treated as a separate line segment.\n  LINE_STRIP: 0x0003, // draw a connected group of line segments from the first vertex to the last\n  TRIANGLES: 0x0004, // draw triangles. Each set of three vertices creates a separate triangle.\n  TRIANGLE_STRIP: 0x0005, // draw a connected group of triangles.\n  TRIANGLE_FAN: 0x0006 // draw a connected group of triangles.\n  // Each vertex connects to the previous and the first vertex in the fan.\n};\n\nexport default class Geometry {\n  static get DRAW_MODE() {\n    return DRAW_MODE;\n  }\n\n  constructor(props = {}) {\n    const {\n      id = uid('geometry'),\n      drawMode = DRAW_MODE.TRIANGLES,\n      attributes = {},\n      indices = null,\n      vertexCount = null\n    } = props;\n\n    this.id = id;\n    this.drawMode = drawMode | 0;\n    this.attributes = {};\n    this.userData = {};\n\n    this._setAttributes(attributes, indices);\n\n    this.vertexCount = vertexCount || this._calculateVertexCount(this.attributes, this.indices);\n\n    // stubRemovedMethods(this, [\n    //   'setNeedsRedraw', 'needsRedraw', 'setAttributes'\n    // ], 'Immutable');\n\n    // stubRemovedMethods(this, [\n    //   'hasAttribute', 'getAttribute', 'getArray'\n    // ], 'Use geometry.attributes and geometry.indices');\n\n    // deprecateMethods(this, ['getAttributes'])\n  }\n\n  get mode() {\n    return this.drawMode;\n  }\n\n  getVertexCount() {\n    return this.vertexCount;\n  }\n\n  // Return an object with all attributes plus indices added as a field.\n  getAttributes() {\n    return this.indices ? {indices: this.indices, ...this.attributes} : this.attributes;\n  }\n\n  // PRIVATE\n\n  _print(attributeName) {\n    return `Geometry ${this.id} attribute ${attributeName}`;\n  }\n\n  // Attribute\n  // value: typed array\n  // type: indices, vertices, uvs\n  // size: elements per vertex\n  // target: WebGL buffer type (string or constant)\n  _setAttributes(attributes, indices) {\n    if (indices) {\n      this.indices = ArrayBuffer.isView(indices) ? {value: indices, size: 1} : indices;\n    }\n\n    for (const attributeName in attributes) {\n      let attribute = attributes[attributeName];\n\n      // Wrap \"unwrapped\" arrays and try to autodetect their type\n      attribute = ArrayBuffer.isView(attribute) ? {value: attribute} : attribute;\n\n      assert(\n        ArrayBuffer.isView(attribute.value),\n        `${this._print(attributeName)}: must be typed array or object with value as typed array`\n      );\n\n      if ((attributeName === 'POSITION' || attributeName === 'positions') && !attribute.size) {\n        attribute.size = 3;\n      }\n\n      // Move indices to separate field\n      if (attributeName === 'indices') {\n        assert(!this.indices);\n        this.indices = attribute;\n      } else {\n        this.attributes[attributeName] = attribute;\n      }\n    }\n\n    if (this.indices && this.indices.isIndexed !== undefined) {\n      this.indices = Object.assign({}, this.indices);\n      delete this.indices.isIndexed;\n    }\n\n    return this;\n  }\n\n  _calculateVertexCount(attributes, indices) {\n    if (indices) {\n      return indices.value.length;\n    }\n    let vertexCount = Infinity;\n    for (const attributeName in attributes) {\n      const attribute = attributes[attributeName];\n      const {value, size, constant} = attribute;\n      if (!constant && value && size >= 1) {\n        vertexCount = Math.min(vertexCount, value.length / size);\n      }\n    }\n\n    assert(Number.isFinite(vertexCount));\n    return vertexCount;\n  }\n}\n","// Feature detection for WebGL\n//\n// Provides a function that enables simple checking of which WebGL features are\n// available in an WebGL1 or WebGL2 environment.\n\n/* eslint-disable no-inline-comments, max-len */\nimport isOldIE from './is-old-ie';\nimport assert from './assert';\n\nconst GL_VENDOR = 0x1f00;\nconst GL_RENDERER = 0x1f01;\nconst GL_VERSION = 0x1f02;\nconst GL_SHADING_LANGUAGE_VERSION = 0x8b8c;\n\n// Defines luma.gl \"feature\" names and semantics\nconst WEBGL_FEATURES = {\n  // GLSL extensions\n  GLSL_FRAG_DATA: ['WEBGL_draw_buffers', true], // TODO - name makes no sense in GLSL 3.00\n  GLSL_FRAG_DEPTH: ['EXT_frag_depth', true],\n  GLSL_DERIVATIVES: ['OES_standard_derivatives', true],\n  GLSL_TEXTURE_LOD: ['EXT_shader_texture_lod', true]\n};\n\n// Create a key-mirrored FEATURES array\nconst FEATURES = {};\nObject.keys(WEBGL_FEATURES).forEach(key => {\n  FEATURES[key] = key;\n});\n\nexport {FEATURES};\n\nfunction isWebGL2(gl) {\n  return Boolean(gl && gl._version === 2);\n}\n\nexport function getContextInfo(gl) {\n  const info = gl.getExtension('WEBGL_debug_renderer_info');\n  const vendor = gl.getParameter((info && info.UNMASKED_VENDOR_WEBGL) || GL_VENDOR);\n  const renderer = gl.getParameter((info && info.UNMASKED_RENDERER_WEBGL) || GL_RENDERER);\n  const gpuVendor = identifyGPUVendor(vendor, renderer);\n  const gpuInfo = {\n    gpuVendor,\n    vendor,\n    renderer,\n    version: gl.getParameter(GL_VERSION),\n    shadingLanguageVersion: gl.getParameter(GL_SHADING_LANGUAGE_VERSION)\n  };\n  return gpuInfo;\n}\n\nfunction identifyGPUVendor(vendor, renderer) {\n  if (vendor.match(/NVIDIA/i) || renderer.match(/NVIDIA/i)) {\n    return 'NVIDIA';\n  }\n  if (vendor.match(/INTEL/i) || renderer.match(/INTEL/i)) {\n    return 'INTEL';\n  }\n  if (\n    vendor.match(/AMD/i) ||\n    renderer.match(/AMD/i) ||\n    vendor.match(/ATI/i) ||\n    renderer.match(/ATI/i)\n  ) {\n    return 'AMD';\n  }\n  return 'UNKNOWN GPU';\n}\n\nconst compiledGlslExtensions = {};\n\n// Enables feature detection in IE11 due to a bug where gl.getExtension may return true\n// but fail to compile when the extension is enabled in the shader. Specifically,\n// the OES_standard_derivatives and WEBGL_draw_buffers extensions fails to compile in IE11 even though its included\n// in the list of supported extensions.\n// opts allows user agent to be overridden for testing\n/*\n* Inputs :\n*  gl : WebGL context\n*  cap : Key of WEBGL_FEATURES object identifying the extension\n*  opts :\n*   behavior : behavor of extension to be tested, by defualt `enable` is used\n* Returns : true, if shader is compiled successfully, false otherwise\n*/\nexport function canCompileGLGSExtension(gl, cap, opts = {}) {\n  const feature = WEBGL_FEATURES[cap];\n  assert(feature, cap);\n\n  if (!isOldIE(opts)) {\n    return true;\n  }\n\n  if (cap in compiledGlslExtensions) {\n    return compiledGlslExtensions[cap];\n  }\n\n  const extensionName = feature[0];\n  const behavior = opts.behavior || 'enable';\n  const source = `#extension GL_${extensionName} : ${behavior}\\nvoid main(void) {}`;\n\n  const shader = gl.createShader(gl.VERTEX_SHADER);\n  gl.shaderSource(shader, source);\n  gl.compileShader(shader);\n  const canCompile = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\n  gl.deleteShader(shader);\n  compiledGlslExtensions[cap] = canCompile;\n  return canCompile;\n}\n\n// TODO - cache the value\nfunction getFeature(gl, cap) {\n  const feature = WEBGL_FEATURES[cap];\n  assert(feature, cap);\n\n  // Get extension name from table\n  const extensionName = isWebGL2(gl) ? feature[1] || feature[0] : feature[0];\n\n  // Check if the value is dependent on checking an extension\n  const value =\n    typeof extensionName === 'string' ? Boolean(gl.getExtension(extensionName)) : extensionName;\n\n  assert(value === false || value === true);\n\n  return value;\n}\n\nexport function hasFeatures(gl, features) {\n  features = Array.isArray(features) ? features : [features];\n  return features.every(feature => getFeature(gl, feature));\n}\n","/* global window */\n// opts allows user agent to be overridden for testing\nexport default function isOldIE(opts = {}) {\n  const navigator = typeof window !== 'undefined' ? window.navigator || {} : {};\n  const userAgent = opts.userAgent || navigator.userAgent || '';\n  // We only care about older versions of IE (IE 11 and below). Newer versions of IE (Edge)\n  // have much better web standards support.\n  const isMSIE = userAgent.indexOf('MSIE ') !== -1;\n  const isTrident = userAgent.indexOf('Trident/') !== -1;\n  return isMSIE || isTrident;\n}\n","import {getContextInfo, hasFeatures, canCompileGLGSExtension, FEATURES} from '../utils/webgl-info';\n\nexport function getPlatformShaderDefines(gl) {\n  const debugInfo = getContextInfo(gl);\n\n  switch (debugInfo.gpuVendor.toLowerCase()) {\n    case 'nvidia':\n      return `\\\n#define NVIDIA_GPU\n// Nvidia optimizes away the calculation necessary for emulated fp64\n#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1\n`;\n\n    case 'intel':\n      return `\\\n#define INTEL_GPU\n// Intel optimizes away the calculation necessary for emulated fp64\n#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1\n// Intel's built-in 'tan' function doesn't have acceptable precision\n#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1\n// Intel GPU doesn't have full 32 bits precision in same cases, causes overflow\n#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1\n`;\n\n    case 'amd':\n      // AMD Does not eliminate fp64 code\n      return `\\\n#define AMD_GPU\n`;\n\n    default:\n      // We don't know what GPU it is, could be that the GPU driver or\n      // browser is not implementing UNMASKED_RENDERER constant and not\n      // reporting a correct name\n      return `\\\n#define DEFAULT_GPU\n// Prevent driver from optimizing away the calculation necessary for emulated fp64\n#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1\n// Intel's built-in 'tan' function doesn't have acceptable precision\n#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1\n// Intel GPU doesn't have full 32 bits precision in same cases, causes overflow\n#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1\n`;\n  }\n}\n\nexport function getVersionDefines(gl, glslVersion, isFragment) {\n  // Add shadertools defines to let shaders portably v1/v3 check for features\n  let versionDefines = `\\\n#if (__VERSION__ > 120)\n\n# define FRAG_DEPTH\n# define DERIVATIVES\n# define DRAW_BUFFERS\n# define TEXTURE_LOD\n\n#endif // __VERSION\n`;\n\n  if (hasFeatures(gl, FEATURES.GLSL_FRAG_DEPTH)) {\n    versionDefines += `\\\n// FRAG_DEPTH => gl_FragDepth is available\n#ifdef GL_EXT_frag_depth\n#extension GL_EXT_frag_depth : enable\n# define FRAG_DEPTH\n# define gl_FragDepth gl_FragDepthEXT\n#endif\n`;\n  }\n  if (\n    hasFeatures(gl, FEATURES.GLSL_DERIVATIVES) &&\n    canCompileGLGSExtension(gl, FEATURES.GLSL_DERIVATIVES)\n  ) {\n    versionDefines += `\\\n// DERIVATIVES => dxdF, dxdY and fwidth are available\n#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives : enable\n# define DERIVATIVES\n#endif\n`;\n  }\n  if (\n    hasFeatures(gl, FEATURES.GLSL_FRAG_DATA) &&\n    canCompileGLGSExtension(gl, FEATURES.GLSL_FRAG_DATA, {behavior: 'require'})\n  ) {\n    versionDefines += `\\\n// DRAW_BUFFERS => gl_FragData[] is available\n#ifdef GL_EXT_draw_buffers\n#extension GL_EXT_draw_buffers : require\n#define DRAW_BUFFERS\n#endif\n`;\n  }\n  if (hasFeatures(gl, FEATURES.GLSL_TEXTURE_LOD)) {\n    versionDefines += `\\\n// TEXTURE_LOD => texture2DLod etc are available\n#ifdef GL_EXT_shader_texture_lod\n#extension GL_EXT_shader_texture_lod : enable\n# define TEXTURE_LOD\n#define texture2DLod texture2DLodEXT\n#define texture2DProjLod texture2DProjLodEXT\n#define texture2DProjLod texture2DProjLodEXT\n#define textureCubeLod textureCubeLodEXT\n#define texture2DGrad texture2DGradEXT\n#define texture2DProjGrad texture2DProjGradEXT\n#define texture2DProjGrad texture2DProjGradEXT\n#define textureCubeGrad textureCubeGradEXT\n#endif\n`;\n  }\n  return versionDefines;\n}\n","import {VERTEX_SHADER, FRAGMENT_SHADER} from './constants';\nimport {resolveModules, getShaderModule} from './resolve-modules';\nimport {getPlatformShaderDefines, getVersionDefines} from './platform-defines';\nimport injectShader, {DECLARATION_INJECT_MARKER} from './inject-shader';\nimport {assert} from '../utils';\n/* eslint-disable max-depth, complexity */\n\nconst INJECT_SHADER_DECLARATIONS = `\\n\\n${DECLARATION_INJECT_MARKER}\\n\\n`;\n\nconst SHADER_TYPE = {\n  [VERTEX_SHADER]: 'vertex',\n  [FRAGMENT_SHADER]: 'fragment'\n};\n\nconst HOOK_FUNCTIONS = {\n  [VERTEX_SHADER]: {},\n  [FRAGMENT_SHADER]: {}\n};\n\nconst MODULE_INJECTIONS = {\n  [VERTEX_SHADER]: {},\n  [FRAGMENT_SHADER]: {}\n};\n\n// Precision prologue to inject before functions are injected in shader\n// TODO - extract any existing prologue in the fragment source and move it up...\nconst FRAGMENT_SHADER_PROLOGUE = `\\\nprecision highp float;\n\n`;\n\nexport function createShaderHook(hook, opts = {}) {\n  hook = hook.trim();\n  const [stage, signature] = hook.split(':');\n  const name = hook.replace(/\\(.+/, '');\n  HOOK_FUNCTIONS[stage][name] = Object.assign(opts, {signature});\n}\n\nexport function createModuleInjection(moduleName, opts) {\n  const {hook, injection, order = 0} = opts;\n  const shaderStage = hook.slice(0, 2);\n\n  const moduleInjections = MODULE_INJECTIONS[shaderStage];\n  moduleInjections[moduleName] = moduleInjections[moduleName] || {};\n\n  assert(!moduleInjections[moduleName][hook], 'Module injection already created');\n\n  moduleInjections[moduleName][hook] = {\n    injection,\n    order\n  };\n}\n\n// Helpful for tests\nexport function resetGlobalShaderHooks() {\n  HOOK_FUNCTIONS[VERTEX_SHADER] = {};\n  HOOK_FUNCTIONS[FRAGMENT_SHADER] = {};\n\n  MODULE_INJECTIONS[VERTEX_SHADER] = {};\n  MODULE_INJECTIONS[FRAGMENT_SHADER] = {};\n}\n\n// Inject a list of modules\nexport function assembleShaders(gl, opts) {\n  const {vs, fs} = opts;\n  const modules = resolveModules(opts.modules || []);\n  return {\n    gl,\n    vs: assembleShader(gl, Object.assign({}, opts, {source: vs, type: VERTEX_SHADER, modules})),\n    fs: assembleShader(gl, Object.assign({}, opts, {source: fs, type: FRAGMENT_SHADER, modules})),\n    getUniforms: assembleGetUniforms(modules),\n    modules: assembleModuleMap(modules)\n  };\n}\n\n// Pulls together complete source code for either a vertex or a fragment shader\n// adding prologues, requested module chunks, and any final injections.\nfunction assembleShader(\n  gl,\n  {\n    id,\n    source,\n    type,\n    modules,\n    defines = {},\n    hookFunctions = HOOK_FUNCTIONS,\n    moduleInjections = MODULE_INJECTIONS,\n    inject = {},\n    prologue = true,\n    log\n  }\n) {\n  assert(typeof source === 'string', 'shader source must be a string');\n\n  // TODO(Tarek): Supporting global hooks, remove when they're removed.\n  if (hookFunctions !== HOOK_FUNCTIONS) {\n    hookFunctions = {\n      [VERTEX_SHADER]: Object.assign(\n        {},\n        HOOK_FUNCTIONS[VERTEX_SHADER],\n        hookFunctions[VERTEX_SHADER]\n      ),\n      [FRAGMENT_SHADER]: Object.assign(\n        {},\n        HOOK_FUNCTIONS[FRAGMENT_SHADER],\n        hookFunctions[FRAGMENT_SHADER]\n      )\n    };\n  }\n\n  if (moduleInjections !== MODULE_INJECTIONS) {\n    moduleInjections = {\n      [VERTEX_SHADER]: Object.assign(\n        {},\n        MODULE_INJECTIONS[VERTEX_SHADER],\n        moduleInjections[VERTEX_SHADER]\n      ),\n      [FRAGMENT_SHADER]: Object.assign(\n        {},\n        MODULE_INJECTIONS[FRAGMENT_SHADER],\n        moduleInjections[FRAGMENT_SHADER]\n      )\n    };\n  }\n\n  const isVertex = type === VERTEX_SHADER;\n\n  const sourceLines = source.split('\\n');\n  let glslVersion = 100;\n  let versionLine = '';\n  let coreSource = source;\n  // Extract any version directive string from source.\n  // TODO : keep all pre-processor statements at the begining of the shader.\n  if (sourceLines[0].indexOf('#version ') === 0) {\n    glslVersion = 300; // TODO - regexp that matches atual version number\n    versionLine = sourceLines[0];\n    coreSource = sourceLines.slice(1).join('\\n');\n  } else {\n    versionLine = `#version ${glslVersion}`;\n  }\n\n  // Combine Module and Application Defines\n  const allDefines = {};\n  modules.forEach(module => {\n    Object.assign(allDefines, module.getDefines());\n  });\n  Object.assign(allDefines, defines);\n\n  // Add platform defines (use these to work around platform-specific bugs and limitations)\n  // Add common defines (GLSL version compatibility, feature detection)\n  // Add precision declaration for fragment shaders\n  let assembledSource = prologue\n    ? `\\\n${versionLine}\n${getShaderName({id, source, type})}\n${getShaderType({type})}\n${getPlatformShaderDefines(gl)}\n${getVersionDefines(gl, glslVersion, !isVertex)}\n${getApplicationDefines(allDefines)}\n${isVertex ? '' : FRAGMENT_SHADER_PROLOGUE}\n`\n    : `${versionLine}\n`;\n\n  // Add source of dependent modules in resolved order\n  let injectStandardStubs = false;\n  const hookInjections = {};\n  const mainInjections = {};\n\n  for (const key in inject) {\n    const injection =\n      typeof inject[key] === 'string' ? {injection: inject[key], order: 0} : inject[key];\n    if (key.match(/^(v|f)s:/)) {\n      if (key[3] === '#') {\n        mainInjections[key] = [injection];\n      } else {\n        hookInjections[key] = [injection];\n      }\n    } else {\n      // Regex injection\n      mainInjections[key] = [injection];\n    }\n  }\n\n  for (const module of modules) {\n    switch (module.name) {\n      case 'inject':\n        injectStandardStubs = true;\n        break;\n\n      default:\n        if (log) {\n          module.checkDeprecations(coreSource, log);\n        }\n        const moduleSource = module.getModuleSource(type, glslVersion);\n        // Add the module source, and a #define that declares it presence\n        assembledSource += moduleSource;\n\n        if (moduleInjections[type][module.name]) {\n          const injections = moduleInjections[type][module.name];\n          for (const key in injections) {\n            if (key.match(/^(v|f)s:#/)) {\n              mainInjections[key] = mainInjections[key] || [];\n              mainInjections[key].push(injections[key]);\n            } else {\n              hookInjections[key] = hookInjections[key] || [];\n              hookInjections[key].push(injections[key]);\n            }\n          }\n        }\n    }\n  }\n\n  // For injectShader\n  assembledSource += INJECT_SHADER_DECLARATIONS;\n\n  assembledSource += getHookFunctions(hookFunctions[type], hookInjections);\n\n  // Add the version directive and actual source of this shader\n  assembledSource += coreSource;\n\n  // Apply any requested shader injections\n  assembledSource = injectShader(assembledSource, type, mainInjections, injectStandardStubs);\n\n  return assembledSource;\n}\n\n// Returns a combined `getUniforms` covering the options for all the modules,\n// the created function will pass on options to the inidividual `getUniforms`\n// function of each shader module and combine the results into one object that\n// can be passed to setUniforms.\nfunction assembleGetUniforms(modules) {\n  return function getUniforms(opts) {\n    const uniforms = {};\n    for (const module of modules) {\n      // `modules` is already sorted by dependency level. This guarantees that\n      // modules have access to the uniforms that are generated by their dependencies.\n      const moduleUniforms = module.getUniforms(opts, uniforms);\n      Object.assign(uniforms, moduleUniforms);\n    }\n    return uniforms;\n  };\n}\n\n// Returns a map with module names as keys, resolving to their module definitions\n// The presence of a key indicates that the module is available in this program,\n// whether directly included, or through a dependency of some other module\nfunction assembleModuleMap(modules) {\n  const result = {};\n  for (const moduleName of modules) {\n    const shaderModule = getShaderModule(moduleName);\n    result[moduleName] = shaderModule;\n  }\n  return result;\n}\n\nfunction getShaderType({type}) {\n  return `\n#define SHADER_TYPE_${SHADER_TYPE[type].toUpperCase()}\n`;\n}\n\n// Generate \"glslify-compatible\" SHADER_NAME defines\n// These are understood by the GLSL error parsing function\n// If id is provided and no SHADER_NAME constant is present in source, create one\nfunction getShaderName({id, source, type}) {\n  const injectShaderName = id && typeof id === 'string' && source.indexOf('SHADER_NAME') === -1;\n  return injectShaderName\n    ? `\n#define SHADER_NAME ${id}_${SHADER_TYPE[type]}\n\n`\n    : '';\n}\n\n// Generates application defines from an object\nfunction getApplicationDefines(defines = {}) {\n  let count = 0;\n  let sourceText = '';\n  for (const define in defines) {\n    if (count === 0) {\n      sourceText += '\\n// APPLICATION DEFINES\\n';\n    }\n    count++;\n\n    const value = defines[define];\n    if (value || Number.isFinite(value)) {\n      sourceText += `#define ${define.toUpperCase()} ${defines[define]}\\n`;\n    }\n  }\n  if (count === 0) {\n    sourceText += '\\n';\n  }\n  return sourceText;\n}\n\nfunction getHookFunctions(hookFunctions, hookInjections) {\n  let result = '';\n  for (const hookName in hookFunctions) {\n    const hookFunction = hookFunctions[hookName];\n    result += `void ${hookFunction.signature} {\\n`;\n    if (hookFunction.header) {\n      result += `  ${hookFunction.header}`;\n    }\n    if (hookInjections[hookName]) {\n      const injections = hookInjections[hookName];\n      injections.sort((a, b) => a.order - b.order);\n      for (const injection of injections) {\n        result += `  ${injection.injection}\\n`;\n      }\n    }\n    if (hookFunction.footer) {\n      result += `  ${hookFunction.footer}`;\n    }\n    result += '}\\n';\n  }\n\n  return result;\n}\n","import ShaderModule from './shader-module';\nimport {assert} from '../utils';\n\nexport default class ShaderModuleRegistry {\n  constructor() {\n    this.shaderModules = {};\n    this.defaultShaderModules = [];\n  }\n\n  setDefaultShaderModules(modules) {\n    this.defaultShaderModules = this.resolveModules(modules);\n  }\n\n  getDefaultShaderModules() {\n    return this.defaultShaderModules;\n  }\n\n  registerShaderModules(shaderModuleList, {ignoreMultipleRegistrations = false} = {}) {\n    for (const shaderModule of shaderModuleList) {\n      this._registerShaderModule(shaderModule, ignoreMultipleRegistrations);\n    }\n  }\n\n  getShaderModule(moduleOrName) {\n    // Check if \"inline\" module, return it\n    if (moduleOrName instanceof ShaderModule) {\n      return moduleOrName;\n    }\n\n    // Check if module descriptor\n    if (typeof moduleOrName !== 'string') {\n      return this._registerShaderModule(moduleOrName, true);\n    }\n\n    // Module name - Look up module\n    const module = this.shaderModules[moduleOrName];\n    if (!module) {\n      assert(false, `Unknown shader module ${moduleOrName}`);\n    }\n    return module;\n  }\n\n  // registers any supplied modules, resolves any names into modules\n  // returns a list of modules\n  resolveModules(modules) {\n    return modules.map(moduleOrName => this.getShaderModule(moduleOrName));\n  }\n\n  // PRIVATE API\n\n  _registerShaderModule(module, ignoreMultipleRegistrations = false) {\n    // Check if \"inline\" module, return it\n    if (module instanceof ShaderModule) {\n      return module;\n    }\n\n    assert(module.name, 'shader module has no name');\n\n    if (!this.shaderModules[module.name] || ignoreMultipleRegistrations) {\n      // if ignoreMultipleRegistrations = true, we allow module to be re-registered\n      module = new ShaderModule(module);\n      module.dependencies = this.resolveModules(module.dependencies);\n      this.shaderModules[module.name] = module;\n    } else {\n      // TODO - instead verify that definition is not changing...\n      throw new Error(`shader module ${module.name} already registered`);\n    }\n\n    return this.shaderModules[module.name];\n  }\n}\n","import ShaderModuleRegistry from './shader-module-registry';\n\nconst shaderModuleRegistry = new ShaderModuleRegistry();\n\n/**\n * Registers an array of default shader modules. These will be concatenated\n * automatically at the end of any shader module list passed to\n * `assembleShaders` (plus `resolveModules` and `getShaderDependencies`)\n * @param {Object[]} modules - Array of shader modules\n */\nexport function setDefaultShaderModules(modules) {\n  shaderModuleRegistry.setDefaultShaderModules(modules);\n}\n\nexport function getDefaultShaderModules() {\n  return shaderModuleRegistry.getDefaultShaderModules();\n}\n\n/**\n * Registers an array of shader modules\n * @param {Object[]} shaderModuleList - Array of shader modules\n */\nexport function registerShaderModules(\n  shaderModuleList,\n  {ignoreMultipleRegistrations = false} = {}\n) {\n  shaderModuleRegistry.registerShaderModules(shaderModuleList, {ignoreMultipleRegistrations});\n}\n\n// registers any supplied modules and returns a list of module names\nexport function resolveModules(modules) {\n  modules = modules.concat(shaderModuleRegistry.defaultShaderModules);\n  modules = shaderModuleRegistry.resolveModules(modules);\n  return getShaderDependencies(modules);\n}\n\n// Looks up a moduleName among registered modules and returns definition.\n// If \"inline\" module, returns it directly\nexport function getShaderModule(moduleOrName) {\n  return shaderModuleRegistry.getShaderModule(moduleOrName);\n}\n\n/**\n * Takes a list of shader module names and returns a new list of\n * shader module names that includes all dependencies, sorted so\n * that modules that are dependencies of other modules come first.\n *\n * If the shader glsl code from the returned modules is concatenated\n * in the reverse order, it is guaranteed that all functions be resolved and\n * that all function and variable definitions come before use.\n *\n * @param {String[]} modules - Array of modules (inline modules or module names)\n * @return {String[]} - Array of modules\n */\nfunction getShaderDependencies(modules) {\n  const moduleMap = {};\n  const moduleDepth = {};\n  getDependencyGraph({modules, level: 0, moduleMap, moduleDepth});\n\n  // Return a reverse sort so that dependencies come before the modules that use them\n  return Object.keys(moduleDepth)\n    .sort((a, b) => moduleDepth[b] - moduleDepth[a])\n    .map(name => moduleMap[name]);\n}\n\n/**\n * Recursively checks module dpendencies to calculate dependency\n * level of each module.\n *\n * @param {String[]} modules - Array of modules\n * @param {Number} level - Current level\n * @return {result} - Map of module name to its level\n */\n// Adds another level of dependencies to the result map\nfunction getDependencyGraph({modules, level, moduleMap, moduleDepth}) {\n  if (level >= 5) {\n    throw new Error('Possible loop in shader dependency graph');\n  }\n\n  // Update level on all current modules\n  for (const module of modules) {\n    moduleMap[module.name] = module;\n    if (moduleDepth[module.name] === undefined || moduleDepth[module.name] < level) {\n      moduleDepth[module.name] = level;\n    }\n  }\n\n  // Recurse\n  for (const module of modules) {\n    if (module.dependencies) {\n      getDependencyGraph({modules: module.dependencies, level: level + 1, moduleMap, moduleDepth});\n    }\n  }\n}\n\nexport const TEST_EXPORTS = {\n  getShaderDependencies,\n  getDependencyGraph\n};\n","import GL from '@luma.gl/constants';\nimport {Buffer} from '@luma.gl/webgl';\nimport {assert} from '../utils';\n\n// Support for mapping new geometries with glTF attribute names to \"classic\" luma.gl shader names\nconst GLTF_TO_LUMA_ATTRIBUTE_MAP = {\n  POSITION: 'positions',\n  NORMAL: 'normals',\n  COLOR_0: 'colors',\n  TEXCOORD_0: 'texCoords',\n  TEXCOORD_1: 'texCoords1',\n  TEXCOORD_2: 'texCoords2'\n};\n\nexport function getBuffersFromGeometry(gl, geometry, options) {\n  const buffers = {};\n  let indices = geometry.indices;\n\n  for (const name in geometry.attributes) {\n    const attribute = geometry.attributes[name];\n    const remappedName = mapAttributeName(name, options);\n\n    if (name === 'indices') {\n      indices = attribute;\n    } else if (attribute.constant) {\n      buffers[remappedName] = attribute.value;\n    } else {\n      const typedArray = attribute.value;\n      // Create accessor by copying the attribute and removing `value``\n      const accessor = {...attribute};\n      delete accessor.value;\n      buffers[remappedName] = [new Buffer(gl, typedArray), accessor];\n\n      inferAttributeAccessor(name, accessor);\n    }\n  }\n\n  if (indices) {\n    const data = indices.value || indices;\n    assert(\n      data instanceof Uint16Array || data instanceof Uint32Array,\n      'attribute array for \"indices\" must be of integer type'\n    );\n    const accessor = {\n      size: 1,\n      isIndexed: indices.isIndexed === undefined ? true : indices.isIndexed\n    };\n    buffers.indices = [\n      new Buffer(gl, {\n        data,\n        target: GL.ELEMENT_ARRAY_BUFFER\n      }),\n      accessor\n    ];\n  }\n\n  return buffers;\n}\n\nfunction mapAttributeName(name, options) {\n  const {attributeMap = GLTF_TO_LUMA_ATTRIBUTE_MAP} = options || {};\n  return (attributeMap && attributeMap[name]) || name;\n}\n\n// Check for well known attribute names\n// eslint-disable-next-line complexity\nexport function inferAttributeAccessor(attributeName, attribute) {\n  let category;\n  switch (attributeName) {\n    case 'texCoords':\n    case 'texCoord1':\n    case 'texCoord2':\n    case 'texCoord3':\n      category = 'uvs';\n      break;\n    case 'vertices':\n    case 'positions':\n    case 'normals':\n    case 'pickingColors':\n      category = 'vectors';\n      break;\n    default:\n  }\n\n  // Check for categorys\n  switch (category) {\n    case 'vectors':\n      attribute.size = attribute.size || 3;\n      break;\n    case 'uvs':\n      attribute.size = attribute.size || 2;\n      break;\n    default:\n  }\n\n  assert(Number.isFinite(attribute.size), `attribute ${attributeName} needs size`);\n}\n","import {assembleShaders} from '@luma.gl/shadertools';\nimport {Program} from '@luma.gl/webgl';\n\nexport default class ProgramManager {\n  static getDefaultProgramManager(gl) {\n    gl.luma = gl.luma || {};\n    gl.luma.defaultProgramManager = gl.luma.defaultProgramManager || new ProgramManager(gl);\n\n    return gl.luma.defaultProgramManager;\n  }\n\n  constructor(gl) {\n    this.gl = gl;\n\n    this._programCache = {};\n    this._getUniforms = {};\n    this._registeredModules = {};\n    this._moduleInjections = {\n      vs: {},\n      fs: {}\n    };\n    this._hookFunctions = {\n      vs: {},\n      fs: {}\n    };\n    this._defaultModules = [];\n\n    this._hashes = {};\n    this._hashCounter = 0;\n    this.stateHash = 0; // Used change hashing if hooks are modified\n    this._useCounts = {};\n  }\n\n  addDefaultModule(module) {\n    if (!this._defaultModules.find(m => m.name === module.name)) {\n      this._defaultModules.push(module);\n    }\n\n    this.stateHash++;\n  }\n\n  removeDefaultModule(module) {\n    const moduleName = typeof module === 'string' ? module : module.name;\n    this._defaultModules = this._defaultModules.filter(m => m.name !== moduleName);\n    this.stateHash++;\n  }\n\n  addModuleInjection(module, opts) {\n    const moduleName = typeof module === 'string' ? module : module.name;\n    const {hook, injection, order = 0} = opts;\n    const shaderStage = hook.slice(0, 2);\n\n    const moduleInjections = this._moduleInjections[shaderStage];\n    moduleInjections[moduleName] = moduleInjections[moduleName] || {};\n\n    moduleInjections[moduleName][hook] = {\n      injection,\n      order\n    };\n\n    this.stateHash++;\n  }\n\n  addShaderHook(hook, opts = {}) {\n    hook = hook.trim();\n    const [stage, signature] = hook.split(':');\n    const name = hook.replace(/\\(.+/, '');\n    this._hookFunctions[stage][name] = Object.assign(opts, {signature});\n\n    this.stateHash++;\n  }\n\n  get(props = {}) {\n    const {vs = '', fs = '', defines = {}, inject = {}, varyings = [], bufferMode = 0x8c8d} = props; // varyings/bufferMode for xform feedback, 0x8c8d = SEPARATE_ATTRIBS\n\n    const modules = this._getModuleList(props.modules); // Combine with default modules\n\n    const vsHash = this._getHash(vs);\n    const fsHash = this._getHash(fs);\n    const moduleHashes = modules.map(m => this._getHash(typeof m === 'string' ? m : m.name)).sort();\n    const varyingHashes = varyings.map(v => this._getHash(v));\n\n    const defineKeys = Object.keys(defines).sort();\n    const injectKeys = Object.keys(inject).sort();\n    const defineHashes = [];\n    const injectHashes = [];\n\n    for (const key of defineKeys) {\n      defineHashes.push(this._getHash(key));\n      defineHashes.push(this._getHash(defines[key]));\n    }\n\n    for (const key of injectKeys) {\n      defineHashes.push(this._getHash(key));\n      defineHashes.push(this._getHash(inject[key]));\n    }\n\n    const hash = `${vsHash}/${fsHash}D${defineHashes.join('/')}M${moduleHashes.join(\n      '/'\n    )}I${injectHashes.join('/')}V${varyingHashes.join('/')}H${this.stateHash}B${bufferMode}`;\n\n    if (!this._programCache[hash]) {\n      const assembled = assembleShaders(this.gl, {\n        vs,\n        fs,\n        modules,\n        inject,\n        defines,\n        hookFunctions: this._hookFunctions,\n        moduleInjections: this._moduleInjections\n      });\n\n      this._programCache[hash] = new Program(this.gl, {\n        hash,\n        vs: assembled.vs,\n        fs: assembled.fs,\n        varyings,\n        bufferMode\n      });\n\n      this._getUniforms[hash] = assembled.getUniforms || (x => {});\n      this._useCounts[hash] = 0;\n    }\n\n    this._useCounts[hash]++;\n\n    return this._programCache[hash];\n  }\n\n  getUniforms(program) {\n    return this._getUniforms[program.hash] || null;\n  }\n\n  release(program) {\n    const hash = program.hash;\n    this._useCounts[hash]--;\n\n    if (this._useCounts[hash] === 0) {\n      this._programCache[hash].delete();\n      delete this._programCache[hash];\n      delete this._getUniforms[hash];\n      delete this._useCounts[hash];\n    }\n  }\n\n  _getHash(key) {\n    if (this._hashes[key] === undefined) {\n      this._hashes[key] = this._hashCounter++;\n    }\n\n    return this._hashes[key];\n  }\n\n  // Dedup and combine with default modules\n  _getModuleList(appModules = []) {\n    const modules = new Array(this._defaultModules.length + appModules.length);\n    const seen = {};\n    let count = 0;\n\n    for (let i = 0, len = this._defaultModules.length; i < len; ++i) {\n      const module = this._defaultModules[i];\n      const name = typeof module === 'string' ? module : module.name;\n      modules[count++] = module;\n      seen[name] = true;\n    }\n\n    for (let i = 0, len = appModules.length; i < len; ++i) {\n      const module = appModules[i];\n      const name = typeof module === 'string' ? module : module.name;\n      if (!seen[name]) {\n        modules[count++] = module;\n        seen[name] = true;\n      }\n    }\n\n    modules.length = count;\n\n    return modules;\n  }\n}\n","// TODO / DEPRECATED - delete when confident that probe.gl logging implements all opts\n/* eslint-disable no-console */\nfunction formatArrayValue(v, opts) {\n  const {maxElts = 16, size = 1} = opts;\n  let string = '[';\n  for (let i = 0; i < v.length && i < maxElts; ++i) {\n    if (i > 0) {\n      string += `,${i % size === 0 ? ' ' : ''}`;\n    }\n    string += formatValue(v[i], opts);\n  }\n  const terminator = v.length > maxElts ? '...' : ']';\n  return `${string}${terminator}`;\n}\n\nexport function formatValue(v, opts = {}) {\n  const EPSILON = 1e-16;\n  const {isInteger = false} = opts;\n  if (Array.isArray(v) || ArrayBuffer.isView(v)) {\n    return formatArrayValue(v, opts);\n  }\n  if (!Number.isFinite(v)) {\n    return String(v);\n  }\n  if (Math.abs(v) < EPSILON) {\n    return isInteger ? '0' : '0.';\n  }\n  if (isInteger) {\n    return v.toFixed(0);\n  }\n  if (Math.abs(v) > 100 && Math.abs(v) < 10000) {\n    return v.toFixed(0);\n  }\n  const string = v.toPrecision(2);\n  const decimal = string.indexOf('.0');\n  return decimal === string.length - 2 ? string.slice(0, -1) : string;\n}\n","import Buffer from '../classes/buffer';\nimport {getKey} from '../webgl-utils';\nimport {getCompositeGLType} from '../webgl-utils/attribute-utils';\nimport {formatValue} from '../utils';\n\n// Creates object suitable as input for console.table\nexport function getDebugTableForVertexArray({vertexArray, header = 'Attributes'} = {}) {\n  if (!vertexArray.configuration) {\n    return {};\n  }\n\n  const table = {}; // {[header]: {}};\n\n  // Add index (elements) if available\n  if (vertexArray.elements) {\n    // const elements = Object.assign({size: 1}, vertexArray.elements);\n    table.ELEMENT_ARRAY_BUFFER = getDebugTableRow(vertexArray, vertexArray.elements, null, header);\n  }\n\n  // Add used attributes\n  const attributes = vertexArray.values;\n\n  for (const attributeLocation in attributes) {\n    const info = vertexArray._getAttributeInfo(attributeLocation);\n    if (info) {\n      let rowHeader = `${attributeLocation}: ${info.name}`;\n      const accessor = vertexArray.accessors[info.location];\n      if (accessor) {\n        rowHeader = `${attributeLocation}: ${getGLSLDeclaration(info.name, accessor)}`;\n      }\n      table[rowHeader] = getDebugTableRow(\n        vertexArray,\n        attributes[attributeLocation],\n        accessor,\n        header\n      );\n    }\n  }\n\n  return table;\n}\n\n/* eslint-disable max-statements */\nfunction getDebugTableRow(vertexArray, attribute, accessor, header) {\n  const {gl} = vertexArray;\n\n  if (!attribute) {\n    return {\n      [header]: 'null',\n      'Format ': 'N/A'\n    };\n  }\n\n  let type = 'NOT PROVIDED';\n  let size = 'N/A';\n  let verts = 'N/A';\n  let bytes = 'N/A';\n\n  let isInteger;\n  let marker;\n  let value;\n\n  if (accessor) {\n    type = accessor.type;\n    size = accessor.size;\n\n    // Generate a type name by dropping Array from Float32Array etc.\n    type = String(type).replace('Array', '');\n\n    // Look for 'nt' to detect integer types, e.g. Int32Array, Uint32Array\n    isInteger = type.indexOf('nt') !== -1;\n  }\n\n  if (attribute instanceof Buffer) {\n    const buffer = attribute;\n\n    const {data, modified} = buffer.getDebugData();\n    marker = modified ? '*' : '';\n\n    value = data;\n    bytes = buffer.byteLength;\n    verts = bytes / data.BYTES_PER_ELEMENT / size;\n\n    let format;\n\n    if (accessor) {\n      const instanced = accessor.divisor > 0;\n      format = `${instanced ? 'I ' : 'P '} ${verts} (x${size}=${bytes} bytes ${getKey(gl, type)})`;\n    } else {\n      // element buffer\n      isInteger = true;\n      format = `${bytes} bytes`;\n    }\n\n    return {\n      [header]: `${marker}${formatValue(value, {size, isInteger})}`,\n      'Format ': format\n    };\n  }\n\n  // CONSTANT VALUE\n  value = attribute;\n  size = attribute.length;\n  // Generate a type name by dropping Array from Float32Array etc.\n  type = String(attribute.constructor.name).replace('Array', '');\n  // Look for 'nt' to detect integer types, e.g. Int32Array, Uint32Array\n  isInteger = type.indexOf('nt') !== -1;\n\n  return {\n    [header]: `${formatValue(value, {size, isInteger})} (constant)`,\n    'Format ': `${size}x${type} (constant)`\n  };\n}\n/* eslint-ensable max-statements */\n\nfunction getGLSLDeclaration(name, accessor) {\n  const {type, size} = accessor;\n  const typeAndName = getCompositeGLType(type, size);\n  return typeAndName ? `${name} (${typeAndName.name})` : name;\n}\n","import {formatValue, assert} from '../utils';\n\n// Prepares a table suitable for console.table\n/* eslint-disable max-statements, complexity */\nexport function getDebugTableForUniforms({\n  header = 'Uniforms',\n  program,\n  uniforms,\n  undefinedOnly = false\n} = {}) {\n  assert(program);\n\n  const SHADER_MODULE_UNIFORM_REGEXP = '.*_.*';\n  const PROJECT_MODULE_UNIFORM_REGEXP = '.*Matrix'; // TODO - Use explicit list\n\n  const uniformLocations = program._uniformSetters;\n  const table = {}; // {[header]: {}};\n\n  // Add program's provided uniforms (in alphabetical order)\n  const uniformNames = Object.keys(uniformLocations).sort();\n\n  let count = 0;\n\n  // First add non-underscored uniforms (assumed not coming from shader modules)\n  for (const uniformName of uniformNames) {\n    if (\n      !uniformName.match(SHADER_MODULE_UNIFORM_REGEXP) &&\n      !uniformName.match(PROJECT_MODULE_UNIFORM_REGEXP)\n    ) {\n      if (addUniformToTable({table, header, uniforms, uniformName, undefinedOnly})) {\n        count++;\n      }\n    }\n  }\n\n  // add underscored uniforms (assumed from shader modules)\n  for (const uniformName of uniformNames) {\n    if (uniformName.match(PROJECT_MODULE_UNIFORM_REGEXP)) {\n      if (addUniformToTable({table, header, uniforms, uniformName, undefinedOnly})) {\n        count++;\n      }\n    }\n  }\n\n  for (const uniformName of uniformNames) {\n    if (!table[uniformName]) {\n      if (addUniformToTable({table, header, uniforms, uniformName, undefinedOnly})) {\n        count++;\n      }\n    }\n  }\n\n  // Create a table of unused uniforms\n  let unusedCount = 0;\n  const unusedTable = {};\n  if (!undefinedOnly) {\n    for (const uniformName in uniforms) {\n      const uniform = uniforms[uniformName];\n      if (!table[uniformName]) {\n        unusedCount++;\n        unusedTable[uniformName] = {\n          Type: `NOT USED: ${uniform}`,\n          [header]: formatValue(uniform)\n        };\n      }\n    }\n  }\n\n  return {table, count, unusedTable, unusedCount};\n}\n\n// Helper\nfunction addUniformToTable({table, header, uniforms, uniformName, undefinedOnly}) {\n  const value = uniforms[uniformName];\n  const isDefined = isUniformDefined(value);\n  if (!undefinedOnly || !isDefined) {\n    table[uniformName] = {\n      // Add program's unprovided uniforms\n      [header]: isDefined ? formatValue(value) : 'N/A',\n      'Uniform Type': isDefined ? value : 'NOT PROVIDED'\n    };\n    return true;\n  }\n  return false;\n}\n\nfunction isUniformDefined(value) {\n  return value !== undefined && value !== null;\n}\n","import {getCompositeGLType} from '../webgl-utils/attribute-utils';\n\nexport function getDebugTableForProgramConfiguration(config) {\n  const table = {};\n\n  const header = `Accessors for ${config.id}`;\n\n  for (const attributeInfo of config.attributeInfos) {\n    if (attributeInfo) {\n      const glslDeclaration = getGLSLDeclaration(attributeInfo);\n      table[`in ${glslDeclaration}`] = {[header]: JSON.stringify(attributeInfo.accessor)};\n    }\n  }\n\n  for (const varyingInfo of config.varyingInfos) {\n    if (varyingInfo) {\n      const glslDeclaration = getGLSLDeclaration(varyingInfo);\n      table[`out ${glslDeclaration}`] = {[header]: JSON.stringify(varyingInfo.accessor)};\n    }\n  }\n\n  return table;\n}\n\nfunction getGLSLDeclaration(attributeInfo) {\n  const {type, size} = attributeInfo.accessor;\n  const typeAndName = getCompositeGLType(type, size);\n  if (typeAndName) {\n    return `${typeAndName.name} ${attributeInfo.name}`;\n  }\n  return attributeInfo.name;\n}\n","import seer from 'seer';\n\nimport {window} from '../utils';\n\nconst models = {};\n\n/**\n * Add a model to our cache indexed by id\n */\nexport const addModel = model => {\n  if (models[model.id]) {\n    return;\n  }\n  models[model.id] = model;\n\n  seer.listItem('luma.gl', model.id);\n};\n\n/**\n * Log a model uniforms and attributes.\n */\nexport const logModel = (model, uniforms) => {\n  if (!seer.isReady() || seer.throttle(`luma.gl:${model.id}`, 1e3)) {\n    return;\n  }\n\n  const attributesObject = model.geometry\n    ? Object.assign({}, model.geometry.attributes, model.attributes)\n    : model.attributes;\n  const uniformsObject = Object.assign({}, model.uniforms, uniforms);\n\n  seer.multiUpdate('luma.gl', model.id, [\n    {path: 'objects.uniforms', data: uniformsObject},\n    {path: 'objects.attributes', data: attributesObject}\n  ]);\n};\n\n/**\n * Remove a previously set model from the cache\n */\nexport const removeModel = id => {\n  delete models[id];\n  seer.deleteItem('luma.gl', id);\n};\n\n/**\n * Recursively traverse an object given a path of properties and set the given value\n */\nconst recursiveSet = (obj, path, value) => {\n  if (!obj) {\n    return;\n  }\n\n  if (path.length > 1) {\n    recursiveSet(obj[path[0]], path.slice(1), value);\n  } else {\n    obj[path[0]] = value;\n  }\n};\n\nconst overrides = new Map();\n\n/**\n * Create an override on the specify layer, indexed by a valuePath array.\n * Do nothing in case Seer as not been initialized to prevent any preformance drawback.\n */\nexport const setOverride = (id, valuePath, value) => {\n  if (!window.__SEER_INITIALIZED__) {\n    return;\n  }\n\n  if (!overrides.has(id)) {\n    overrides.set(id, new Map());\n  }\n\n  const uniforms = overrides.get(id);\n  uniforms.set(valuePath, value);\n};\n\n/**\n * Apply overrides to a specific model's uniforms\n */\nexport const getOverrides = (id, uniforms) => {\n  if (!window.__SEER_INITIALIZED__ || !id) {\n    return;\n  }\n\n  const overs = overrides.get(id);\n  if (!overs) {\n    return;\n  }\n\n  overs.forEach((value, valuePath) => {\n    recursiveSet(uniforms, valuePath, value);\n  });\n};\n\n/**\n * Listen for luma.gl edit events\n */\nseer.listenFor('luma.gl', payload => {\n  const model = models[payload.itemKey];\n  if (!model || payload.type !== 'edit' || payload.valuePath[0] !== 'uniforms') {\n    return;\n  }\n\n  const valuePath = payload.valuePath.slice(1);\n  setOverride(payload.itemKey, valuePath, payload.value);\n\n  const uniforms = model.getUniforms();\n  recursiveSet(uniforms, valuePath, payload.value);\n  model.setUniforms(uniforms);\n});\n","/* eslint-disable complexity */\n// Shared code between Model and MeshModel\nimport ProgramManager from '../resource-management/program-manager';\nimport {isWebGL, Query, Program, VertexArray, clear} from '@luma.gl/webgl';\nimport {MODULAR_SHADERS} from '@luma.gl/shadertools';\nimport {\n  getDebugTableForUniforms,\n  getDebugTableForVertexArray,\n  getDebugTableForProgramConfiguration\n} from '@luma.gl/webgl';\nimport {addModel, removeModel, logModel, getOverrides} from '../debug/seer-integration';\nimport {log, isObjectEmpty, uid, assert} from '../utils';\n\nconst LOG_DRAW_PRIORITY = 2;\nconst LOG_DRAW_TIMEOUT = 10000;\n\n// Model abstract O3D Class\nexport default class BaseModel {\n  constructor(gl, props = {}) {\n    assert(isWebGL(gl));\n    const {id = uid('base-model')} = props;\n    this.id = id;\n    this.gl = gl;\n    this.id = props.id || uid('Model');\n    this.lastLogTime = 0; // TODO - move to probe.gl\n    this.initialize(props);\n  }\n\n  initialize(props) {\n    this.props = {};\n\n    if (props.shaderCache) {\n      log.warn('ShaderCache property is deprecated')();\n    }\n\n    this.programManager = props.programManager || ProgramManager.getDefaultProgramManager(this.gl);\n    this._programManagerState = -1;\n    this._managedProgram = false;\n\n    const {program = null, vs, fs, modules, defines, inject, varyings, bufferMode} = props;\n\n    this.programProps = {program, vs, fs, modules, defines, inject, varyings, bufferMode};\n    this.program = null;\n    this.vertexArray = null;\n    this._programDirty = true;\n\n    // Initialize state\n    this.userData = {};\n    this.needsRedraw = true;\n\n    // Attributes and buffers\n    // Model manages auto Buffer creation from typed arrays\n    this._attributes = {}; // All attributes\n    this.attributes = {}; // User defined attributes\n\n    // Model manages uniform animation\n    this.uniforms = {};\n    this.animatedUniforms = {};\n    this.animated = false;\n    this.animationLoop = null; // if set, used as source for animationProps\n\n    this.timerQueryEnabled = false;\n    this.timeElapsedQuery = undefined;\n    this.lastQueryReturned = true;\n\n    this.stats = {\n      accumulatedFrameTime: 0,\n      averageFrameTime: 0,\n      profileFrameCount: 0\n    };\n\n    // picking options\n    this.pickable = true;\n\n    this._checkProgram();\n\n    this._setBaseModelProps(props);\n\n    this.setUniforms(\n      Object.assign(\n        {},\n        this.getModuleUniforms(props.moduleSettings) // Get unforms for supplied parameters\n      )\n    );\n  }\n\n  setProps(props) {\n    this._setBaseModelProps(props);\n  }\n\n  delete() {\n    // delete all attributes created by this model\n    // TODO - should buffer deletes be handled by vertex array?\n    for (const key in this._attributes) {\n      if (this._attributes[key] !== this.attributes[key]) {\n        this._attributes[key].delete();\n      }\n    }\n\n    if (this._managedProgram) {\n      this.programManager.release(this.program);\n    }\n\n    this.vertexArray.delete();\n\n    removeModel(this.id);\n  }\n\n  // GETTERS\n\n  isAnimated() {\n    return this.animated;\n  }\n\n  getProgram() {\n    return this.program;\n  }\n\n  setProgram(props) {\n    this.programProps = Object.assign({}, props);\n    this._programDirty = true;\n  }\n\n  getUniforms() {\n    return this.uniforms;\n  }\n\n  // SETTERS\n\n  // TODO - should actually set the uniforms\n  setUniforms(uniforms = {}) {\n    // Let Seer override edited uniforms\n    uniforms = Object.assign({}, uniforms);\n    getOverrides(this.id, uniforms);\n\n    // Resolve any animated uniforms so that we have an initial value\n    uniforms = this._extractAnimatedUniforms(uniforms);\n\n    Object.assign(this.uniforms, uniforms);\n\n    return this;\n  }\n\n  getModuleUniforms(opts) {\n    this._checkProgram();\n\n    const getUniforms = this.programManager.getUniforms(this.program);\n\n    if (getUniforms) {\n      return getUniforms(opts);\n    }\n\n    return {};\n  }\n\n  updateModuleSettings(opts) {\n    const uniforms = this.getModuleUniforms(opts || {});\n    return this.setUniforms(uniforms);\n  }\n\n  // DRAW CALLS\n\n  clear(opts) {\n    clear(this.program.gl, opts);\n    return this;\n  }\n\n  /* eslint-disable max-statements  */\n  drawGeometry(opts = {}) {\n    // Lazy update program and vertex array\n    this._checkProgram();\n\n    const {\n      moduleSettings = null,\n      framebuffer,\n      uniforms = {},\n      attributes = {},\n      transformFeedback = this.transformFeedback,\n      parameters = {},\n      vertexArray = this.vertexArray,\n      animationProps\n    } = opts;\n\n    addModel(this);\n\n    // Update model with any just provided attributes, settings or uniforms\n    this.setAttributes(attributes);\n    this.updateModuleSettings(moduleSettings);\n    this.setUniforms(uniforms);\n\n    // Animate any function valued uniforms\n    this._refreshAnimationProps(animationProps);\n\n    const logPriority = this._logDrawCallStart(2);\n\n    const drawParams = this.vertexArray.getDrawParams(this.props);\n    if (drawParams.isInstanced && !this.isInstanced) {\n      log.warn('Found instanced attributes on non-instanced model', this.id)();\n    }\n\n    const {isIndexed, indexType, indexOffset} = drawParams;\n    const {isInstanced, instanceCount} = this;\n\n    const noop = () => {};\n    const {onBeforeRender = noop, onAfterRender = noop} = this.props;\n\n    onBeforeRender();\n\n    this._timerQueryStart();\n\n    this.program.setUniforms(this.uniforms);\n\n    const didDraw = this.program.draw(\n      Object.assign({}, opts, {\n        logPriority,\n        uniforms: null, // Already set (may contain \"function values\" not understood by Program)\n        framebuffer,\n        parameters,\n        drawMode: this.getDrawMode(),\n        vertexCount: this.getVertexCount(),\n        vertexArray,\n        transformFeedback,\n        isIndexed,\n        indexType,\n        isInstanced,\n        instanceCount,\n        offset: isIndexed ? indexOffset : 0\n      })\n    );\n\n    this._timerQueryEnd();\n\n    onAfterRender();\n\n    this._logDrawCallEnd(logPriority, vertexArray, framebuffer);\n\n    return didDraw;\n  }\n  /* eslint-enable max-statements  */\n\n  // PRIVATE METHODS\n\n  // eslint-disable-next-line max-statements, complexity\n  _setBaseModelProps(props) {\n    Object.assign(this.props, props);\n\n    if ('uniforms' in props) {\n      this.setUniforms(props.uniforms);\n    }\n\n    if ('pickable' in props) {\n      this.pickable = props.pickable;\n    }\n\n    // if ('onBeforeRender' in props) {}\n    // if ('onAfterRender' in props) {}\n\n    // Experimental props\n    if ('timerQueryEnabled' in props) {\n      this.timerQueryEnabled = props.timerQueryEnabled && Query.isSupported(this.gl, ['timers']);\n      if (props.timerQueryEnabled && !this.timerQueryEnabled) {\n        log.warn('GPU timer not supported')();\n      }\n    }\n\n    if ('_animationProps' in props) {\n      this._setAnimationProps(props._animationProps);\n    }\n\n    if ('_animationLoop' in props) {\n      this.animationLoop = props._animationLoop;\n    }\n  }\n\n  _checkProgram(shaderCache = null) {\n    const needsUpdate =\n      this._programDirty || this.programManager.stateHash !== this._programManagerState;\n\n    if (!needsUpdate) {\n      return;\n    }\n\n    let {program} = this.programProps;\n\n    if (program) {\n      this._managedProgram = false;\n    } else {\n      const {\n        // TODO(Tarek): Are these actually used anywhere?\n        vs = MODULAR_SHADERS.vs,\n        fs = MODULAR_SHADERS.fs,\n        modules,\n        inject,\n        defines,\n        varyings,\n        bufferMode\n      } = this.programProps;\n      program = this.programManager.get({vs, fs, modules, inject, defines, varyings, bufferMode});\n      if (this.program && this._managedProgram) {\n        this.programManager.release(this.program);\n      }\n      this._programManagerState = this.programManager.stateHash;\n      this._managedProgram = true;\n    }\n\n    assert(program instanceof Program, 'Model needs a program');\n\n    this._programDirty = false;\n\n    if (program === this.program) {\n      return;\n    }\n\n    this.program = program;\n\n    if (this.vertexArray) {\n      this.vertexArray.setProps({program: this.program, attributes: this.vertexArray.attributes});\n    } else {\n      this.vertexArray = new VertexArray(this.gl, {program: this.program});\n    }\n\n    // Make sure we have some reasonable default uniforms in place\n    this.setUniforms(\n      Object.assign(\n        {},\n        this.getModuleUniforms() // Get all default uniforms,\n      )\n    );\n  }\n\n  // Refreshes animated uniforms, attempting to get animated props from animationLoop if registered\n  _refreshAnimationProps(animationProps) {\n    // Try to read animationProps\n    animationProps = animationProps || (this.animationLoop && this.animationLoop.animationProps);\n    if (animationProps) {\n      this._setAnimationProps(animationProps);\n    }\n  }\n\n  // Calculate new values for any function uniforms based on supplied animationProps\n  _evaluateAnimateUniforms(animationProps) {\n    if (!this.animated) {\n      return {};\n    }\n    const animatedUniforms = {};\n    for (const uniformName in this.animatedUniforms) {\n      const valueFunction = this.animatedUniforms[uniformName];\n      animatedUniforms[uniformName] = valueFunction(animationProps);\n    }\n    return animatedUniforms;\n  }\n\n  // Extracts a list of function valued uniforms, so we can update them before each draw call\n  // Also removes such uniforms from the returned list\n  _extractAnimatedUniforms(uniforms) {\n    let foundAnimated = false;\n\n    // Keep our animatedUniforms map up-to-date\n    for (const uniformName in uniforms) {\n      const newValue = uniforms[uniformName];\n      if (typeof newValue === 'function') {\n        this.animatedUniforms[uniformName] = newValue;\n        foundAnimated = true;\n      } else {\n        delete this.animatedUniforms[uniformName];\n      }\n    }\n\n    // Update animated flag: `Model` is animated if any uniforms are animated (i.e. functions)\n    this.animated = !isObjectEmpty(this.animatedUniforms);\n\n    if (!foundAnimated) {\n      return uniforms;\n    }\n\n    // If animated uniforms were found, remove them from ordinary uniform list\n    // `Program` class can't (and shouldn't) handle function valued uniforms\n    const staticUniforms = {};\n    for (const uniformName in uniforms) {\n      if (!this.animatedUniforms[uniformName]) {\n        staticUniforms[uniformName] = uniforms[uniformName];\n      }\n    }\n    return staticUniforms;\n  }\n\n  // Timer Queries\n\n  _timerQueryStart() {\n    if (this.timerQueryEnabled === true) {\n      if (!this.timeElapsedQuery) {\n        this.timeElapsedQuery = new Query(this.gl);\n      }\n      if (this.lastQueryReturned) {\n        this.lastQueryReturned = false;\n        this.timeElapsedQuery.beginTimeElapsedQuery();\n      }\n    }\n  }\n\n  _timerQueryEnd() {\n    if (this.timerQueryEnabled === true) {\n      this.timeElapsedQuery.end();\n      // TODO: Skip results if 'gl.getParameter(this.ext.GPU_DISJOINT_EXT)' returns false\n      // should this be incorporated into Query object?\n      if (this.timeElapsedQuery.isResultAvailable()) {\n        this.lastQueryReturned = true;\n        const elapsedTime = this.timeElapsedQuery.getTimerMilliseconds();\n\n        // Update stats (e.g. for seer)\n        this.stats.lastFrameTime = elapsedTime;\n        this.stats.accumulatedFrameTime += elapsedTime;\n        this.stats.profileFrameCount++;\n        this.stats.averageFrameTime =\n          this.stats.accumulatedFrameTime / this.stats.profileFrameCount;\n\n        // Log stats\n        log.log(\n          LOG_DRAW_PRIORITY,\n          `\\\nGPU time ${this.program.id}: ${this.stats.lastFrameTime}ms \\\naverage ${this.stats.averageFrameTime}ms \\\naccumulated: ${this.stats.accumulatedFrameTime}ms \\\ncount: ${this.stats.profileFrameCount}`\n        )();\n      }\n    }\n  }\n\n  _logDrawCallStart(priority) {\n    const logDrawTimeout = priority > 3 ? 0 : LOG_DRAW_TIMEOUT;\n    if (log.priority < priority || Date.now() - this.lastLogTime < logDrawTimeout) {\n      return undefined;\n    }\n\n    this.lastLogTime = Date.now();\n\n    log.group(LOG_DRAW_PRIORITY, `>>> DRAWING MODEL ${this.id}`, {collapsed: log.priority <= 2})();\n\n    return priority;\n  }\n\n  _logDrawCallEnd(priority, vertexArray, uniforms, framebuffer) {\n    // HACK: priority === undefined means logDrawCallStart didn't run\n    if (priority === undefined) {\n      return;\n    }\n\n    const attributeTable = getDebugTableForVertexArray({\n      vertexArray,\n      header: `${this.id} attributes`,\n      attributes: this._attributes\n    });\n\n    const {table: uniformTable, unusedTable, unusedCount} = getDebugTableForUniforms({\n      header: `${this.id} uniforms`,\n      program: this.program,\n      uniforms: Object.assign({}, this.program.uniforms, uniforms)\n    });\n\n    // log missing uniforms\n    const {table: missingTable, count: missingCount} = getDebugTableForUniforms({\n      header: `${this.id} uniforms`,\n      program: this.program,\n      uniforms: Object.assign({}, this.program.uniforms, uniforms),\n      undefinedOnly: true\n    });\n\n    if (missingCount > 0) {\n      log.log('MISSING UNIFORMS', Object.keys(missingTable))();\n      // log.table(priority, missingTable)();\n    }\n    if (unusedCount > 0) {\n      log.log('UNUSED UNIFORMS', Object.keys(unusedTable))();\n      // log.log(priority, 'Unused uniforms ', unusedTable)();\n    }\n\n    const configTable = getDebugTableForProgramConfiguration(this.vertexArray.configuration);\n\n    log.table(priority, attributeTable)();\n\n    log.table(priority, uniformTable)();\n\n    log.table(priority + 1, configTable)();\n\n    logModel(this, uniforms);\n\n    if (framebuffer) {\n      framebuffer.log({priority: LOG_DRAW_PRIORITY, message: `Rendered to ${framebuffer.id}`});\n    }\n\n    log.groupEnd(LOG_DRAW_PRIORITY, `>>> DRAWING MODEL ${this.id}`)();\n  }\n}\n","import GL from '@luma.gl/constants';\nimport {TransformFeedback, Buffer} from '@luma.gl/webgl';\nimport {getBuffersFromGeometry} from './model-utils';\nimport BaseModel from './base-model';\nimport {log, isObjectEmpty, uid, assert} from '../utils';\n\nconst ERR_MODEL_PARAMS = 'Model needs drawMode and vertexCount';\n\nexport default class Model extends BaseModel {\n  constructor(gl, props = {}) {\n    // Deduce a helpful id\n    const {id = uid('model')} = props;\n    super(gl, {...props, id});\n  }\n\n  initialize(props) {\n    super.initialize(props);\n\n    this.drawMode = props.drawMode !== undefined ? props.drawMode : GL.TRIANGLES;\n    this.vertexCount = props.vertexCount || 0;\n\n    // Track buffers created by setGeometry\n    this.geometryBuffers = {};\n\n    // geometry might have set drawMode and vertexCount\n    this.isInstanced = props.isInstanced || props.instanced;\n\n    this._setModelProps(props);\n\n    // TODO - just to unbreak deck.gl 7.0-beta, remove as soon as updated\n    this.geometry = {};\n\n    // assert(program || program instanceof Program);\n    assert(this.drawMode !== undefined && Number.isFinite(this.vertexCount), ERR_MODEL_PARAMS);\n  }\n\n  setProps(props) {\n    super.setProps(props);\n    this._setModelProps(props);\n  }\n\n  delete() {\n    super.delete();\n\n    this._deleteGeometryBuffers();\n  }\n\n  // GETTERS\n\n  getDrawMode() {\n    return this.drawMode;\n  }\n\n  getVertexCount() {\n    return this.vertexCount;\n  }\n\n  getInstanceCount() {\n    return this.instanceCount;\n  }\n\n  getAttributes() {\n    return this.attributes;\n  }\n\n  // SETTERS\n\n  setDrawMode(drawMode) {\n    this.drawMode = drawMode;\n    return this;\n  }\n\n  setVertexCount(vertexCount) {\n    assert(Number.isFinite(vertexCount));\n    this.vertexCount = vertexCount;\n    return this;\n  }\n\n  setInstanceCount(instanceCount) {\n    assert(Number.isFinite(instanceCount));\n    this.instanceCount = instanceCount;\n    return this;\n  }\n\n  setGeometry(geometry) {\n    this.drawMode = geometry.drawMode;\n    this.vertexCount = geometry.getVertexCount();\n\n    this._deleteGeometryBuffers();\n\n    this.geometryBuffers = getBuffersFromGeometry(this.gl, geometry);\n    this.vertexArray.setAttributes(this.geometryBuffers);\n    return this;\n  }\n\n  setAttributes(attributes = {}) {\n    // Avoid setting needsRedraw if no attributes\n    if (isObjectEmpty(attributes)) {\n      return this;\n    }\n\n    const normalizedAttributes = {};\n    for (const name in attributes) {\n      const attribute = attributes[name];\n      // The `getValue` call provides support for deck.gl `Attribute` class\n      // TODO - remove once deck refactoring completes\n      normalizedAttributes[name] = attribute.getValue ? attribute.getValue() : attribute;\n    }\n\n    this.vertexArray.setAttributes(normalizedAttributes);\n    return this;\n  }\n\n  // DRAW CALLS\n\n  draw(options = {}) {\n    return this.drawGeometry(options);\n  }\n\n  // Draw call for transform feedback\n  transform(opts = {}) {\n    const {discard = true, feedbackBuffers, unbindModels = []} = opts;\n\n    let {parameters} = opts;\n\n    if (feedbackBuffers) {\n      this._setFeedbackBuffers(feedbackBuffers);\n    }\n\n    if (discard) {\n      parameters = Object.assign({}, parameters, {[GL.RASTERIZER_DISCARD]: discard});\n    }\n\n    unbindModels.forEach(model => model.vertexArray.unbindBuffers());\n    try {\n      this.draw(Object.assign({}, opts, {parameters}));\n    } finally {\n      unbindModels.forEach(model => model.vertexArray.bindBuffers());\n    }\n\n    return this;\n  }\n\n  // DEPRECATED METHODS\n\n  render(uniforms = {}) {\n    log.warn('Model.render() is deprecated. Use Model.setUniforms() and Model.draw()')();\n    return this.setUniforms(uniforms).draw();\n  }\n\n  // PRIVATE METHODS\n\n  _setModelProps(props) {\n    // params\n    // if ('drawMode' in props) {\n    //   this.drawMode = getDrawMode(props.drawMode);\n    // }\n    // if ('vertexCount' in props) {\n    //   this.vertexCount = props.vertexCount;\n    // }\n    if ('instanceCount' in props) {\n      this.instanceCount = props.instanceCount;\n    }\n    if ('geometry' in props) {\n      this.setGeometry(props.geometry);\n    }\n\n    // webgl settings\n    if ('attributes' in props) {\n      this.setAttributes(props.attributes);\n    }\n    if ('_feedbackBuffers' in props) {\n      this._setFeedbackBuffers(props._feedbackBuffers);\n    }\n  }\n\n  _deleteGeometryBuffers() {\n    for (const name in this.geometryBuffers) {\n      // Buffer is raw value (for indices) or first element of [buffer, accessor] pair\n      const buffer = this.geometryBuffers[name][0] || this.geometryBuffers[name];\n      if (buffer instanceof Buffer) {\n        buffer.delete();\n      }\n    }\n  }\n\n  // Updates (evaluates) all function valued uniforms based on a new set of animationProps\n  // experimental\n  _setAnimationProps(animationProps) {\n    if (this.animated) {\n      assert(animationProps, 'Model.draw(): animated uniforms but no animationProps');\n      const animatedUniforms = this._evaluateAnimateUniforms(animationProps);\n      Object.assign(this.uniforms, animatedUniforms);\n    }\n  }\n\n  // Transform Feedback\n\n  _setFeedbackBuffers(feedbackBuffers = {}) {\n    // Avoid setting needsRedraw if no feedbackBuffers\n    if (isObjectEmpty(feedbackBuffers)) {\n      return this;\n    }\n\n    const {gl} = this.program;\n    this.transformFeedback =\n      this.transformFeedback ||\n      new TransformFeedback(gl, {\n        program: this.program\n      });\n\n    this.transformFeedback.setBuffers(feedbackBuffers);\n    return this;\n  }\n}\n","// Transpiles shader source code to target GLSL version\n// Note: We always run transpiler even if same version e.g. 3.00 => 3.00\n// RFC: https://github.com/uber/luma.gl/blob/7.0-release/dev-docs/RFCs/v6.0/portable-glsl-300-rfc.md\nexport default function transpileShader(source, targetGLSLVersion, isVertex) {\n  switch (targetGLSLVersion) {\n    case 300:\n      return isVertex ? convertVertexShaderTo300(source) : convertFragmentShaderTo300(source);\n    case 100:\n      return isVertex ? convertVertexShaderTo100(source) : convertFragmentShaderTo100(source);\n    default:\n      throw new Error(`unknown GLSL version ${targetGLSLVersion}`);\n  }\n}\n\nfunction convertVertexShaderTo300(source) {\n  return source\n    .replace(/attribute\\s+/g, 'in ')\n    .replace(/varying\\s+/g, 'out ')\n    .replace(/texture2D\\(/g, 'texture(')\n    .replace(/textureCube\\(+/g, 'texture(')\n    .replace(/texture2DLodEXT\\(/g, 'textureLod(')\n    .replace(/textureCubeLodEXT\\(/g, 'textureLod(');\n}\n\nfunction convertFragmentShaderTo300(source) {\n  return source\n    .replace(/varying\\s+/g, 'in ')\n    .replace(/texture2D\\(/g, 'texture(')\n    .replace(/textureCube\\(/g, 'texture(')\n    .replace(/texture2DLodEXT\\(/g, 'textureLod(')\n    .replace(/textureCubeLodEXT\\(/g, 'textureLod(');\n\n  // Deal with fragColor\n  // .replace(/gl_fragColor/g, 'fragColor ');\n}\n\nfunction convertVertexShaderTo100(source) {\n  // /gm - treats each line as a string, so that ^ matches after newlines\n  return source\n    .replace(/^in\\s+/gm, 'attribute ')\n    .replace(/^out\\s+/gm, 'varying ')\n    .replace(/texture\\(/g, 'texture2D(');\n}\n\nfunction convertFragmentShaderTo100(source) {\n  // /gm - treats each line as a string, so that ^ matches after newlines\n  return source.replace(/^in\\s+/gm, 'varying ').replace(/texture\\(/g, 'texture2D(');\n\n  // Deal with fragColor\n  // .replace(/^out\\s+/g, 'varying ')\n}\n","const TYPE_DEFINITIONS = {\n  number: {\n    validate(value, propType) {\n      return (\n        Number.isFinite(value) &&\n        (!('max' in propType) || value <= propType.max) &&\n        (!('min' in propType) || value >= propType.min)\n      );\n    }\n  },\n  array: {\n    validate(value, propType) {\n      return Array.isArray(value) || ArrayBuffer.isView(value);\n    }\n  }\n};\n\nexport function parsePropTypes(propDefs) {\n  const propTypes = {};\n  for (const propName in propDefs) {\n    const propDef = propDefs[propName];\n    const propType = parsePropType(propDef);\n    propTypes[propName] = propType;\n  }\n  return propTypes;\n}\n\n// Parses one property definition entry. Either contains:\n// * a valid prop type object ({type, ...})\n// * or just a default value, in which case type and name inference is used\nfunction parsePropType(propDef) {\n  let type = getTypeOf(propDef);\n  if (type === 'object') {\n    if (!propDef) {\n      return {type: 'object', value: null};\n    }\n    if ('type' in propDef) {\n      return Object.assign({}, propDef, TYPE_DEFINITIONS[propDef.type]);\n    }\n    if (!('value' in propDef)) {\n      // If no type and value this object is likely the value\n      return {type: 'object', value: propDef};\n    }\n    type = getTypeOf(propDef.value);\n    return Object.assign({type}, propDef, TYPE_DEFINITIONS[type]);\n  }\n  return Object.assign({type, value: propDef}, TYPE_DEFINITIONS[type]);\n}\n\n// improved version of javascript typeof that can distinguish arrays and null values\nfunction getTypeOf(value) {\n  if (Array.isArray(value) || ArrayBuffer.isView(value)) {\n    return 'array';\n  }\n  return typeof value;\n}\n","import transpileShader from './transpile-shader';\nimport {assert} from '../utils';\nimport {parsePropTypes} from './filters/prop-types';\n\nconst VERTEX_SHADER = 'vs';\nconst FRAGMENT_SHADER = 'fs';\n\nexport default class ShaderModule {\n  constructor({\n    name,\n    vs,\n    fs,\n    dependencies = [],\n    uniforms,\n    getUniforms,\n    deprecations = [],\n    defines = {},\n    // DEPRECATED\n    vertexShader,\n    fragmentShader\n  }) {\n    assert(typeof name === 'string');\n    this.name = name;\n    this.vs = vs || vertexShader;\n    this.fs = fs || fragmentShader;\n    this.getModuleUniforms = getUniforms;\n    this.dependencies = dependencies;\n    this.deprecations = this._parseDeprecationDefinitions(deprecations);\n    this.defines = defines;\n\n    if (uniforms) {\n      this.uniforms = parsePropTypes(uniforms);\n    }\n  }\n\n  // Extracts the source code chunk for the specified shader type from the named shader module\n  getModuleSource(type, targetGLSLVersion) {\n    let moduleSource;\n    switch (type) {\n      case VERTEX_SHADER:\n        moduleSource = transpileShader(this.vs || '', targetGLSLVersion, true);\n        break;\n      case FRAGMENT_SHADER:\n        moduleSource = transpileShader(this.fs || '', targetGLSLVersion, false);\n        break;\n      default:\n        assert(false);\n    }\n\n    return `\\\n#define MODULE_${this.name.toUpperCase()}\n${moduleSource}\\\n// END MODULE_${this.name}\n\n`;\n  }\n\n  getUniforms(opts, uniforms) {\n    if (this.getModuleUniforms) {\n      return this.getModuleUniforms(opts, uniforms);\n    }\n    // Build uniforms from the uniforms array\n    if (this.uniforms) {\n      return this._defaultGetUniforms(opts);\n    }\n    return {};\n  }\n\n  getDefines() {\n    return this.defines;\n  }\n\n  // Warn about deprecated uniforms or functions\n  checkDeprecations(shaderSource, log) {\n    this.deprecations.forEach(def => {\n      if (def.regex.test(shaderSource)) {\n        if (def.deprecated) {\n          log.deprecated(def.old, def.new)();\n        } else {\n          log.removed(def.old, def.new)();\n        }\n      }\n    });\n  }\n\n  _parseDeprecationDefinitions(deprecations) {\n    deprecations.forEach(def => {\n      switch (def.type) {\n        case 'function':\n          def.regex = new RegExp(`\\\\b${def.old}\\\\(`);\n          break;\n        default:\n          def.regex = new RegExp(`${def.type} ${def.old};`);\n      }\n    });\n\n    return deprecations;\n  }\n\n  _defaultGetUniforms(opts = {}) {\n    const uniforms = {};\n    const propTypes = this.uniforms;\n\n    for (const key in propTypes) {\n      const propDef = propTypes[key];\n      if (key in opts && !propDef.private) {\n        if (propDef.validate) {\n          assert(propDef.validate(opts[key], propDef), `${this.name}: invalid ${key}`);\n        }\n        uniforms[key] = opts[key];\n      } else {\n        uniforms[key] = propDef.value;\n      }\n    }\n\n    return uniforms;\n  }\n}\n\n// This utility mutates the original module\n// Keeping for backward compatibility\n// TODO - remove in v8\nexport function normalizeShaderModule(module) {\n  if (!module.normalized) {\n    module.normalized = true;\n    if (module.uniforms && !module.getUniforms) {\n      const shaderModule = new ShaderModule(module);\n      module.getUniforms = shaderModule.getUniforms.bind(shaderModule);\n    }\n  }\n  return module;\n}\n","import {MODULE_INJECTORS_VS, MODULE_INJECTORS_FS} from '../modules/module-injectors';\nimport {VERTEX_SHADER, FRAGMENT_SHADER} from './constants';\nimport {assert} from '../utils';\n\n// TODO - experimental\nconst MODULE_INJECTORS = {\n  [VERTEX_SHADER]: MODULE_INJECTORS_VS,\n  [FRAGMENT_SHADER]: MODULE_INJECTORS_FS\n};\n\nexport const DECLARATION_INJECT_MARKER = '__LUMA_INJECT_DECLARATIONS__'; // Uniform/attribute declarations\n\nconst REGEX_START_OF_MAIN = /void main\\s*\\([^)]*\\)\\s*\\{\\n?/; // Beginning of main\nconst REGEX_END_OF_MAIN = /}\\n?[^{}]*$/; // End of main, assumes main is last function\nconst fragments = [];\n\n// A minimal shader injection/templating system.\n// RFC: https://github.com/uber/luma.gl/blob/7.0-release/dev-docs/RFCs/v6.0/shader-injection-rfc.md\n/* eslint-disable complexity */\nexport default function injectShader(source, type, inject, injectStandardStubs) {\n  const isVertex = type === VERTEX_SHADER;\n\n  for (const key in inject) {\n    const fragmentData = inject[key];\n    fragmentData.sort((a, b) => a.order - b.order);\n    fragments.length = fragmentData.length;\n    for (let i = 0, len = fragmentData.length; i < len; ++i) {\n      fragments[i] = fragmentData[i].injection;\n    }\n    const fragmentString = `${fragments.join('\\n')}\\n`;\n    switch (key) {\n      // declarations are injected before the main function\n      case 'vs:#decl':\n        if (isVertex) {\n          source = source.replace(DECLARATION_INJECT_MARKER, fragmentString);\n        }\n        break;\n      // main code is injected at the end of main function\n      case 'vs:#main-start':\n        if (isVertex) {\n          source = source.replace(REGEX_START_OF_MAIN, match => match + fragmentString);\n        }\n        break;\n      case 'vs:#main-end':\n        if (isVertex) {\n          source = source.replace(REGEX_END_OF_MAIN, match => fragmentString + match);\n        }\n        break;\n      case 'fs:#decl':\n        if (!isVertex) {\n          source = source.replace(DECLARATION_INJECT_MARKER, fragmentString);\n        }\n        break;\n      case 'fs:#main-start':\n        if (!isVertex) {\n          source = source.replace(REGEX_START_OF_MAIN, match => match + fragmentString);\n        }\n        break;\n      case 'fs:#main-end':\n        if (!isVertex) {\n          source = source.replace(REGEX_END_OF_MAIN, match => fragmentString + match);\n        }\n        break;\n\n      default:\n        // TODO(Tarek): I think this usage should be deprecated.\n\n        // inject code after key, leaving key in place\n        source = source.replace(key, match => match + fragmentString);\n    }\n  }\n\n  // Remove if it hasn't already been replaced\n  source = source.replace(DECLARATION_INJECT_MARKER, '');\n\n  // Finally, if requested, insert an automatic module injector chunk\n  if (injectStandardStubs) {\n    source = source.replace(/\\}\\s*$/, match => match + MODULE_INJECTORS[type]);\n  }\n\n  return source;\n}\n\n/* eslint-enable complexity */\n\n// Takes an array of inject objects and combines them into one\nexport function combineInjects(injects) {\n  const result = {};\n  assert(Array.isArray(injects) && injects.length > 1);\n  injects.forEach(inject => {\n    for (const key in inject) {\n      result[key] = result[key] ? `${result[key]}\\n${inject[key]}` : inject[key];\n    }\n  });\n  return result;\n}\n","export const MODULE_INJECTORS_VS = `\\\n#ifdef MODULE_LOGDEPTH\n  logdepth_adjustPosition(gl_Position);\n#endif\n`;\n\nexport const MODULE_INJECTORS_FS = `\\\n#ifdef MODULE_MATERIAL\n  gl_FragColor = material_filterColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_LIGHTING\n  gl_FragColor = lighting_filterColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_FOG\n  gl_FragColor = fog_filterColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_PICKING\n  gl_FragColor = picking_filterHighlightColor(gl_FragColor);\n  gl_FragColor = picking_filterPickingColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_LOGDEPTH\n  logdepth_setFragDepth();\n#endif\n`;\n","// shadertools exports\n\n// DEFAULT SHADERS\n// A set of base shaders that leverage the shader module system,\n// dynamically enabling features depending on which modules are included\nimport MODULAR_VS from './shaders/modular-vertex.glsl';\nimport MODULAR_FS from './shaders/modular-fragment.glsl';\n\n// DOCUMENTED APIS\nexport {\n  registerShaderModules,\n  setDefaultShaderModules,\n  getDefaultShaderModules\n} from './lib/resolve-modules';\nexport {\n  assembleShaders,\n  createShaderHook,\n  createModuleInjection,\n  resetGlobalShaderHooks\n} from './lib/assemble-shaders';\n\n// HELPERS\nexport {combineInjects} from './lib/inject-shader';\nexport {normalizeShaderModule} from './lib/shader-module';\n\n// UTILS\nexport {\n  getQualifierDetails,\n  getPassthroughFS,\n  typeToChannelSuffix,\n  typeToChannelCount,\n  convertToVec4\n} from './utils/shader-utils';\n\n// SHADER MODULES\nexport * from './modules';\n\nexport const MODULAR_SHADERS = {\n  vs: MODULAR_VS,\n  fs: MODULAR_FS,\n  uniforms: {}\n};\n","export default `\\\n#define SHADER_NAME luma_modular_vertex\n\n// object attributes\nattribute vec3 positions;\nattribute vec3 normals;\nattribute vec4 colors;\nattribute vec2 texCoords;\nattribute vec3 pickingColors;\n\nvoid main(void) {\n\n  // Set up position\n#ifdef MODULE_GEOMETRY\n  geometry_setPosition(positions);\n  geometry_setNormal(normals);\n#endif\n\n#ifdef MODULE_PROJECT\n  project_setPositionAndNormal_Model(positions, normals);\n  gl_Position = project_model_to_clipspace(positions);\n#endif\n\n  // Set up depth\n#ifdef MODULE_LOGDEPTH\n  logdepth_adjustPosition(gl_Position);\n#endif\n\n#ifdef MODULE_DIFFUSE\n  diffuse_setTextureCoordinate(texCoords);\n#endif\n\n  // Set up color calculations\n#ifdef MODULE_MATERIAL\n  material_setDiffuseColor(colors);\n  material_setDiffuseTextureCoordinates(texCoords);\n#endif\n\n#ifdef MODULE_LIGHTING\n  lighting_setPositionAndNormal(positions, normals);\n  lighting_apply_light(positions);\n  lighting_apply_reflection(positions);\n#endif\n\n#ifdef MODULE_PICKING\n  picking_setPickingColor(pickingColors);\n#endif\n\n}\n`;\n","export default `\\\n#define SHADER_NAME luma-modular-fragment\n\nprecision highp float;\n\n// varyings\nvarying vec4 vColor;\n\nvoid main(){\n  gl_FragColor = vec4(1., 0., 1., 1.);\n\n#ifdef MODULE_DIFFUSE\n  gl_FragColor = diffuse_filterColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_MATERIAL\n  gl_FragColor = material_filterColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_LIGHTING\n  gl_FragColor = lighting_filterColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_FOG\n  gl_FragColor = fog_filterColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_PICKING\n  gl_FragColor = picking_filterHighlightColor(gl_FragColor);\n  gl_FragColor = picking_filterPickingColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_LOGDEPTH\n  logdepth_setFragDepth(gl_Position);\n#endif\n}\n`;\n","export const VERTEX_SHADER = 'vs';\nexport const FRAGMENT_SHADER = 'fs';\n","// Recommendation is to ignore message but current test suite checks agains the\n// message so keep it for now.\nexport default function assert(condition, message) {\n  if (!condition) {\n    throw new Error(message || 'shadertools: assertion failed.');\n  }\n}\n","import GL from '@luma.gl/constants';\nimport Resource from './resource';\nimport Buffer from './buffer';\nimport {isWebGL2, assertWebGL2Context} from '../webgl-utils';\nimport {log, isObjectEmpty} from '../utils';\n\n// NOTE: The `bindOnUse` flag is a major workaround:\n// See https://github.com/KhronosGroup/WebGL/issues/2346\n\nexport default class TransformFeedback extends Resource {\n  static isSupported(gl) {\n    return isWebGL2(gl);\n  }\n\n  constructor(gl, props = {}) {\n    assertWebGL2Context(gl);\n    super(gl, props);\n\n    this.initialize(props);\n    this.stubRemovedMethods('TransformFeedback', 'v6.0', ['pause', 'resume']);\n    Object.seal(this);\n  }\n\n  initialize(props = {}) {\n    this.buffers = {};\n    this.unused = {};\n    this.configuration = null;\n    this.bindOnUse = true;\n\n    // Unbind any currently bound buffers\n    if (!isObjectEmpty(this.buffers)) {\n      this.bind(() => this._unbindBuffers());\n    }\n\n    this.setProps(props);\n    return this;\n  }\n\n  setProps(props) {\n    if ('program' in props) {\n      this.configuration = props.program && props.program.configuration;\n    }\n    if ('configuration' in props) {\n      this.configuration = props.configuration;\n    }\n    if ('bindOnUse' in props) {\n      props = props.bindOnUse;\n    }\n    if ('buffers' in props) {\n      this.setBuffers(props.buffers);\n    }\n  }\n\n  setBuffers(buffers = {}) {\n    this.bind(() => {\n      for (const bufferName in buffers) {\n        this.setBuffer(bufferName, buffers[bufferName]);\n      }\n    });\n    return this;\n  }\n\n  setBuffer(locationOrName, bufferOrParams) {\n    const location = this._getVaryingIndex(locationOrName);\n    const {buffer, byteSize, byteOffset} = this._getBufferParams(bufferOrParams);\n\n    if (location < 0) {\n      this.unused[locationOrName] = buffer;\n      log.warn(() => `${this.id} unused varying buffer ${locationOrName}`)();\n      return this;\n    }\n\n    this.buffers[location] = bufferOrParams;\n\n    // Need to avoid chrome bug where buffer that is already bound to a different target\n    // cannot be bound to 'TRANSFORM_FEEDBACK_BUFFER' target.\n    if (!this.bindOnUse) {\n      this._bindBuffer(location, buffer, byteOffset, byteSize);\n    }\n\n    return this;\n  }\n\n  begin(primitiveMode = GL.POINTS) {\n    this.gl.bindTransformFeedback(GL.TRANSFORM_FEEDBACK, this.handle);\n    this._bindBuffers();\n    this.gl.beginTransformFeedback(primitiveMode);\n    return this;\n  }\n\n  end() {\n    this.gl.endTransformFeedback();\n    this._unbindBuffers();\n    this.gl.bindTransformFeedback(GL.TRANSFORM_FEEDBACK, null);\n    return this;\n  }\n\n  // PRIVATE METHODS\n\n  _getBufferParams(bufferOrParams) {\n    let byteOffset;\n    let byteSize;\n    let buffer;\n    if (bufferOrParams instanceof Buffer === false) {\n      buffer = bufferOrParams.buffer;\n      byteSize = bufferOrParams.byteSize;\n      byteOffset = bufferOrParams.byteOffset;\n    } else {\n      buffer = bufferOrParams;\n    }\n    // to use bindBufferRange, either offset or size must be specified, use default value for the other.\n    if (byteOffset !== undefined || byteSize !== undefined) {\n      byteOffset = byteOffset || 0;\n      byteSize = byteSize || buffer.byteLength - byteOffset;\n    }\n    return {buffer, byteOffset, byteSize};\n  }\n\n  _getVaryingInfo(locationOrName) {\n    return this.configuration && this.configuration.getVaryingInfo(locationOrName);\n  }\n\n  _getVaryingIndex(locationOrName) {\n    if (this.configuration) {\n      return this.configuration.getVaryingInfo(locationOrName).location;\n    }\n    const location = Number(locationOrName);\n    return Number.isFinite(location) ? location : -1;\n  }\n\n  // Need to avoid chrome bug where buffer that is already bound to a different target\n  // cannot be bound to 'TRANSFORM_FEEDBACK_BUFFER' target.\n  _bindBuffers() {\n    if (this.bindOnUse) {\n      for (const bufferIndex in this.buffers) {\n        const {buffer, byteSize, byteOffset} = this._getBufferParams(this.buffers[bufferIndex]);\n        this._bindBuffer(bufferIndex, buffer, byteOffset, byteSize);\n      }\n    }\n  }\n\n  _unbindBuffers() {\n    if (this.bindOnUse) {\n      for (const bufferIndex in this.buffers) {\n        this._bindBuffer(bufferIndex, null);\n      }\n    }\n  }\n\n  _bindBuffer(index, buffer, byteOffset = 0, byteSize) {\n    const handle = buffer && buffer.handle;\n    if (!handle || byteSize === undefined) {\n      this.gl.bindBufferBase(GL.TRANSFORM_FEEDBACK_BUFFER, index, handle);\n    } else {\n      this.gl.bindBufferRange(GL.TRANSFORM_FEEDBACK_BUFFER, index, handle, byteOffset, byteSize);\n    }\n    return this;\n  }\n\n  // RESOURCE METHODS\n\n  _createHandle() {\n    return this.gl.createTransformFeedback();\n  }\n\n  _deleteHandle() {\n    this.gl.deleteTransformFeedback(this.handle);\n  }\n\n  _bindHandle(handle) {\n    this.gl.bindTransformFeedback(GL.TRANSFORM_FEEDBACK, this.handle);\n  }\n}\n","import Geometry from '../geometry/geometry';\nimport {uid} from '../utils';\n\nexport default class SphereGeometry extends Geometry {\n  constructor(props = {}) {\n    const {id = uid('sphere-geometry')} = props;\n    const {indices, attributes} = tesselateSphere(props);\n    super({\n      ...props,\n      id,\n      indices,\n      attributes: {...attributes, ...props.attributes}\n    });\n  }\n}\n\n// Primitives inspired by TDL http://code.google.com/p/webglsamples/,\n// copyright 2011 Google Inc. new BSD License\n// (http://www.opensource.org/licenses/bsd-license.php).\n/* eslint-disable max-statements, complexity */\nfunction tesselateSphere(props) {\n  const {nlat = 10, nlong = 10} = props;\n  let {radius = 1} = props;\n\n  const startLat = 0;\n  const endLat = Math.PI;\n  const latRange = endLat - startLat;\n  const startLong = 0;\n  const endLong = 2 * Math.PI;\n  const longRange = endLong - startLong;\n  const numVertices = (nlat + 1) * (nlong + 1);\n\n  if (typeof radius === 'number') {\n    const value = radius;\n    radius = (n1, n2, n3, u, v) => value;\n  }\n\n  const positions = new Float32Array(numVertices * 3);\n  const normals = new Float32Array(numVertices * 3);\n  const texCoords = new Float32Array(numVertices * 2);\n  const indices = new Uint16Array(nlat * nlong * 6);\n\n  // Create positions, normals and texCoords\n  for (let y = 0; y <= nlat; y++) {\n    for (let x = 0; x <= nlong; x++) {\n      const u = x / nlong;\n      const v = y / nlat;\n\n      const index = x + y * (nlong + 1);\n      const i2 = index * 2;\n      const i3 = index * 3;\n\n      const theta = longRange * u;\n      const phi = latRange * v;\n      const sinTheta = Math.sin(theta);\n      const cosTheta = Math.cos(theta);\n      const sinPhi = Math.sin(phi);\n      const cosPhi = Math.cos(phi);\n      const ux = cosTheta * sinPhi;\n      const uy = cosPhi;\n      const uz = sinTheta * sinPhi;\n\n      const r = radius(ux, uy, uz, u, v);\n\n      positions[i3 + 0] = r * ux;\n      positions[i3 + 1] = r * uy;\n      positions[i3 + 2] = r * uz;\n\n      normals[i3 + 0] = ux;\n      normals[i3 + 1] = uy;\n      normals[i3 + 2] = uz;\n\n      texCoords[i2 + 0] = u;\n      texCoords[i2 + 1] = 1 - v;\n    }\n  }\n\n  // Create indices\n  const numVertsAround = nlat + 1;\n  for (let x = 0; x < nlat; x++) {\n    for (let y = 0; y < nlong; y++) {\n      const index = (x * nlong + y) * 6;\n\n      indices[index + 0] = y * numVertsAround + x;\n      indices[index + 1] = y * numVertsAround + x + 1;\n      indices[index + 2] = (y + 1) * numVertsAround + x;\n\n      indices[index + 3] = (y + 1) * numVertsAround + x;\n      indices[index + 4] = y * numVertsAround + x + 1;\n      indices[index + 5] = (y + 1) * numVertsAround + x + 1;\n    }\n  }\n\n  return {\n    indices: {size: 1, value: indices},\n    attributes: {\n      POSITION: {size: 3, value: positions},\n      NORMAL: {size: 3, value: normals},\n      TEXCOORD_0: {size: 2, value: texCoords}\n    }\n  };\n}\n"],"sourceRoot":""}