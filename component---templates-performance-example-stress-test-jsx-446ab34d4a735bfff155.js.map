{"version":3,"sources":["webpack:///../examples/performance/stress-test/app.js","webpack:///./templates/performance/example-stress-test.jsx","webpack:///../examples/utils/index.js","webpack:///../modules/engine/src/geometry/geometry.js","webpack:///../modules/engine/src/geometries/cube-geometry.js","webpack:///../modules/shadertools/src/modules/project/project.js","webpack:///../modules/shadertools/src/modules/dirlight/dirlight.js"],"names":["CUBES_PER_DRAWCALL","SCENE_DIM","OPAQUE_DRAWCALLS","Math","NUM_DRAWCALLS","TRANSPARENT_DRAWCALLS","random","getRandom","rotationAngle","CUBE_VERTEX","CUBE_FRAGMENT","InstancedCube","count","props","offsetBuffer","Object","geometry","vs","fs","modules","isInstanced","instanceCount","uniforms","attributes","offset","buffer","size","divisor","Model","AppAnimationLoop","getInfo","onInitialize","gl","projectionMatrix","framebuffer","viewMatrix","eye","texture","data","mipmaps","parameters","opaqueCubes","Array","transparentCubes","offsets","Float32Array","i","createDrawcall","statsWidget","this","container","document","title","css","position","top","left","fontSize","formatters","onRender","aspect","tick","stats","reset","camX","camZ","fov","radians","near","far","center","up","clear","color","depth","withParameters","depthTest","depthMask","depthFunc","GL","cull","blend","uProjection","uView","blendFunc","onFinalize","c","AnimationLoop","x","y","z","uTexture","alpha","window","animationLoop","width","height","innerHeight","Example","render","pageContext","exampleConfig","React","Component","MiniAnimationLoop","start","stop","delete","_setDisplay","_getCanvas","canvas","dpr","s","n","DRAW_MODE","POINTS","LINES","LINE_LOOP","LINE_STRIP","TRIANGLES","TRIANGLE_STRIP","TRIANGLE_FAN","Geometry","id","uid","drawMode","indices","vertexCount","userData","_setAttributes","_calculateVertexCount","getVertexCount","getAttributes","_print","ArrayBuffer","value","attribute","assert","attributeName","isIndexed","Number","CUBE_INDICES","Uint16Array","CUBE_POSITIONS","CUBE_NORMALS","CUBE_TEX_COORDS","ATTRIBUTES","POSITION","NORMAL","TEXCOORD_0","CubeGeometry","IDENTITY_MATRIX","DEFAULT_MODULE_OPTIONS","modelMatrix","cameraPositionWorld","name","getUniforms","opts","prevUniforms","common","lightDirection","dependencies","project"],"mappings":"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","file":"component---templates-performance-example-stress-test-jsx-446ab34d4a735bfff155.js","sourcesContent":["/* global document, window */\nimport GL from '@luma.gl/constants';\nimport {AnimationLoop, Model, CubeGeometry} from '@luma.gl/engine';\nimport {clear, Texture2D, Buffer} from '@luma.gl/webgl';\nimport {dirlight} from '@luma.gl/shadertools';\nimport {withParameters} from '@luma.gl/gltools';\nimport {Matrix4, radians} from 'math.gl';\nimport {StatsWidget} from '@probe.gl/stats-widget';\nimport {getRandom} from '../../utils';\n\nconst INFO_HTML = `\n<p>\n  <div id=\"info-stats\"></div>\n<p>\n`;\n\nconst NUM_DRAWCALLS = 5000;\nconst CUBES_PER_DRAWCALL = 200;\nconst SCENE_DIM = 500;\nconst OPAQUE_DRAWCALLS = Math.floor(NUM_DRAWCALLS / 2);\nconst TRANSPARENT_DRAWCALLS = NUM_DRAWCALLS - OPAQUE_DRAWCALLS;\nconst NEAR = 200;\nconst FAR = 2000.0;\n\nconst random = getRandom();\nlet rotationAngle = 0;\n\nconst CUBE_VERTEX = `\\\n#version 300 es\n#define SHADER_NAME scene.vs\n\nin vec3 positions;\nin vec3 normals;\nin vec2 texCoords;\nin vec3 offset;\n\nuniform mat4 uView;\nuniform mat4 uProjection;\nout vec2 vUV;\n\nvoid main(void) {\n  gl_Position = uProjection * uView * vec4(positions * 4.0 + offset, 1.0);\n  project_setNormal(normals);\n  vUV = texCoords;\n}\n`;\nconst CUBE_FRAGMENT = `\\\n#version 300 es\nprecision highp float;\n#define SHADER_NAME scene.fs\n\nin vec2 vUV;\nuniform sampler2D uTexture;\nuniform float alpha;\n\nout vec4 fragColor;\nvoid main(void) {\n  fragColor.rgb = texture(uTexture, vUV).rgb;\n  fragColor.a = alpha;\n  fragColor = dirlight_filterColor(fragColor);\n  fragColor.rgb *= fragColor.a;\n}\n`;\n\nclass InstancedCube extends Model {\n  constructor(gl, props) {\n    const count = props.count;\n    const offsetBuffer = new Buffer(gl, props.offsets);\n\n    super(\n      gl,\n      Object.assign({geometry: new CubeGeometry()}, props, {\n        vs: CUBE_VERTEX,\n        fs: CUBE_FRAGMENT,\n        modules: [dirlight],\n        isInstanced: 1,\n        instanceCount: count,\n        uniforms: props.uniforms,\n        attributes: {\n          offset: {\n            buffer: offsetBuffer,\n            size: 3,\n            divisor: 1\n          }\n        }\n      })\n    );\n\n    this.count = count;\n  }\n}\n\nexport default class AppAnimationLoop extends AnimationLoop {\n  static getInfo() {\n    return INFO_HTML;\n  }\n\n  constructor(props = {}) {\n    super(props);\n    this.isDemoSupported = true;\n  }\n\n  onInitialize({gl, framebuffer}) {\n    const projectionMatrix = new Matrix4();\n    const viewMatrix = new Matrix4().lookAt({eye: [0, 0, 8]});\n\n    const texture = new Texture2D(gl, {\n      data: 'vis-logo.png',\n      mipmaps: true,\n      parameters: {\n        [gl.TEXTURE_MAG_FILTER]: gl.LINEAR,\n        [gl.TEXTURE_MIN_FILTER]: gl.LINEAR_MIPMAP_NEAREST\n      }\n    });\n\n    const opaqueCubes = new Array(OPAQUE_DRAWCALLS);\n    const transparentCubes = new Array(TRANSPARENT_DRAWCALLS);\n    const offsets = new Float32Array(CUBES_PER_DRAWCALL * 3);\n\n    for (let i = 0; i < OPAQUE_DRAWCALLS; ++i) {\n      opaqueCubes[i] = createDrawcall(gl, offsets, texture, 1.0);\n    }\n\n    for (let i = 0; i < TRANSPARENT_DRAWCALLS; ++i) {\n      transparentCubes[i] = createDrawcall(gl, offsets, texture, 0.5);\n    }\n\n    const statsWidget = new StatsWidget(this.stats, {\n      container: document.getElementById('info-stats'),\n      title: `Drawing ${CUBES_PER_DRAWCALL *\n        OPAQUE_DRAWCALLS} opaque cubes and ${CUBES_PER_DRAWCALL *\n        TRANSPARENT_DRAWCALLS} transparent cubes in ${NUM_DRAWCALLS} draw calls`,\n      css: {\n        position: 'absolute',\n        top: '10px',\n        left: '10px',\n        fontSize: '14px'\n      },\n      formatters: {\n        'CPU Time': 'averageTime',\n        'GPU Time': 'averageTime',\n        'Frame Rate': 'fps'\n      }\n    });\n\n    rotationAngle = 0;\n\n    return {\n      projectionMatrix,\n      viewMatrix,\n      opaqueCubes,\n      transparentCubes,\n      statsWidget\n    };\n  }\n\n  onRender(props) {\n    rotationAngle += 0.01;\n\n    const {\n      gl,\n      aspect,\n      projectionMatrix,\n      viewMatrix,\n      opaqueCubes,\n      transparentCubes,\n      statsWidget,\n      tick\n    } = props;\n\n    statsWidget.update();\n\n    if (tick % 600 === 0) {\n      this.stats.reset();\n    }\n\n    const camX = Math.cos(rotationAngle);\n    const camZ = Math.sin(rotationAngle);\n    const camRadius = 800;\n\n    projectionMatrix.perspective({fov: radians(60), aspect, near: NEAR, far: FAR});\n    viewMatrix.lookAt({\n      eye: [camX * camRadius, 400, camZ * camRadius],\n      center: [0, 0, 0],\n      up: [0, 1, 0]\n    });\n\n    clear(gl, {color: [0, 0, 0, 1], depth: true});\n\n    withParameters(\n      gl,\n      {depthTest: true, depthMask: true, depthFunc: GL.LEQUAL, cull: true, blend: false},\n      () => {\n        for (let i = 0; i < OPAQUE_DRAWCALLS; ++i) {\n          opaqueCubes[i].draw({\n            uniforms: {\n              uProjection: projectionMatrix,\n              uView: viewMatrix\n            }\n          });\n        }\n      }\n    );\n\n    withParameters(\n      gl,\n      {\n        depthTest: true,\n        depthMask: false,\n        depthFunc: GL.LEQUAL,\n        cull: true,\n        blend: true,\n        blendFunc: [GL.ONE, GL.ONE_MINUS_SRC_ALPHA]\n      },\n      () => {\n        for (let i = 0; i < TRANSPARENT_DRAWCALLS; ++i) {\n          transparentCubes[i].draw({\n            uniforms: {\n              uProjection: projectionMatrix,\n              uView: viewMatrix\n            }\n          });\n        }\n      }\n    );\n  }\n\n  onFinalize({opaqueCubes, transparentCubes}) {\n    opaqueCubes.forEach(c => c.delete());\n    transparentCubes.forEach(c => c.delete());\n  }\n}\n\nfunction createDrawcall(gl, offsets, texture, alpha) {\n  for (let i = 0; i < CUBES_PER_DRAWCALL; ++i) {\n    const x = (random() - 0.5) * SCENE_DIM;\n    const y = (random() - 0.5) * SCENE_DIM;\n    const z = (random() - 0.5) * SCENE_DIM;\n\n    offsets.set([x, y, z], i * 3);\n  }\n  return new InstancedCube(gl, {\n    count: CUBES_PER_DRAWCALL,\n    offsets,\n    uniforms: {\n      uTexture: texture,\n      alpha\n    }\n  });\n}\n\nif (typeof window !== 'undefined' && !window.website) {\n  document.body.style.overflow = 'hidden';\n  document.body.style.margin = '0';\n  const animationLoop = new AppAnimationLoop();\n  animationLoop.start({width: window.innerWidth, height: window.innerHeight});\n}\n","import React from 'react';\nimport AnimationLoopExamplePage from '../../src/components/animation-loop-example-page';\nimport AnimationLoop from '../../../examples/performance/stress-test/app';\n\nexport default class Example extends React.Component {\n  render() {\n    const { pageContext } = this.props;\n    const exampleConfig = (pageContext && pageContext.exampleConfig) || {};\n    return (\n      <AnimationLoopExamplePage AnimationLoop={AnimationLoop} exampleConfig={exampleConfig} />\n    );\n  }\n}\n","/* global window, document */\n\n// Light class implementing the AnimationLoop interface\n// use by examples w/o creating a gl context\nexport class MiniAnimationLoop {\n  static getInfo() {\n    return '';\n  }\n\n  start() {}\n\n  stop() {}\n\n  delete() {}\n\n  _setDisplay() {}\n\n  _getCanvas(props = {}) {\n    let canvas;\n    if (props.canvas) {\n      canvas = document.getElementById(props.canvas);\n      const dpr = window.devicePixelRatio || 1;\n      canvas.height = canvas.clientHeight * dpr;\n      canvas.width = canvas.clientWidth * dpr;\n    } else {\n      canvas = document.createElement('canvas');\n      canvas.width = 800;\n      canvas.height = 600;\n      document.body.appendChild(canvas);\n    }\n\n    return canvas;\n  }\n}\n\n// Create a deterministic pseudorandom number generator\nexport function getRandom() {\n  let s = 1;\n  let c = 1;\n  return () => {\n    s = Math.sin(c * 17.23);\n    c = Math.cos(s * 27.92);\n    return fract(Math.abs(s * c) * 1432.71);\n  };\n}\n\nfunction fract(n) {\n  return n - Math.floor(n);\n}\n","import {uid, assert} from '@luma.gl/webgl';\n\n// Rendering primitives - specify how to extract primitives from vertices.\n// NOTE: These are numerically identical to the corresponding WebGL/OpenGL constants\nexport const DRAW_MODE = {\n  POINTS: 0x0000, // draw single points.\n  LINES: 0x0001, // draw lines. Each vertex connects to the one after it.\n  LINE_LOOP: 0x0002, // draw lines. Each set of two vertices is treated as a separate line segment.\n  LINE_STRIP: 0x0003, // draw a connected group of line segments from the first vertex to the last\n  TRIANGLES: 0x0004, // draw triangles. Each set of three vertices creates a separate triangle.\n  TRIANGLE_STRIP: 0x0005, // draw a connected group of triangles.\n  TRIANGLE_FAN: 0x0006 // draw a connected group of triangles.\n  // Each vertex connects to the previous and the first vertex in the fan.\n};\n\nexport default class Geometry {\n  static get DRAW_MODE() {\n    return DRAW_MODE;\n  }\n\n  constructor(props = {}) {\n    const {\n      id = uid('geometry'),\n      drawMode = DRAW_MODE.TRIANGLES,\n      attributes = {},\n      indices = null,\n      vertexCount = null\n    } = props;\n\n    this.id = id;\n    this.drawMode = drawMode | 0;\n    this.attributes = {};\n    this.userData = {};\n\n    this._setAttributes(attributes, indices);\n\n    this.vertexCount = vertexCount || this._calculateVertexCount(this.attributes, this.indices);\n\n    // stubRemovedMethods(this, [\n    //   'setNeedsRedraw', 'needsRedraw', 'setAttributes'\n    // ], 'Immutable');\n\n    // stubRemovedMethods(this, [\n    //   'hasAttribute', 'getAttribute', 'getArray'\n    // ], 'Use geometry.attributes and geometry.indices');\n\n    // deprecateMethods(this, ['getAttributes'])\n  }\n\n  get mode() {\n    return this.drawMode;\n  }\n\n  getVertexCount() {\n    return this.vertexCount;\n  }\n\n  // Return an object with all attributes plus indices added as a field.\n  getAttributes() {\n    return this.indices ? {indices: this.indices, ...this.attributes} : this.attributes;\n  }\n\n  // PRIVATE\n\n  _print(attributeName) {\n    return `Geometry ${this.id} attribute ${attributeName}`;\n  }\n\n  // Attribute\n  // value: typed array\n  // type: indices, vertices, uvs\n  // size: elements per vertex\n  // target: WebGL buffer type (string or constant)\n  _setAttributes(attributes, indices) {\n    if (indices) {\n      this.indices = ArrayBuffer.isView(indices) ? {value: indices, size: 1} : indices;\n    }\n\n    for (const attributeName in attributes) {\n      let attribute = attributes[attributeName];\n\n      // Wrap \"unwrapped\" arrays and try to autodetect their type\n      attribute = ArrayBuffer.isView(attribute) ? {value: attribute} : attribute;\n\n      assert(\n        ArrayBuffer.isView(attribute.value),\n        `${this._print(attributeName)}: must be typed array or object with value as typed array`\n      );\n\n      if ((attributeName === 'POSITION' || attributeName === 'positions') && !attribute.size) {\n        attribute.size = 3;\n      }\n\n      // Move indices to separate field\n      if (attributeName === 'indices') {\n        assert(!this.indices);\n        this.indices = attribute;\n      } else {\n        this.attributes[attributeName] = attribute;\n      }\n    }\n\n    if (this.indices && this.indices.isIndexed !== undefined) {\n      this.indices = Object.assign({}, this.indices);\n      delete this.indices.isIndexed;\n    }\n\n    return this;\n  }\n\n  _calculateVertexCount(attributes, indices) {\n    if (indices) {\n      return indices.value.length;\n    }\n    let vertexCount = Infinity;\n    for (const attributeName in attributes) {\n      const attribute = attributes[attributeName];\n      const {value, size, constant} = attribute;\n      if (!constant && value && size >= 1) {\n        vertexCount = Math.min(vertexCount, value.length / size);\n      }\n    }\n\n    assert(Number.isFinite(vertexCount));\n    return vertexCount;\n  }\n}\n","import Geometry from '../geometry/geometry';\nimport {uid} from '@luma.gl/webgl';\n\n// prettier-ignore\nconst CUBE_INDICES = new Uint16Array([\n  0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13,\n  14, 12, 14, 15, 16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23\n]);\n\n// prettier-ignore\nconst CUBE_POSITIONS = new Float32Array([\n  -1,  -1,  1, 1,  -1,  1,  1,  1,  1,  -1,  1,  1,\n  -1,  -1,  -1,  -1,  1,  -1,  1,  1,  -1,  1,  -1,  -1,\n  -1,  1,  -1,  -1,  1,  1,  1,  1,  1,  1,  1,  -1,\n  -1,  -1,  -1,  1,  -1,  -1,  1,  -1,  1,  -1,  -1,  1,\n  1,  -1,  -1,  1,  1,  -1,  1,  1,  1,  1,  -1,  1,\n  -1,  -1,  -1,  -1,  -1,  1,  -1,  1,  1,  -1,  1,  -1\n]);\n\n// TODO - could be Uint8\n// prettier-ignore\nconst CUBE_NORMALS = new Float32Array([\n  // Front face\n  0,  0,  1,  0,  0,  1,  0,  0,  1,  0,  0,  1,\n  // Back face\n  0,  0,  -1,  0,  0,  -1,  0,  0,  -1,  0,  0,  -1,\n  // Top face\n  0,  1,  0,  0,  1,  0,  0,  1,  0,  0,  1,  0,\n  // Bottom face\n  0,  -1,  0,  0,  -1,  0,  0,  -1,  0,  0,  -1,  0,\n  // Right face\n  1,  0,  0,  1,  0,  0,  1,  0,  0,  1,  0,  0,\n  // Left face\n  -1,  0,  0,  -1,  0,  0,  -1,  0,  0,  -1,  0,  0\n]);\n\n// prettier-ignore\nconst CUBE_TEX_COORDS = new Float32Array([\n  // Front face\n  0,  0,  1,  0,  1,  1,  0,  1,\n  // Back face\n  1,  0,  1,  1,  0,  1,  0,  0,\n  // Top face\n  0,  1,  0,  0,  1,  0,  1,  1,\n  // Bottom face\n  1,  1,  0,  1,  0,  0,  1,  0,\n  // Right face\n  1,  0,  1,  1,  0,  1,  0,  0,\n  // Left face\n  0,  0,  1,  0,  1,  1,  0,  1\n]);\n\nconst ATTRIBUTES = {\n  POSITION: {size: 3, value: new Float32Array(CUBE_POSITIONS)},\n  NORMAL: {size: 3, value: new Float32Array(CUBE_NORMALS)},\n  TEXCOORD_0: {size: 2, value: new Float32Array(CUBE_TEX_COORDS)}\n};\n\nexport default class CubeGeometry extends Geometry {\n  constructor(props = {}) {\n    const {id = uid('cube-geometry')} = props;\n    super({\n      ...props,\n      id,\n      indices: {size: 1, value: new Uint16Array(CUBE_INDICES)},\n      attributes: {...ATTRIBUTES, ...props.attributes}\n    });\n  }\n}\n","import {Matrix4} from 'math.gl';\n\nconst IDENTITY_MATRIX = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\n\nconst DEFAULT_MODULE_OPTIONS = {\n  modelMatrix: IDENTITY_MATRIX,\n  viewMatrix: IDENTITY_MATRIX,\n  projectionMatrix: IDENTITY_MATRIX,\n  cameraPositionWorld: [0, 0, 0]\n};\n\nfunction getUniforms(opts = DEFAULT_MODULE_OPTIONS, prevUniforms = {}) {\n  // const viewProjectionInverse = viewProjection.invert();\n  // viewInverseMatrix: view.invert(),\n  // viewProjectionInverseMatrix: viewProjectionInverse\n\n  const uniforms = {};\n  if (opts.modelMatrix !== undefined) {\n    uniforms.modelMatrix = opts.modelMatrix;\n  }\n  if (opts.viewMatrix !== undefined) {\n    uniforms.viewMatrix = opts.viewMatrix;\n  }\n  if (opts.projectionMatrix !== undefined) {\n    uniforms.projectionMatrix = opts.projectionMatrix;\n  }\n  if (opts.cameraPositionWorld !== undefined) {\n    uniforms.cameraPositionWorld = opts.cameraPositionWorld;\n  }\n\n  // COMPOSITE UNIFORMS\n  if (opts.projectionMatrix !== undefined || opts.viewMatrix !== undefined) {\n    uniforms.viewProjectionMatrix = new Matrix4(opts.projectionMatrix).multiplyRight(\n      opts.viewMatrix\n    );\n  }\n\n  return uniforms;\n}\n\nconst common = `\\\nvarying vec4 project_vPositionWorld;\nvarying vec3 project_vNormalWorld;\n\nvec4 project_getPosition_World() {\n  return project_vPositionWorld;\n}\n\nvec3 project_getNormal_World() {\n  return project_vNormalWorld;\n}\n`;\n\nconst vs = `\\\n${common}\n\n// Unprefixed uniforms\nuniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 viewProjectionMatrix;\nuniform vec3 cameraPositionWorld;\n\nstruct World {\n  vec3 position;\n  vec3 normal;\n};\n\nWorld world;\n\nvoid project_setPosition(vec4 position) {\n  project_vPositionWorld = position;\n}\n\nvoid project_setNormal(vec3 normal) {\n  project_vNormalWorld = normal;\n}\n\nvoid project_setPositionAndNormal_World(vec3 position, vec3 normal) {\n  world.position = position;\n  world.normal = normal;\n}\n\nvoid project_setPositionAndNormal_Model(vec3 position, vec3 normal) {\n  world.position = (modelMatrix * vec4(position, 1.)).xyz;\n  world.normal = mat3(modelMatrix) * normal;\n}\n\nvec4 project_model_to_clipspace(vec4 position) {\n  return viewProjectionMatrix * modelMatrix * position;\n}\n\nvec4 project_model_to_clipspace(vec3 position) {\n  return viewProjectionMatrix * modelMatrix * vec4(position, 1.);\n}\n\nvec4 project_world_to_clipspace(vec3 position) {\n  return viewProjectionMatrix * vec4(position, 1.);\n}\n\nvec4 project_view_to_clipspace(vec3 position) {\n  return projectionMatrix * vec4(position, 1.);\n}\n\nvec4 project_to_clipspace(vec3 position) {\n  return viewProjectionMatrix * vec4(position, 1.);\n}\n`;\n\nconst fs = `\n${common}\\\n`;\n\nexport default {\n  name: 'project',\n  getUniforms,\n  vs,\n  fs\n};\n","// Cheap lighting - single directional light, single dot product, one uniform\n\nimport project from '../project/project';\n\n/* eslint-disable camelcase */\nconst DEFAULT_LIGHT_DIRECTION = new Float32Array([1, 1, 2]);\n\nconst DEFAULT_MODULE_OPTIONS = {\n  lightDirection: DEFAULT_LIGHT_DIRECTION\n};\n\nfunction getUniforms(opts = DEFAULT_MODULE_OPTIONS) {\n  const uniforms = {};\n  if (opts.lightDirection) {\n    uniforms.dirlight_uLightDirection = opts.lightDirection;\n  }\n  return uniforms;\n}\n\n// TODO - reuse normal from geometry module\nconst vs = null;\n\nconst fs = `\\\nuniform vec3 dirlight_uLightDirection;\n\n/*\n * Returns color attenuated by angle from light source\n */\nvec4 dirlight_filterColor(vec4 color) {\n  vec3 normal = project_getNormal_World();\n  float d = abs(dot(normalize(normal), normalize(dirlight_uLightDirection)));\n  return vec4(color.rgb * d, color.a);\n}\n`;\n\nexport default {\n  name: 'dirlight',\n  vs,\n  fs,\n  getUniforms,\n  dependencies: [project]\n};\n"],"sourceRoot":""}