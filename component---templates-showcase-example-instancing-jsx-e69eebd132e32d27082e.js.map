{"version":3,"sources":["webpack:///../examples/showcase/instancing/app.js","webpack:///./templates/showcase/example-instancing.jsx","webpack:///../examples/utils/index.js","webpack:///../modules/engine/src/geometry/geometry.js","webpack:///../modules/engine/src/geometries/cube-geometry.js","webpack:///../modules/shadertools/src/modules/project/project.js","webpack:///../modules/shadertools/src/modules/dirlight/dirlight.js","webpack:///../modules/engine/src/animation/timeline.js","webpack:///../modules/shadertools/src/modules/picking/picking.js"],"names":["random","getRandom","SIDE","InstancedCube","offsets","i","x","j","y","Float32Array","pickingColors","Uint8ClampedArray","colors","offsetsBuffer","colorsBuffer","pickingColorsBuffer","programManager","ProgramManager","hook","injection","order","Number","POSITIVE_INFINITY","Object","vs","fs","modules","dirlight","isInstanced","instanceCount","geometry","attributes","instanceSizes","instanceOffsets","divisor","instanceColors","instancePickingColors","Model","AppAnimationLoop","createFramebuffer","debug","getInfo","onInitialize","gl","_animationLoop","setParameters","clearColor","clearDepth","depthTest","depthFunc","LEQUAL","this","attachTimeline","timeline","play","timelineChannels","timeChannel","addChannel","rate","eyeXChannel","eyeYChannel","eyeZChannel","cube","onRender","animationProps","aspect","tick","framebuffer","_mousePosition","devicePixels","cssToDevicePixels","color","depth","model","picking_uActive","readPixelsToArray","sourceX","sourceY","sourceWidth","sourceHeight","sourceFormat","sourceType","UNSIGNED_BYTE","pickingSelectedColor","pickInstance","Math","setUniforms","uTime","getTime","uProjection","fov","radians","near","far","uView","center","eye","uModel","draw","onFinalize","delete","AnimationLoop","window","animationLoop","Example","render","pageContext","exampleConfig","React","Component","MiniAnimationLoop","start","stop","_setDisplay","_getCanvas","props","canvas","document","dpr","s","c","n","DRAW_MODE","POINTS","LINES","LINE_LOOP","LINE_STRIP","TRIANGLES","TRIANGLE_STRIP","TRIANGLE_FAN","Geometry","id","uid","drawMode","indices","vertexCount","userData","_setAttributes","_calculateVertexCount","getVertexCount","getAttributes","_print","ArrayBuffer","value","size","attribute","assert","attributeName","isIndexed","CUBE_INDICES","Uint16Array","CUBE_POSITIONS","CUBE_NORMALS","CUBE_TEX_COORDS","ATTRIBUTES","POSITION","NORMAL","TEXCOORD_0","CubeGeometry","IDENTITY_MATRIX","DEFAULT_MODULE_OPTIONS","modelMatrix","viewMatrix","projectionMatrix","cameraPositionWorld","name","getUniforms","opts","prevUniforms","uniforms","common","lightDirection","dependencies","project","channelHandles","animationHandles","Timeline","time","channels","animations","playing","lastEngineTime","delay","duration","handle","channel","repeat","_setChannelTime","set","removeChannel","animationHandle","animation","detachAnimation","isFinished","get","setTime","animationData","pause","reset","attachAnimation","channelHandle","update","engineTime","offsetTime","pickingHighlightColor","Uint8Array","pickingActive","pickingAttribute","selectedColor","Boolean"],"mappings":"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","file":"component---templates-showcase-example-instancing-jsx-e69eebd132e32d27082e.js","sourcesContent":["import {AnimationLoop, CubeGeometry, Timeline, Model, ProgramManager} from '@luma.gl/engine';\nimport {readPixelsToArray, Buffer} from '@luma.gl/webgl';\nimport {setParameters} from '@luma.gl/gltools';\nimport {picking, dirlight} from '@luma.gl/shadertools';\nimport {cssToDevicePixels} from '@luma.gl/webgl';\nimport {Matrix4, radians} from 'math.gl';\nimport {getRandom} from '../../utils';\n\nconst INFO_HTML = `\n<p>\nCube drawn with <b>instanced rendering</b>.\n<p>\nA luma.gl <code>Cube</code>, rendering 65,536 instances in a\nsingle GPU draw call using instanced vertex attributes.\n`;\n\nconst random = getRandom();\n\nconst SIDE = 256;\n\n// Make a cube with 65K instances and attributes to control offset and color of each instance\nclass InstancedCube extends Model {\n  constructor(gl, props) {\n    let offsets = [];\n    for (let i = 0; i < SIDE; i++) {\n      const x = ((-SIDE + 1) * 3) / 2 + i * 3;\n      for (let j = 0; j < SIDE; j++) {\n        const y = ((-SIDE + 1) * 3) / 2 + j * 3;\n        offsets.push(x, y);\n      }\n    }\n    offsets = new Float32Array(offsets);\n\n    const pickingColors = new Uint8ClampedArray(SIDE * SIDE * 2);\n    for (let i = 0; i < SIDE; i++) {\n      for (let j = 0; j < SIDE; j++) {\n        pickingColors[(i * SIDE + j) * 2 + 0] = i;\n        pickingColors[(i * SIDE + j) * 2 + 1] = j;\n      }\n    }\n\n    const colors = new Float32Array(SIDE * SIDE * 3).map((n, i) => random() * 0.75 + 0.25);\n\n    const vs = `\\\nattribute float instanceSizes;\nattribute vec3 positions;\nattribute vec3 normals;\nattribute vec2 instanceOffsets;\nattribute vec3 instanceColors;\nattribute vec2 instancePickingColors;\n\nuniform mat4 uModel;\nuniform mat4 uView;\nuniform mat4 uProjection;\nuniform float uTime;\n\nvarying vec3 color;\n\nvoid main(void) {\n  vec3 normal = vec3(uModel * vec4(normals, 1.0));\n\n  // Set up data for modules\n  color = instanceColors;\n  project_setNormal(normal);\n  vec4 pickColor = vec4(0., instancePickingColors, 1.0);\n  MY_SHADER_HOOK_pickColor(pickColor);\n\n  // Vertex position (z coordinate undulates with time), and model rotates around center\n  float delta = length(instanceOffsets);\n  vec4 offset = vec4(instanceOffsets, sin((uTime + delta) * 0.1) * 16.0, 0);\n  gl_Position = uProjection * uView * (uModel * vec4(positions * instanceSizes, 1.0) + offset);\n}\n`;\n    const fs = `\\\nprecision highp float;\n\nvarying vec3 color;\n\nvoid main(void) {\n  gl_FragColor = vec4(color, 1.);\n  MY_SHADER_HOOK_fragmentColor(gl_FragColor);\n}\n`;\n\n    const offsetsBuffer = new Buffer(gl, offsets);\n    const colorsBuffer = new Buffer(gl, colors);\n    const pickingColorsBuffer = new Buffer(gl, pickingColors);\n\n    const programManager = ProgramManager.getDefaultProgramManager(gl);\n\n    programManager.addShaderHook('vs:MY_SHADER_HOOK_pickColor(inout vec4 color)');\n\n    programManager.addShaderHook('fs:MY_SHADER_HOOK_fragmentColor(inout vec4 color)');\n\n    programManager.addModuleInjection('picking', {\n      hook: 'vs:MY_SHADER_HOOK_pickColor',\n      injection: 'picking_setPickingColor(color.rgb);'\n    });\n\n    programManager.addModuleInjection('dirlight', {\n      hook: 'fs:MY_SHADER_HOOK_fragmentColor',\n      injection: 'color = dirlight_filterColor(color);'\n    });\n\n    programManager.addModuleInjection('picking', {\n      hook: 'fs:MY_SHADER_HOOK_fragmentColor',\n      injection: 'color = picking_filterColor(color);',\n      order: Number.POSITIVE_INFINITY\n    });\n\n    super(\n      gl,\n      Object.assign({}, props, {\n        vs,\n        fs,\n        modules: [dirlight, picking],\n        isInstanced: 1,\n        instanceCount: SIDE * SIDE,\n        geometry: new CubeGeometry(),\n        attributes: {\n          instanceSizes: new Float32Array([1]), // Constant attribute\n          instanceOffsets: [offsetsBuffer, {divisor: 1}],\n          instanceColors: [colorsBuffer, {divisor: 1}],\n          instancePickingColors: [pickingColorsBuffer, {divisor: 1}]\n        }\n      })\n    );\n  }\n}\n\nexport default class AppAnimationLoop extends AnimationLoop {\n  constructor() {\n    super({createFramebuffer: true, debug: true});\n  }\n\n  static getInfo() {\n    return INFO_HTML;\n  }\n\n  onInitialize({gl, _animationLoop}) {\n    setParameters(gl, {\n      clearColor: [0, 0, 0, 1],\n      clearDepth: 1,\n      depthTest: true,\n      depthFunc: gl.LEQUAL\n    });\n\n    this.attachTimeline(new Timeline());\n    this.timeline.play();\n\n    const timelineChannels = {\n      timeChannel: this.timeline.addChannel({\n        rate: 0.01\n      }),\n\n      eyeXChannel: this.timeline.addChannel({\n        rate: 0.0003\n      }),\n\n      eyeYChannel: this.timeline.addChannel({\n        rate: 0.0004\n      }),\n\n      eyeZChannel: this.timeline.addChannel({\n        rate: 0.0002\n      })\n    };\n\n    this.cube = new InstancedCube(gl);\n\n    return {timelineChannels};\n  }\n\n  onRender(animationProps) {\n    const {gl, aspect, tick, timelineChannels} = animationProps;\n    const {framebuffer, _mousePosition} = animationProps;\n    const {timeChannel, eyeXChannel, eyeYChannel, eyeZChannel} = timelineChannels;\n\n    if (_mousePosition) {\n      // use the center pixel location in device pixel range\n      const devicePixels = cssToDevicePixels(gl, _mousePosition);\n      const deviceX = devicePixels.x + Math.floor(devicePixels.width / 2);\n      const deviceY = devicePixels.y + Math.floor(devicePixels.height / 2);\n\n      pickInstance(gl, deviceX, deviceY, this.cube, framebuffer);\n    }\n\n    // Draw the cubes\n    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n    this.cube.setUniforms({\n      uTime: this.timeline.getTime(timeChannel),\n      // Basic projection matrix\n      uProjection: new Matrix4().perspective({fov: radians(60), aspect, near: 1, far: 2048.0}),\n      // Move the eye around the plane\n      uView: new Matrix4().lookAt({\n        center: [0, 0, 0],\n        eye: [\n          (Math.cos(this.timeline.getTime(eyeXChannel)) * SIDE) / 2,\n          (Math.sin(this.timeline.getTime(eyeYChannel)) * SIDE) / 2,\n          ((Math.sin(this.timeline.getTime(eyeZChannel)) + 1) * SIDE) / 4 + 32\n        ]\n      }),\n      // Rotate all the individual cubes\n      uModel: new Matrix4().rotateX(tick * 0.01).rotateY(tick * 0.013)\n    });\n    this.cube.draw();\n  }\n\n  onFinalize({gl}) {\n    this.cube.delete();\n  }\n}\n\nfunction pickInstance(gl, pickX, pickY, model, framebuffer) {\n  framebuffer.clear({color: true, depth: true});\n  // Render picking colors\n  /* eslint-disable camelcase */\n  model.setUniforms({picking_uActive: 1});\n  model.draw({framebuffer});\n  model.setUniforms({picking_uActive: 0});\n\n  const color = readPixelsToArray(framebuffer, {\n    sourceX: pickX,\n    sourceY: pickY,\n    sourceWidth: 1,\n    sourceHeight: 1,\n    sourceFormat: gl.RGBA,\n    sourceType: gl.UNSIGNED_BYTE\n  });\n\n  if (color[0] + color[1] + color[2] > 0) {\n    model.updateModuleSettings({\n      pickingSelectedColor: color\n    });\n  } else {\n    model.updateModuleSettings({\n      pickingSelectedColor: null\n    });\n  }\n}\n\n/* global window */\nif (typeof window !== 'undefined' && !window.website) {\n  const animationLoop = new AppAnimationLoop();\n  animationLoop.start();\n}\n","import React from 'react';\nimport AnimationLoopExamplePage from '../../src/components/animation-loop-example-page';\nimport AnimationLoop from '../../../examples/showcase/instancing/app';\n\nexport default class Example extends React.Component {\n  render() {\n    const { pageContext } = this.props;\n    const exampleConfig = (pageContext && pageContext.exampleConfig) || {};\n    return (\n      <AnimationLoopExamplePage AnimationLoop={AnimationLoop} exampleConfig={exampleConfig} />\n    );\n  }\n}\n","/* global window, document */\n\n// Light class implementing the AnimationLoop interface\n// use by examples w/o creating a gl context\nexport class MiniAnimationLoop {\n  static getInfo() {\n    return '';\n  }\n\n  start() {}\n\n  stop() {}\n\n  delete() {}\n\n  _setDisplay() {}\n\n  _getCanvas(props = {}) {\n    let canvas;\n    if (props.canvas) {\n      canvas = document.getElementById(props.canvas);\n      const dpr = window.devicePixelRatio || 1;\n      canvas.height = canvas.clientHeight * dpr;\n      canvas.width = canvas.clientWidth * dpr;\n    } else {\n      canvas = document.createElement('canvas');\n      canvas.width = 800;\n      canvas.height = 600;\n      document.body.appendChild(canvas);\n    }\n\n    return canvas;\n  }\n}\n\n// Create a deterministic pseudorandom number generator\nexport function getRandom() {\n  let s = 1;\n  let c = 1;\n  return () => {\n    s = Math.sin(c * 17.23);\n    c = Math.cos(s * 27.92);\n    return fract(Math.abs(s * c) * 1432.71);\n  };\n}\n\nfunction fract(n) {\n  return n - Math.floor(n);\n}\n","import {uid, assert} from '@luma.gl/webgl';\n\n// Rendering primitives - specify how to extract primitives from vertices.\n// NOTE: These are numerically identical to the corresponding WebGL/OpenGL constants\nexport const DRAW_MODE = {\n  POINTS: 0x0000, // draw single points.\n  LINES: 0x0001, // draw lines. Each vertex connects to the one after it.\n  LINE_LOOP: 0x0002, // draw lines. Each set of two vertices is treated as a separate line segment.\n  LINE_STRIP: 0x0003, // draw a connected group of line segments from the first vertex to the last\n  TRIANGLES: 0x0004, // draw triangles. Each set of three vertices creates a separate triangle.\n  TRIANGLE_STRIP: 0x0005, // draw a connected group of triangles.\n  TRIANGLE_FAN: 0x0006 // draw a connected group of triangles.\n  // Each vertex connects to the previous and the first vertex in the fan.\n};\n\nexport default class Geometry {\n  static get DRAW_MODE() {\n    return DRAW_MODE;\n  }\n\n  constructor(props = {}) {\n    const {\n      id = uid('geometry'),\n      drawMode = DRAW_MODE.TRIANGLES,\n      attributes = {},\n      indices = null,\n      vertexCount = null\n    } = props;\n\n    this.id = id;\n    this.drawMode = drawMode | 0;\n    this.attributes = {};\n    this.userData = {};\n\n    this._setAttributes(attributes, indices);\n\n    this.vertexCount = vertexCount || this._calculateVertexCount(this.attributes, this.indices);\n\n    // stubRemovedMethods(this, [\n    //   'setNeedsRedraw', 'needsRedraw', 'setAttributes'\n    // ], 'Immutable');\n\n    // stubRemovedMethods(this, [\n    //   'hasAttribute', 'getAttribute', 'getArray'\n    // ], 'Use geometry.attributes and geometry.indices');\n\n    // deprecateMethods(this, ['getAttributes'])\n  }\n\n  get mode() {\n    return this.drawMode;\n  }\n\n  getVertexCount() {\n    return this.vertexCount;\n  }\n\n  // Return an object with all attributes plus indices added as a field.\n  getAttributes() {\n    return this.indices ? {indices: this.indices, ...this.attributes} : this.attributes;\n  }\n\n  // PRIVATE\n\n  _print(attributeName) {\n    return `Geometry ${this.id} attribute ${attributeName}`;\n  }\n\n  // Attribute\n  // value: typed array\n  // type: indices, vertices, uvs\n  // size: elements per vertex\n  // target: WebGL buffer type (string or constant)\n  _setAttributes(attributes, indices) {\n    if (indices) {\n      this.indices = ArrayBuffer.isView(indices) ? {value: indices, size: 1} : indices;\n    }\n\n    for (const attributeName in attributes) {\n      let attribute = attributes[attributeName];\n\n      // Wrap \"unwrapped\" arrays and try to autodetect their type\n      attribute = ArrayBuffer.isView(attribute) ? {value: attribute} : attribute;\n\n      assert(\n        ArrayBuffer.isView(attribute.value),\n        `${this._print(attributeName)}: must be typed array or object with value as typed array`\n      );\n\n      if ((attributeName === 'POSITION' || attributeName === 'positions') && !attribute.size) {\n        attribute.size = 3;\n      }\n\n      // Move indices to separate field\n      if (attributeName === 'indices') {\n        assert(!this.indices);\n        this.indices = attribute;\n      } else {\n        this.attributes[attributeName] = attribute;\n      }\n    }\n\n    if (this.indices && this.indices.isIndexed !== undefined) {\n      this.indices = Object.assign({}, this.indices);\n      delete this.indices.isIndexed;\n    }\n\n    return this;\n  }\n\n  _calculateVertexCount(attributes, indices) {\n    if (indices) {\n      return indices.value.length;\n    }\n    let vertexCount = Infinity;\n    for (const attributeName in attributes) {\n      const attribute = attributes[attributeName];\n      const {value, size, constant} = attribute;\n      if (!constant && value && size >= 1) {\n        vertexCount = Math.min(vertexCount, value.length / size);\n      }\n    }\n\n    assert(Number.isFinite(vertexCount));\n    return vertexCount;\n  }\n}\n","import Geometry from '../geometry/geometry';\nimport {uid} from '@luma.gl/webgl';\n\n// prettier-ignore\nconst CUBE_INDICES = new Uint16Array([\n  0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13,\n  14, 12, 14, 15, 16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23\n]);\n\n// prettier-ignore\nconst CUBE_POSITIONS = new Float32Array([\n  -1,  -1,  1, 1,  -1,  1,  1,  1,  1,  -1,  1,  1,\n  -1,  -1,  -1,  -1,  1,  -1,  1,  1,  -1,  1,  -1,  -1,\n  -1,  1,  -1,  -1,  1,  1,  1,  1,  1,  1,  1,  -1,\n  -1,  -1,  -1,  1,  -1,  -1,  1,  -1,  1,  -1,  -1,  1,\n  1,  -1,  -1,  1,  1,  -1,  1,  1,  1,  1,  -1,  1,\n  -1,  -1,  -1,  -1,  -1,  1,  -1,  1,  1,  -1,  1,  -1\n]);\n\n// TODO - could be Uint8\n// prettier-ignore\nconst CUBE_NORMALS = new Float32Array([\n  // Front face\n  0,  0,  1,  0,  0,  1,  0,  0,  1,  0,  0,  1,\n  // Back face\n  0,  0,  -1,  0,  0,  -1,  0,  0,  -1,  0,  0,  -1,\n  // Top face\n  0,  1,  0,  0,  1,  0,  0,  1,  0,  0,  1,  0,\n  // Bottom face\n  0,  -1,  0,  0,  -1,  0,  0,  -1,  0,  0,  -1,  0,\n  // Right face\n  1,  0,  0,  1,  0,  0,  1,  0,  0,  1,  0,  0,\n  // Left face\n  -1,  0,  0,  -1,  0,  0,  -1,  0,  0,  -1,  0,  0\n]);\n\n// prettier-ignore\nconst CUBE_TEX_COORDS = new Float32Array([\n  // Front face\n  0,  0,  1,  0,  1,  1,  0,  1,\n  // Back face\n  1,  0,  1,  1,  0,  1,  0,  0,\n  // Top face\n  0,  1,  0,  0,  1,  0,  1,  1,\n  // Bottom face\n  1,  1,  0,  1,  0,  0,  1,  0,\n  // Right face\n  1,  0,  1,  1,  0,  1,  0,  0,\n  // Left face\n  0,  0,  1,  0,  1,  1,  0,  1\n]);\n\nconst ATTRIBUTES = {\n  POSITION: {size: 3, value: new Float32Array(CUBE_POSITIONS)},\n  NORMAL: {size: 3, value: new Float32Array(CUBE_NORMALS)},\n  TEXCOORD_0: {size: 2, value: new Float32Array(CUBE_TEX_COORDS)}\n};\n\nexport default class CubeGeometry extends Geometry {\n  constructor(props = {}) {\n    const {id = uid('cube-geometry')} = props;\n    super({\n      ...props,\n      id,\n      indices: {size: 1, value: new Uint16Array(CUBE_INDICES)},\n      attributes: {...ATTRIBUTES, ...props.attributes}\n    });\n  }\n}\n","import {Matrix4} from 'math.gl';\n\nconst IDENTITY_MATRIX = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\n\nconst DEFAULT_MODULE_OPTIONS = {\n  modelMatrix: IDENTITY_MATRIX,\n  viewMatrix: IDENTITY_MATRIX,\n  projectionMatrix: IDENTITY_MATRIX,\n  cameraPositionWorld: [0, 0, 0]\n};\n\nfunction getUniforms(opts = DEFAULT_MODULE_OPTIONS, prevUniforms = {}) {\n  // const viewProjectionInverse = viewProjection.invert();\n  // viewInverseMatrix: view.invert(),\n  // viewProjectionInverseMatrix: viewProjectionInverse\n\n  const uniforms = {};\n  if (opts.modelMatrix !== undefined) {\n    uniforms.modelMatrix = opts.modelMatrix;\n  }\n  if (opts.viewMatrix !== undefined) {\n    uniforms.viewMatrix = opts.viewMatrix;\n  }\n  if (opts.projectionMatrix !== undefined) {\n    uniforms.projectionMatrix = opts.projectionMatrix;\n  }\n  if (opts.cameraPositionWorld !== undefined) {\n    uniforms.cameraPositionWorld = opts.cameraPositionWorld;\n  }\n\n  // COMPOSITE UNIFORMS\n  if (opts.projectionMatrix !== undefined || opts.viewMatrix !== undefined) {\n    uniforms.viewProjectionMatrix = new Matrix4(opts.projectionMatrix).multiplyRight(\n      opts.viewMatrix\n    );\n  }\n\n  return uniforms;\n}\n\nconst common = `\\\nvarying vec4 project_vPositionWorld;\nvarying vec3 project_vNormalWorld;\n\nvec4 project_getPosition_World() {\n  return project_vPositionWorld;\n}\n\nvec3 project_getNormal_World() {\n  return project_vNormalWorld;\n}\n`;\n\nconst vs = `\\\n${common}\n\n// Unprefixed uniforms\nuniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 viewProjectionMatrix;\nuniform vec3 cameraPositionWorld;\n\nstruct World {\n  vec3 position;\n  vec3 normal;\n};\n\nWorld world;\n\nvoid project_setPosition(vec4 position) {\n  project_vPositionWorld = position;\n}\n\nvoid project_setNormal(vec3 normal) {\n  project_vNormalWorld = normal;\n}\n\nvoid project_setPositionAndNormal_World(vec3 position, vec3 normal) {\n  world.position = position;\n  world.normal = normal;\n}\n\nvoid project_setPositionAndNormal_Model(vec3 position, vec3 normal) {\n  world.position = (modelMatrix * vec4(position, 1.)).xyz;\n  world.normal = mat3(modelMatrix) * normal;\n}\n\nvec4 project_model_to_clipspace(vec4 position) {\n  return viewProjectionMatrix * modelMatrix * position;\n}\n\nvec4 project_model_to_clipspace(vec3 position) {\n  return viewProjectionMatrix * modelMatrix * vec4(position, 1.);\n}\n\nvec4 project_world_to_clipspace(vec3 position) {\n  return viewProjectionMatrix * vec4(position, 1.);\n}\n\nvec4 project_view_to_clipspace(vec3 position) {\n  return projectionMatrix * vec4(position, 1.);\n}\n\nvec4 project_to_clipspace(vec3 position) {\n  return viewProjectionMatrix * vec4(position, 1.);\n}\n`;\n\nconst fs = `\n${common}\\\n`;\n\nexport default {\n  name: 'project',\n  getUniforms,\n  vs,\n  fs\n};\n","// Cheap lighting - single directional light, single dot product, one uniform\n\nimport project from '../project/project';\n\n/* eslint-disable camelcase */\nconst DEFAULT_LIGHT_DIRECTION = new Float32Array([1, 1, 2]);\n\nconst DEFAULT_MODULE_OPTIONS = {\n  lightDirection: DEFAULT_LIGHT_DIRECTION\n};\n\nfunction getUniforms(opts = DEFAULT_MODULE_OPTIONS) {\n  const uniforms = {};\n  if (opts.lightDirection) {\n    uniforms.dirlight_uLightDirection = opts.lightDirection;\n  }\n  return uniforms;\n}\n\n// TODO - reuse normal from geometry module\nconst vs = null;\n\nconst fs = `\\\nuniform vec3 dirlight_uLightDirection;\n\n/*\n * Returns color attenuated by angle from light source\n */\nvec4 dirlight_filterColor(vec4 color) {\n  vec3 normal = project_getNormal_World();\n  float d = abs(dot(normalize(normal), normalize(dirlight_uLightDirection)));\n  return vec4(color.rgb * d, color.a);\n}\n`;\n\nexport default {\n  name: 'dirlight',\n  vs,\n  fs,\n  getUniforms,\n  dependencies: [project]\n};\n","let channelHandles = 1;\nlet animationHandles = 1;\n\nexport class Timeline {\n  constructor() {\n    this.time = 0;\n    this.channels = new Map();\n    this.animations = new Map();\n    this.playing = false;\n    this.lastEngineTime = -1;\n  }\n\n  addChannel(props) {\n    const {delay = 0, duration = Number.POSITIVE_INFINITY, rate = 1, repeat = 1} = props;\n\n    const handle = channelHandles++;\n    const channel = {\n      time: 0,\n      delay,\n      duration,\n      rate,\n      repeat\n    };\n    this._setChannelTime(channel, this.time);\n    this.channels.set(handle, channel);\n\n    return handle;\n  }\n\n  removeChannel(handle) {\n    this.channels.delete(handle);\n\n    for (const [animationHandle, animation] of this.animations) {\n      if (animation.channel === handle) {\n        this.detachAnimation(animationHandle);\n      }\n    }\n  }\n\n  isFinished(handle) {\n    const channel = this.channels.get(handle);\n    if (channel === undefined) {\n      return false;\n    }\n\n    return this.time >= channel.delay + channel.duration * channel.repeat;\n  }\n\n  getTime(handle) {\n    if (handle === undefined) {\n      return this.time;\n    }\n\n    const channel = this.channels.get(handle);\n\n    if (channel === undefined) {\n      return -1;\n    }\n\n    return channel.time;\n  }\n\n  setTime(time) {\n    this.time = Math.max(0, time);\n\n    const channels = this.channels.values();\n    for (const channel of channels) {\n      this._setChannelTime(channel, this.time);\n    }\n\n    const animations = this.animations.values();\n    for (const animationData of animations) {\n      const {animation, channel} = animationData;\n      animation.setTime(this.getTime(channel));\n    }\n  }\n\n  play() {\n    this.playing = true;\n  }\n\n  pause() {\n    this.playing = false;\n    this.lastEngineTime = -1;\n  }\n\n  reset() {\n    this.setTime(0);\n  }\n\n  attachAnimation(animation, channelHandle) {\n    const animationHandle = animationHandles++;\n\n    this.animations.set(animationHandle, {\n      animation,\n      channel: channelHandle\n    });\n\n    animation.setTime(this.getTime(channelHandle));\n\n    return animationHandle;\n  }\n\n  detachAnimation(handle) {\n    this.animations.delete(handle);\n  }\n\n  update(engineTime) {\n    if (this.playing) {\n      if (this.lastEngineTime === -1) {\n        this.lastEngineTime = engineTime;\n      }\n      this.setTime(this.time + (engineTime - this.lastEngineTime));\n      this.lastEngineTime = engineTime;\n    }\n  }\n\n  _setChannelTime(channel, time) {\n    const offsetTime = time - channel.delay;\n    const totalDuration = channel.duration * channel.repeat;\n    // Note(Tarek): Don't loop on final repeat.\n    if (offsetTime >= totalDuration) {\n      channel.time = channel.duration * channel.rate;\n    } else {\n      channel.time = Math.max(0, offsetTime) % channel.duration;\n      channel.time *= channel.rate;\n    }\n  }\n}\n","const DEFAULT_HIGHLIGHT_COLOR = new Uint8Array([0, 255, 255, 255]);\n\nconst DEFAULT_MODULE_OPTIONS = {\n  pickingSelectedColor: null, //  Set to a picking color to visually highlight that item\n  pickingHighlightColor: DEFAULT_HIGHLIGHT_COLOR, // Color of visual highlight of \"selected\" item\n  pickingActive: false, // Set to true when rendering to off-screen \"picking\" buffer\n  pickingAttribute: false // Set to true when picking an attribute value instead of object index\n};\n\n/* eslint-disable camelcase */\nfunction getUniforms(opts = DEFAULT_MODULE_OPTIONS) {\n  const uniforms = {};\n  if (opts.pickingSelectedColor !== undefined) {\n    if (!opts.pickingSelectedColor) {\n      uniforms.picking_uSelectedColorValid = 0;\n    } else {\n      const selectedColor = opts.pickingSelectedColor.slice(0, 3);\n      uniforms.picking_uSelectedColorValid = 1;\n      uniforms.picking_uSelectedColor = selectedColor;\n    }\n  }\n  if (opts.pickingHighlightColor) {\n    uniforms.picking_uHighlightColor = opts.pickingHighlightColor.map(x => x / 255);\n  }\n  if (opts.pickingActive !== undefined) {\n    uniforms.picking_uActive = Boolean(opts.pickingActive);\n    uniforms.picking_uAttribute = Boolean(opts.pickingAttribute);\n  }\n  return uniforms;\n}\n\nconst vs = `\\\nuniform bool picking_uActive;\nuniform bool picking_uAttribute;\nuniform vec3 picking_uSelectedColor;\nuniform bool picking_uSelectedColorValid;\n\nout vec4 picking_vRGBcolor_Avalid;\n\nconst float COLOR_SCALE = 1. / 255.;\n\nbool picking_isColorValid(vec3 color) {\n  return dot(color, vec3(1.0)) > 0.001;\n}\n\nbool isVertexPicked(vec3 vertexColor) {\n  return\n    picking_uSelectedColorValid &&\n    !picking_isColorValid(abs(vertexColor - picking_uSelectedColor));\n}\n\nvoid picking_setPickingColor(vec3 pickingColor) {\n  if (picking_uActive) {\n    // Use alpha as the validity flag. If pickingColor is [0, 0, 0] fragment is non-pickable\n    picking_vRGBcolor_Avalid.a = float(picking_isColorValid(pickingColor));\n\n    if (!picking_uAttribute) {\n      // Stores the picking color so that the fragment shader can render it during picking\n      picking_vRGBcolor_Avalid.rgb = pickingColor * COLOR_SCALE;\n    }\n  } else {\n    // Do the comparison with selected item color in vertex shader as it should mean fewer compares\n    picking_vRGBcolor_Avalid.a = float(isVertexPicked(pickingColor));\n  }\n}\n\nvoid picking_setPickingAttribute(float value) {\n  if (picking_uAttribute) {\n    picking_vRGBcolor_Avalid.r = value;\n  }\n}\nvoid picking_setPickingAttribute(vec2 value) {\n  if (picking_uAttribute) {\n    picking_vRGBcolor_Avalid.rg = value;\n  }\n}\nvoid picking_setPickingAttribute(vec3 value) {\n  if (picking_uAttribute) {\n    picking_vRGBcolor_Avalid.rgb = value;\n  }\n}\n`;\n\nconst fs = `\\\nuniform bool picking_uActive;\nuniform vec3 picking_uSelectedColor;\nuniform vec4 picking_uHighlightColor;\n\nin vec4 picking_vRGBcolor_Avalid;\n\n/*\n * Returns highlight color if this item is selected.\n */\nvec4 picking_filterHighlightColor(vec4 color) {\n  if (picking_uActive) {\n    return color;\n  }\n  bool selected = bool(picking_vRGBcolor_Avalid.a);\n\n  if (selected) {\n    float highLightAlpha = picking_uHighlightColor.a;\n    float blendedAlpha = highLightAlpha + color.a * (1.0 - highLightAlpha);\n    float highLightRatio = highLightAlpha / blendedAlpha;\n\n    vec3 blendedRGB = mix(color.rgb, picking_uHighlightColor.rgb, highLightRatio);\n    return vec4(blendedRGB, blendedAlpha);\n  } else {\n    return color;\n  }\n}\n\n/*\n * Returns picking color if picking enabled else unmodified argument.\n */\nvec4 picking_filterPickingColor(vec4 color) {\n  if (picking_uActive) {\n    if (picking_vRGBcolor_Avalid.a == 0.0) {\n      discard;\n    }\n    return picking_vRGBcolor_Avalid;\n  }\n  return color;\n}\n\n/*\n * Returns picking color if picking is enabled if not\n * highlight color if this item is selected, otherwise unmodified argument.\n */\nvec4 picking_filterColor(vec4 color) {\n  vec4 highightColor = picking_filterHighlightColor(color);\n  return picking_filterPickingColor(highightColor);\n}\n\n`;\n\nexport default {\n  name: 'picking',\n  vs,\n  fs,\n  getUniforms\n};\n"],"sourceRoot":""}