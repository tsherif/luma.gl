{"version":3,"sources":["webpack:///../modules/shadertools/src/utils/shader-utils.js","webpack:///../modules/engine/src/transform/buffer-transform.js","webpack:///../modules/webgl/src/glsl-utils/get-shader-version.js","webpack:///../modules/shadertools/src/modules/transform/transform.js","webpack:///../modules/engine/src/transform/transform-shader-utils.js","webpack:///../modules/engine/src/transform/texture-transform.js","webpack:///../modules/engine/src/transform/transform.js","webpack:///../examples/showcase/transform/app.js","webpack:///./templates/showcase/example-transform.jsx","webpack:///../examples/utils/index.js","webpack:///../modules/shadertools/src/modules/picking/picking.js"],"names":["FS100","FS_GLES","FS300","getQualifierDetails","line","qualifiers","Array","words","qualifier","type","definition","name","getPassthroughFS","version","input","inputType","output","outputValue","variable","assert","convertToVec4","typeToChannelSuffix","typeToChannelCount","BufferTransform","props","this","gl","currentIndex","feedbackMap","varyings","bindings","resources","_initialize","Object","setupResources","binding","_setupTransformFeedback","updateModelProps","getDrawOptions","opts","sourceBuffers","transformFeedback","attributes","swap","update","_setupBuffers","getBuffer","feedbackBuffers","bufferOrParams","varyingName","getData","buffer","delete","length","isWebGL2","_getFeedbackBuffers","feedbackName","sourceName","bufferOrRef","sourceBuffer","byteLength","usage","accessor","_createNewBuffer","bufferName","_updateBindings","program","model","buffers","_updateBinding","_swapBuffers","nextIndex","dstName","_getNextIndex","getShaderVersion","source","v","parseInt","Number","vs","fs","SAMPLER_UNIFORM_PREFIX","SIZE_UNIFORM_PREFIX","VS_POS_VARIABLE","updateForTextures","sourceTextureMap","targetTextureVarying","targetTexture","sourceCount","targetTextureType","samplerTextureMap","updatedVs","finalInject","vsLines","updateVsLines","updated","attributeData","getAttributeDefinition","textureMap","updatedLine","textureName","samplerName","sizeName","uniformDeclerations","getSamplerDeclerations","channels","sampleInstruction","inject","processAttributeDefinition","combineInjects","qualaiferDetails","getVaryingType","SRC_TEX_PARAMETER_OVERRIDES","GL","TextureTransform","_swapTexture","updatedModelProps","_processVertexShader","sourceTextures","framebuffer","uniforms","parameters","discard","hasSourceTextures","sizeUniforms","width","height","getSizeUniforms","_setupTextures","getTargetTexture","packed","pixels","readPixelsToArray","ArrayType","channelCount","packedPixels","packCount","i","j","getFramebuffer","ownTexture","elementIDBuffer","_targetTextureVarying","hasTargetTexture","_createTargetTexture","textureOrReference","refTexture","_targetRefTexName","_sourceTextures","_targetTexture","_updateElementIDBuffer","elementCount","elementIds","Float32Array","array","setData","data","size","_swapTextures","attachments","resizeAttachments","id","_setSourceTextureParameters","index","_createNewTexture","texture","cloneTextureFrom","pixelStore","combinedInject","modules","Transform","bufferTransform","textureTransform","isSupported","run","clearRenderTarget","updatedOpts","_updateDrawOptions","color","transform","swapped","resourceTransform","setVertexCount","_buildResourceTransforms","_updateModelProps","drawMode","vertexCount","updatedProps","isObjectEmpty","canCreateBufferTransform","canCreateTextureTransform","RED","Uint8Array","ALT_TEXT","random","getRandom","log","pickPosition","mousemove","e","mouseleave","AppAnimationLoop","getInfo","onInitialize","canvas","isDemoSupported","trianglePositions","instanceOffsets","NUM_INSTANCES","instanceRotations","instanceColors","pickingColors","Uint8ClampedArray","Math","positionBuffer","colorBuffer","offsetBuffer","rotationBuffer","pickingColorBuffer","renderModel","isInstanced","instanceCount","a_position","a_color","divisor","a_offset","a_rotation","instancePickingColors","picking","pickingFramebuffer","onRender","time","useDevicePixels","u_time","depth","blend","blendFunc","devicePixels","cssToDevicePixels","deviceX","deviceY","picking_uActive","sourceX","sourceY","sourceWidth","sourceHeight","sourceFormat","sourceType","UNSIGNED_BYTE","pickingSelectedColor","pickingHighlightColor","pickInstance","onFinalize","getAltText","AnimationLoop","window","animationLoop","Example","render","exampleConfig","pageContext","React","Component","MiniAnimationLoop","start","stop","_setDisplay","_getCanvas","document","dpr","s","c","n","DEFAULT_MODULE_OPTIONS","pickingActive","pickingAttribute","getUniforms","selectedColor","x","Boolean"],"mappings":"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","file":"component---templates-showcase-example-transform-jsx-d2e224b53c2714cf4d84.js","sourcesContent":["import {assert} from '../utils';\nconst FS100 = `void main() {gl_FragColor = vec4(0);}`;\nconst FS_GLES = `\\\nout vec4 transform_output;\nvoid main() {\n  transform_output = vec4(0);\n}`;\nconst FS300 = `#version 300 es\\n${FS_GLES}`;\n\n// Prase given glsl line and return qualifier details or null\nexport function getQualifierDetails(line, qualifiers) {\n  qualifiers = Array.isArray(qualifiers) ? qualifiers : [qualifiers];\n  const words = line.replace(/^\\s+/, '').split(/\\s+/);\n  // TODO add support for precession qualifiers (highp, mediump and lowp)\n  const [qualifier, type, definition] = words;\n  if (!qualifiers.includes(qualifier) || !type || !definition) {\n    return null;\n  }\n  const name = definition.split(';')[0];\n  return {qualifier, type, name};\n}\n\n// Given the shader version, input and output variable names,\n// builds and return a pass through fragment shader.\nexport function getPassthroughFS({version = 100, input, inputType, output} = {}) {\n  if (!input) {\n    if (version === 300) {\n      // Fast-path for WebGL 2.0\n      return FS300;\n    } else if (version > 300) {\n      // Use the supplied version for OpenGL/ES 3.2+\n      return `#version ${version}\\n${FS_GLES}`;\n    }\n    // Fast-path for WebGL 1.0\n    return FS100;\n  }\n  const outputValue = convertToVec4(input, inputType);\n  if (version >= 300) {\n    // If version is 300, assume WebGL 2.0\n    return `\\\n#version ${version} ${version === 300 ? 'es' : ''}\nin ${inputType} ${input};\nout vec4 ${output};\nvoid main() {\n  ${output} = ${outputValue};\n}`;\n  }\n  // WebGL 1.0\n  return `\\\nvarying ${inputType} ${input};\nvoid main() {\n  gl_FragColor = ${outputValue};\n}`;\n}\n\n// convert glsl type to suffix\nexport function typeToChannelSuffix(type) {\n  switch (type) {\n    case 'float':\n      return 'x';\n    case 'vec2':\n      return 'xy';\n    case 'vec3':\n      return 'xyz';\n    case 'vec4':\n      return 'xyzw';\n    default:\n      assert(false);\n      return null;\n  }\n}\n\n// convert glsl type to channel count\nexport function typeToChannelCount(type) {\n  switch (type) {\n    case 'float':\n      return 1;\n    case 'vec2':\n      return 2;\n    case 'vec3':\n      return 3;\n    case 'vec4':\n      return 4;\n    default:\n      assert(false);\n      return null;\n  }\n}\n\n// Returns glsl instruction for converting to vec4\nexport function convertToVec4(variable, type) {\n  switch (type) {\n    case 'float':\n      return `vec4(${variable}, 0.0, 0.0, 1.0)`;\n    case 'vec2':\n      return `vec4(${variable}, 0.0, 1.0)`;\n    case 'vec3':\n      return `vec4(${variable}, 1.0)`;\n    case 'vec4':\n      return variable;\n    default:\n      assert(false);\n      return null;\n  }\n}\n","import {isWebGL2, Buffer, TransformFeedback} from '@luma.gl/webgl';\nimport {assert} from '@luma.gl/webgl';\n\nexport default class BufferTransform {\n  constructor(gl, props = {}) {\n    this.gl = gl;\n    this.currentIndex = 0;\n    this.feedbackMap = {};\n    this.varyings = null; // varyings array\n    this.bindings = []; // each element is an object : {sourceBuffers, feedbackBuffers, transformFeedback}\n\n    this.resources = {}; // resources to be deleted\n\n    this._initialize(props);\n    Object.seal(this);\n  }\n\n  setupResources(opts) {\n    for (const binding of this.bindings) {\n      this._setupTransformFeedback(binding, opts);\n    }\n  }\n\n  updateModelProps(props = {}) {\n    const {varyings} = this;\n    if (varyings.length > 0) {\n      props = Object.assign({}, props, {varyings});\n    }\n    return props;\n  }\n\n  getDrawOptions(opts = {}) {\n    const binding = this.bindings[this.currentIndex];\n    const {sourceBuffers, transformFeedback} = binding;\n    const attributes = Object.assign({}, sourceBuffers, opts.attributes);\n\n    return {attributes, transformFeedback};\n  }\n\n  swap() {\n    if (this.feedbackMap) {\n      this.currentIndex = this._getNextIndex();\n      return true;\n    }\n    return false;\n  }\n\n  // update source and/or feedbackBuffers\n  update(opts = {}) {\n    this._setupBuffers(opts);\n  }\n\n  // returns current feedbackBuffer of given name\n  getBuffer(varyingName) {\n    const {feedbackBuffers} = this.bindings[this.currentIndex];\n    const bufferOrParams = varyingName ? feedbackBuffers[varyingName] : null;\n    if (!bufferOrParams) {\n      return null;\n    }\n    return bufferOrParams instanceof Buffer ? bufferOrParams : bufferOrParams.buffer;\n  }\n\n  getData({varyingName} = {}) {\n    const buffer = this.getBuffer(varyingName);\n    if (buffer) {\n      return buffer.getData();\n    }\n    return null;\n  }\n\n  // Delete owned resources.\n  delete() {\n    for (const name in this.resources) {\n      this.resources[name].delete();\n    }\n  }\n\n  // Private\n\n  _initialize(props = {}) {\n    this._setupBuffers(props);\n    this.varyings = props.varyings || Object.keys(this.bindings[this.currentIndex].feedbackBuffers);\n    if (this.varyings.length > 0) {\n      // if writting to buffers make sure it is WebGL2\n      assert(isWebGL2(this.gl));\n    }\n  }\n\n  // auto create feedback buffers if requested\n  _getFeedbackBuffers(props) {\n    const {sourceBuffers = {}} = props;\n    const feedbackBuffers = {};\n    if (this.bindings[this.currentIndex]) {\n      // this gurantees a partial feedback buffer set doesn't update\n      // previously set buffers during auto creation mode.\n      Object.assign(feedbackBuffers, this.bindings[this.currentIndex].feedbackBuffers);\n    }\n    if (this.feedbackMap) {\n      // feedbackMap is defined as sourceBuffer as key and feedbackBuffer name as object\n      for (const sourceName in this.feedbackMap) {\n        const feedbackName = this.feedbackMap[sourceName];\n        if (sourceName in sourceBuffers) {\n          feedbackBuffers[feedbackName] = sourceName;\n        }\n      }\n    }\n    Object.assign(feedbackBuffers, props.feedbackBuffers);\n    for (const bufferName in feedbackBuffers) {\n      const bufferOrRef = feedbackBuffers[bufferName];\n      if (typeof bufferOrRef === 'string') {\n        // Create new buffer with same layout and settings as source buffer\n        const sourceBuffer = sourceBuffers[bufferOrRef];\n        const {byteLength, usage, accessor} = sourceBuffer;\n        feedbackBuffers[bufferName] = this._createNewBuffer(bufferName, {\n          byteLength,\n          usage,\n          accessor\n        });\n      }\n    }\n\n    return feedbackBuffers;\n  }\n\n  _setupBuffers(props = {}) {\n    const {sourceBuffers = null} = props;\n    Object.assign(this.feedbackMap, props.feedbackMap);\n    const feedbackBuffers = this._getFeedbackBuffers(props);\n    this._updateBindings({sourceBuffers, feedbackBuffers});\n  }\n\n  _setupTransformFeedback(binding, {model}) {\n    const {program} = model;\n    binding.transformFeedback = new TransformFeedback(this.gl, {\n      program,\n      buffers: binding.feedbackBuffers\n    });\n  }\n\n  _updateBindings(opts) {\n    this.bindings[this.currentIndex] = this._updateBinding(this.bindings[this.currentIndex], opts);\n    if (this.feedbackMap) {\n      const {sourceBuffers, feedbackBuffers} = this._swapBuffers(this.bindings[this.currentIndex]);\n      const nextIndex = this._getNextIndex();\n      this.bindings[nextIndex] = this._updateBinding(this.bindings[nextIndex], {\n        sourceBuffers,\n        feedbackBuffers\n      });\n    }\n  }\n\n  _updateBinding(binding, opts) {\n    if (!binding) {\n      return {\n        sourceBuffers: Object.assign({}, opts.sourceBuffers),\n        feedbackBuffers: Object.assign({}, opts.feedbackBuffers)\n      };\n    }\n    Object.assign(binding.sourceBuffers, opts.sourceBuffers);\n    Object.assign(binding.feedbackBuffers, opts.feedbackBuffers);\n    if (binding.transformFeedback) {\n      binding.transformFeedback.setBuffers(binding.feedbackBuffers);\n    }\n    return binding;\n  }\n\n  _swapBuffers(opts) {\n    if (!this.feedbackMap) {\n      return null;\n    }\n    const sourceBuffers = Object.assign({}, opts.sourceBuffers);\n    const feedbackBuffers = Object.assign({}, opts.feedbackBuffers);\n    for (const srcName in this.feedbackMap) {\n      const dstName = this.feedbackMap[srcName];\n      sourceBuffers[srcName] = opts.feedbackBuffers[dstName];\n      feedbackBuffers[dstName] = opts.sourceBuffers[srcName];\n\n      // make sure the new destination buffer is a Buffer object\n      assert(feedbackBuffers[dstName] instanceof Buffer);\n    }\n    return {sourceBuffers, feedbackBuffers};\n  }\n\n  // Create a buffer and add to list of buffers to be deleted.\n  _createNewBuffer(name, opts) {\n    const buffer = new Buffer(this.gl, opts);\n    if (this.resources[name]) {\n      this.resources[name].delete();\n    }\n    this.resources[name] = buffer;\n    return buffer;\n  }\n\n  _getNextIndex() {\n    return (this.currentIndex + 1) % 2;\n  }\n}\n","// returns GLSL shader version of given shader string\nexport default function getShaderVersion(source) {\n  let version = 100;\n  const words = source.match(/[^\\s]+/g);\n  if (words.length >= 2 && words[0] === '#version') {\n    const v = parseInt(words[1], 10);\n    if (Number.isFinite(v)) {\n      version = v;\n    }\n  }\n  return version;\n}\n","// Private shader module used by `Transform`\n\nconst vs = `\\\nattribute float transform_elementID;\n\n// returns half of pixel size, used to move the pixel position to center of the pixel.\nvec2 transform_getPixelSizeHalf(vec2 size) {\n  return vec2(1.) / (2. * size);\n}\n\n// returns current elements pixel indeces [x, y],\n// where x ranges in [0 to texSize-1] and y ranges in [0 to texSize-1]\nvec2 transform_getPixelIndices(vec2 texSize, vec2 pixelSizeHalf) {\n  // Add safe offset (half of pixel height) before doing floor\n  float yIndex = floor((transform_elementID / texSize[0]) + pixelSizeHalf[1]);\n  float xIndex = transform_elementID - (yIndex * texSize[0]);\n  return vec2(xIndex, yIndex);\n}\n\n// returns current elementID's texture co-ordianate\nvec2 transform_getTexCoord(vec2 size) {\n  vec2 pixelSizeHalf = transform_getPixelSizeHalf(size);\n  vec2 indices = transform_getPixelIndices(size, pixelSizeHalf);\n  vec2 coord = indices / size + pixelSizeHalf;\n  return coord;\n}\n\n// returns current elementID's position\nvec2 transform_getPos(vec2 size) {\n  vec2 texCoord = transform_getTexCoord(size);\n  // Change from [0 1] range to [-1 1]\n  vec2 pos = (texCoord * (2.0, 2.0)) - (1., 1.);\n  return pos;\n}\n\n// returns current elementID's pixel value\nvec4 transform_getInput(sampler2D texSampler, vec2 size) {\n  vec2 texCoord = transform_getTexCoord(size);\n  vec4 textureColor = texture2D(texSampler, texCoord);\n  return textureColor;\n}\n`;\n\nexport default {\n  name: 'transform',\n  vs,\n  fs: null\n};\n","import {assert} from '@luma.gl/webgl';\nimport {combineInjects, getQualifierDetails, typeToChannelSuffix} from '@luma.gl/shadertools';\n\nconst SAMPLER_UNIFORM_PREFIX = 'transform_uSampler_';\nconst SIZE_UNIFORM_PREFIX = 'transform_uSize_';\nconst VS_POS_VARIABLE = 'transform_position';\n\n// Scan provided vertex shader\n// for each texture attribute, inject sampler instructions and build uniforms for sampler\n// for texture target, get varying type and inject position instruction\nexport function updateForTextures({vs, sourceTextureMap, targetTextureVarying, targetTexture}) {\n  const texAttributeNames = Object.keys(sourceTextureMap);\n  let sourceCount = texAttributeNames.length;\n  let targetTextureType = null;\n  const samplerTextureMap = {};\n  let updatedVs = vs;\n  let finalInject = {};\n\n  if (sourceCount > 0 || targetTextureVarying) {\n    const vsLines = updatedVs.split('\\n');\n    const updateVsLines = vsLines.slice();\n    vsLines.forEach((line, index, lines) => {\n      // TODO add early exit\n      if (sourceCount > 0) {\n        const updated = processAttributeDefinition(line, sourceTextureMap);\n        if (updated) {\n          const {updatedLine, inject} = updated;\n          updateVsLines[index] = updatedLine;\n          // sampleInstructions.push(sampleInstruction);\n          finalInject = combineInjects([finalInject, inject]);\n          Object.assign(samplerTextureMap, updated.samplerTextureMap);\n          sourceCount--;\n        }\n      }\n      if (targetTextureVarying && !targetTextureType) {\n        targetTextureType = getVaryingType(line, targetTextureVarying);\n      }\n    });\n\n    if (targetTextureVarying) {\n      assert(targetTexture);\n      const sizeName = `${SIZE_UNIFORM_PREFIX}${targetTextureVarying}`;\n\n      const uniformDeclaration = `uniform vec2 ${sizeName};\\n`;\n      const posInstructions = `\\\n     vec2 ${VS_POS_VARIABLE} = transform_getPos(${sizeName});\n     gl_Position = vec4(${VS_POS_VARIABLE}, 0, 1.);\\n`;\n      const inject = {\n        'vs:#decl': uniformDeclaration,\n        'vs:#main-start': posInstructions\n      };\n      finalInject = combineInjects([finalInject, inject]);\n    }\n    updatedVs = updateVsLines.join('\\n');\n  }\n  return {\n    // updated vertex shader (commented texture attribute definition)\n    vs: updatedVs,\n    // type (float, vec2, vec3 of vec4) target texture varying\n    targetTextureType,\n    // required vertex and fragment shader injects\n    inject: finalInject,\n    // map of sampler name to texture name, can be used to set attributes\n    // usefull when swapping textures, as source and destination texture change when swap is called.\n    samplerTextureMap\n  };\n}\n\n// builds and returns an object contaning size uniform for each texture\nexport function getSizeUniforms({sourceTextureMap, targetTextureVarying, targetTexture}) {\n  const uniforms = {};\n  let width;\n  let height;\n  if (targetTextureVarying) {\n    ({width, height} = targetTexture);\n    uniforms[`${SIZE_UNIFORM_PREFIX}${targetTextureVarying}`] = [width, height];\n  }\n  for (const textureName in sourceTextureMap) {\n    ({width, height} = sourceTextureMap[textureName]);\n    uniforms[`${SIZE_UNIFORM_PREFIX}${textureName}`] = [width, height];\n  }\n  return uniforms;\n}\n\n// Checks if provided line is defining an attribute, if so returns details otherwise null\nfunction getAttributeDefinition(line) {\n  return getQualifierDetails(line, ['attribute', 'in']);\n}\n\nfunction getSamplerDeclerations(textureName) {\n  const samplerName = `${SAMPLER_UNIFORM_PREFIX}${textureName}`;\n  const sizeName = `${SIZE_UNIFORM_PREFIX}${textureName}`;\n  const uniformDeclerations = `\\\n  uniform sampler2D ${samplerName};\n  uniform vec2 ${sizeName};`;\n  return {samplerName, sizeName, uniformDeclerations};\n}\n\n// Return size (float, vec2 etc) of a given varying, null if doens't exist.\nexport function getVaryingType(line, varying) {\n  const qualaiferDetails = getQualifierDetails(line, ['varying', 'out']);\n  if (!qualaiferDetails) {\n    return null;\n  }\n  return qualaiferDetails.name === varying ? qualaiferDetails.type : null;\n}\n\n// build required definitions, sample instructions for each texture attribute\nexport function processAttributeDefinition(line, textureMap) {\n  const samplerTextureMap = {};\n  const attributeData = getAttributeDefinition(line);\n  if (!attributeData) {\n    return null;\n  }\n  const {type, name} = attributeData;\n  if (name && textureMap[name]) {\n    // eslint-disable-next-line no-useless-escape\n    const updatedLine = `\\// ${line} => Replaced by Transform with a sampler`;\n    const {samplerName, sizeName, uniformDeclerations} = getSamplerDeclerations(name);\n\n    const channels = typeToChannelSuffix(type);\n    const sampleInstruction = `  ${type} ${name} = transform_getInput(${samplerName}, ${sizeName}).${channels};\\n`;\n\n    samplerTextureMap[samplerName] = name;\n    const inject = {\n      'vs:#decl': uniformDeclerations,\n      'vs:#main-start': sampleInstruction\n    };\n\n    // samplerNameMap\n    return {\n      // update vertex shader line.\n      updatedLine,\n      // inject object with sampler instructions.\n      inject,\n      // sampler name to texture name map\n      samplerTextureMap\n    };\n  }\n  return null;\n}\n","import GL from '@luma.gl/constants';\nimport {\n  cloneTextureFrom,\n  readPixelsToArray,\n  getShaderVersion,\n  Buffer,\n  Texture2D,\n  Framebuffer\n} from '@luma.gl/webgl';\nimport {\n  _transform as transformModule,\n  getPassthroughFS,\n  typeToChannelCount,\n  combineInjects\n} from '@luma.gl/shadertools';\nimport {updateForTextures, getSizeUniforms} from './transform-shader-utils';\n\n// TODO: move these constants to transform-shader-utils\n// Texture parameters needed so sample can precisely pick pixel for given element id.\nconst SRC_TEX_PARAMETER_OVERRIDES = {\n  [GL.TEXTURE_MIN_FILTER]: GL.NEAREST,\n  [GL.TEXTURE_MAG_FILTER]: GL.NEAREST,\n  [GL.TEXTURE_WRAP_S]: GL.CLAMP_TO_EDGE,\n  [GL.TEXTURE_WRAP_T]: GL.CLAMP_TO_EDGE\n};\nconst FS_OUTPUT_VARIABLE = 'transform_output';\n\nexport default class TextureTransform {\n  constructor(gl, props = {}) {\n    this.gl = gl;\n    this.currentIndex = 0;\n    this._swapTexture = null;\n    this.targetTextureVarying = null;\n    this.targetTextureType = null;\n    this.samplerTextureMap = null;\n    this.bindings = []; // each element is an object : {sourceTextures, targetTexture, framebuffer}\n\n    this.resources = {}; // resources to be deleted\n\n    this._initialize(props);\n    Object.seal(this);\n  }\n\n  updateModelProps(props = {}) {\n    const updatedModelProps = this._processVertexShader(props);\n    return Object.assign({}, props, updatedModelProps);\n  }\n\n  getDrawOptions(opts = {}) {\n    const {sourceTextures, framebuffer, targetTexture} = this.bindings[this.currentIndex];\n\n    const attributes = Object.assign({}, opts.attributes);\n    const uniforms = Object.assign({}, opts.uniforms);\n    const parameters = Object.assign({}, opts.parameters);\n    let discard = opts.discard;\n\n    if (this.hasSourceTextures || this.hasTargetTexture) {\n      attributes.transform_elementID = this.elementIDBuffer;\n\n      for (const sampler in this.samplerTextureMap) {\n        const textureName = this.samplerTextureMap[sampler];\n        uniforms[sampler] = sourceTextures[textureName];\n      }\n      this._setSourceTextureParameters();\n      // get texture size uniforms\n      const sizeUniforms = getSizeUniforms({\n        sourceTextureMap: sourceTextures,\n        targetTextureVarying: this.targetTextureVarying,\n        targetTexture\n      });\n      Object.assign(uniforms, sizeUniforms);\n    }\n\n    if (this.hasTargetTexture) {\n      discard = false;\n      parameters.viewport = [0, 0, framebuffer.width, framebuffer.height];\n    }\n\n    return {attributes, framebuffer, uniforms, discard, parameters};\n  }\n\n  swap() {\n    if (this._swapTexture) {\n      this.currentIndex = this._getNextIndex();\n      return true;\n    }\n    return false;\n  }\n\n  // update source and/or feedbackBuffers\n  update(opts = {}) {\n    this._setupTextures(opts);\n  }\n\n  // returns current target texture\n  getTargetTexture() {\n    const {targetTexture} = this.bindings[this.currentIndex];\n    return targetTexture;\n  }\n\n  getData({packed = false} = {}) {\n    const {framebuffer} = this.bindings[this.currentIndex];\n    const pixels = readPixelsToArray(framebuffer);\n\n    if (!packed) {\n      return pixels;\n    }\n\n    // readPixels returns 4 elements for each pixel, pack the elements when requested\n    const ArrayType = pixels.constructor;\n    const channelCount = typeToChannelCount(this.targetTextureType);\n    const packedPixels = new ArrayType((pixels.length * channelCount) / 4);\n    let packCount = 0;\n    for (let i = 0; i < pixels.length; i += 4) {\n      for (let j = 0; j < channelCount; j++) {\n        packedPixels[packCount++] = pixels[i + j];\n      }\n    }\n    return packedPixels;\n  }\n\n  // returns current framebuffer object that is being used.\n  getFramebuffer() {\n    const currentResources = this.bindings[this.currentIndex];\n    return currentResources.framebuffer;\n  }\n\n  // Delete owned resources.\n  delete() {\n    if (this.ownTexture) {\n      this.ownTexture.delete();\n    }\n    if (this.elementIDBuffer) {\n      this.elementIDBuffer.delete();\n    }\n  }\n\n  // Private\n\n  _initialize(props = {}) {\n    const {_targetTextureVarying, _swapTexture} = props;\n    this._swapTexture = _swapTexture;\n    this.targetTextureVarying = _targetTextureVarying;\n    this.hasTargetTexture = _targetTextureVarying;\n    this._setupTextures(props);\n  }\n\n  // auto create target texture if requested\n  _createTargetTexture(props) {\n    const {sourceTextures, textureOrReference} = props;\n    if (textureOrReference instanceof Texture2D) {\n      return textureOrReference;\n    }\n    // 'targetTexture' is a reference souce texture.\n    const refTexture = sourceTextures[textureOrReference];\n    if (!refTexture) {\n      return null;\n    }\n\n    // save reference texture name, when corresponding source texture is updated\n    // we also update target texture.\n    this._targetRefTexName = textureOrReference;\n\n    return this._createNewTexture(refTexture);\n  }\n\n  _setupTextures(props = {}) {\n    const {_sourceTextures = {}, _targetTexture} = props;\n    const targetTexture = this._createTargetTexture({\n      sourceTextures: _sourceTextures,\n      textureOrReference: _targetTexture\n    });\n    this.hasSourceTextures =\n      this.hasSourceTextures || (_sourceTextures && Object.keys(_sourceTextures).length > 0);\n    this._updateBindings({sourceTextures: _sourceTextures, targetTexture});\n    if ('elementCount' in props) {\n      this._updateElementIDBuffer(props.elementCount);\n    }\n  }\n\n  _updateElementIDBuffer(elementCount) {\n    if (typeof elementCount !== 'number' || this.elementCount >= elementCount) {\n      return;\n    }\n    // NOTE: using float so this will work with GLSL 1.0 shaders.\n    const elementIds = new Float32Array(elementCount);\n    elementIds.forEach((_, index, array) => {\n      array[index] = index;\n    });\n    if (!this.elementIDBuffer) {\n      this.elementIDBuffer = new Buffer(this.gl, {\n        data: elementIds,\n        accessor: {size: 1}\n      });\n    } else {\n      this.elementIDBuffer.setData({data: elementIds});\n    }\n    this.elementCount = elementCount;\n  }\n\n  _updateBindings(opts) {\n    this.bindings[this.currentIndex] = this._updateBinding(this.bindings[this.currentIndex], opts);\n    if (this._swapTexture) {\n      const {sourceTextures, targetTexture} = this._swapTextures(this.bindings[this.currentIndex]);\n      const nextIndex = this._getNextIndex();\n      this.bindings[nextIndex] = this._updateBinding(this.bindings[nextIndex], {\n        sourceTextures,\n        targetTexture\n      });\n    }\n  }\n\n  _updateBinding(binding, opts) {\n    const {sourceTextures, targetTexture} = opts;\n    if (!binding) {\n      binding = {\n        sourceTextures: {},\n        targetTexture: null\n      };\n    }\n    Object.assign(binding.sourceTextures, sourceTextures);\n    if (targetTexture) {\n      binding.targetTexture = targetTexture;\n\n      const {width, height} = targetTexture;\n      const {framebuffer} = binding;\n      if (framebuffer) {\n        // First update texture without re-sizing attachments\n        framebuffer.update({\n          attachments: {[GL.COLOR_ATTACHMENT0]: targetTexture},\n          resizeAttachments: false\n        });\n        // Resize to new taget texture size\n        framebuffer.resize({width, height});\n      } else {\n        binding.framebuffer = new Framebuffer(this.gl, {\n          id: `${this.id || 'transform'}-framebuffer`,\n          width,\n          height,\n          attachments: {\n            [GL.COLOR_ATTACHMENT0]: targetTexture\n          }\n        });\n      }\n    }\n    return binding;\n  }\n\n  // set texture filtering parameters on source textures.\n  _setSourceTextureParameters() {\n    const index = this.currentIndex;\n    const {sourceTextures} = this.bindings[index];\n    for (const name in sourceTextures) {\n      sourceTextures[name].setParameters(SRC_TEX_PARAMETER_OVERRIDES);\n    }\n  }\n\n  _swapTextures(opts) {\n    if (!this._swapTexture) {\n      return null;\n    }\n    const sourceTextures = Object.assign({}, opts.sourceTextures);\n    sourceTextures[this._swapTexture] = opts.targetTexture;\n\n    const targetTexture = opts.sourceTextures[this._swapTexture];\n\n    return {sourceTextures, targetTexture};\n  }\n\n  // Create a buffer and add to list of buffers to be deleted.\n  _createNewTexture(refTexture) {\n    const texture = cloneTextureFrom(refTexture, {\n      parameters: {\n        [GL.TEXTURE_MIN_FILTER]: GL.NEAREST,\n        [GL.TEXTURE_MAG_FILTER]: GL.NEAREST,\n        [GL.TEXTURE_WRAP_S]: GL.CLAMP_TO_EDGE,\n        [GL.TEXTURE_WRAP_T]: GL.CLAMP_TO_EDGE\n      },\n      pixelStore: {\n        [GL.UNPACK_FLIP_Y_WEBGL]: false\n      }\n    });\n\n    // thre can only be one target texture\n    if (this.ownTexture) {\n      this.ownTexture.delete();\n    }\n    this.ownTexture = texture;\n\n    return texture;\n  }\n\n  _getNextIndex() {\n    return (this.currentIndex + 1) % 2;\n  }\n\n  // build and return shader releated parameters\n  _processVertexShader(props = {}) {\n    const {sourceTextures, targetTexture} = this.bindings[this.currentIndex];\n    const {vs, uniforms, targetTextureType, inject, samplerTextureMap} = updateForTextures({\n      vs: props.vs,\n      sourceTextureMap: sourceTextures,\n      targetTextureVarying: this.targetTextureVarying,\n      targetTexture\n    });\n    const combinedInject = combineInjects([props.inject || {}, inject]);\n    this.targetTextureType = targetTextureType;\n    this.samplerTextureMap = samplerTextureMap;\n    const fs =\n      props._fs ||\n      getPassthroughFS({\n        version: getShaderVersion(vs),\n        input: this.targetTextureVarying,\n        inputType: targetTextureType,\n        output: FS_OUTPUT_VARIABLE\n      });\n    const modules =\n      this.hasSourceTextures || this.targetTextureVarying\n        ? [transformModule].concat(props.modules || [])\n        : props.modules;\n    return {vs, fs, modules, uniforms, inject: combinedInject};\n  }\n}\n","import GL from '@luma.gl/constants';\nimport {getPassthroughFS} from '@luma.gl/shadertools';\nimport BufferTransform from './buffer-transform';\nimport TextureTransform from './texture-transform';\n\nimport {isWebGL2, getShaderVersion} from '@luma.gl/webgl';\nimport {assert, isObjectEmpty} from '@luma.gl/webgl';\nimport Model from '../lib/model';\n\n// takes source and target buffers/textures and setsup the pipeline\nexport default class Transform {\n  static isSupported(gl) {\n    // TODO : differentiate writting to buffer vs not\n    return isWebGL2(gl);\n  }\n\n  constructor(gl, props = {}) {\n    this.gl = gl;\n    this.model = null;\n    this.elementCount = 0;\n    this.bufferTransform = null;\n    this.textureTransform = null;\n    this.elementIDBuffer = null;\n    this._initialize(props);\n    Object.seal(this);\n  }\n\n  // Delete owned resources.\n  delete() {\n    const {model, bufferTransform, textureTransform} = this;\n    if (model) {\n      model.delete();\n    }\n    if (bufferTransform) {\n      bufferTransform.delete();\n    }\n    if (textureTransform) {\n      textureTransform.delete();\n    }\n  }\n\n  // Run one transform loop.\n  run(opts = {}) {\n    const {clearRenderTarget = true} = opts;\n\n    const updatedOpts = this._updateDrawOptions(opts);\n\n    if (clearRenderTarget && updatedOpts.framebuffer) {\n      updatedOpts.framebuffer.clear({color: true});\n    }\n\n    this.model.transform(updatedOpts);\n  }\n\n  // swap resources if a map is provided\n  swap() {\n    let swapped = false;\n    const resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);\n    for (const resourceTransform of resourceTransforms) {\n      swapped = swapped || resourceTransform.swap();\n    }\n    assert(swapped, 'Nothing to swap');\n  }\n\n  // Return Buffer object for given varying name.\n  getBuffer(varyingName = null) {\n    return this.bufferTransform && this.bufferTransform.getBuffer(varyingName);\n  }\n\n  // Return data either from Buffer or from Texture\n  getData(opts = {}) {\n    const resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);\n    for (const resourceTransform of resourceTransforms) {\n      const data = resourceTransform.getData(opts);\n      if (data) {\n        return data;\n      }\n    }\n    return null;\n  }\n\n  // Return framebuffer object if rendering to textures\n  getFramebuffer() {\n    return this.textureTransform && this.textureTransform.getFramebuffer();\n  }\n\n  // Update some or all buffer/texture bindings.\n  update(opts = {}) {\n    if ('elementCount' in opts) {\n      this.model.setVertexCount(opts.elementCount);\n    }\n    const resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);\n    for (const resourceTransform of resourceTransforms) {\n      resourceTransform.update(opts);\n    }\n  }\n\n  // Private\n\n  _initialize(props = {}) {\n    const {gl} = this;\n    this._buildResourceTransforms(gl, props);\n\n    props = this._updateModelProps(props);\n    this.model = new Model(\n      gl,\n      Object.assign({}, props, {\n        fs: props.fs || getPassthroughFS({version: getShaderVersion(props.vs)}),\n        id: props.id || 'transform-model',\n        drawMode: props.drawMode || GL.POINTS,\n        vertexCount: props.elementCount\n      })\n    );\n\n    /* eslint-disable no-unused-expressions */\n    this.bufferTransform && this.bufferTransform.setupResources({model: this.model});\n    /* eslint-enable no-unused-expressions */\n  }\n\n  _updateModelProps(props) {\n    let updatedProps = Object.assign({}, props);\n    const resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);\n    for (const resourceTransform of resourceTransforms) {\n      updatedProps = resourceTransform.updateModelProps(updatedProps);\n    }\n    return updatedProps;\n  }\n\n  _buildResourceTransforms(gl, props) {\n    if (canCreateBufferTransform(props)) {\n      this.bufferTransform = new BufferTransform(gl, props);\n    }\n    if (canCreateTextureTransform(props)) {\n      this.textureTransform = new TextureTransform(gl, props);\n    }\n    assert(\n      this.bufferTransform || this.textureTransform,\n      'must provide source/feedback buffers or source/target textures'\n    );\n  }\n\n  _updateDrawOptions(opts) {\n    let updatedOpts = Object.assign({}, opts);\n    const resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);\n    for (const resourceTransform of resourceTransforms) {\n      updatedOpts = Object.assign(updatedOpts, resourceTransform.getDrawOptions(updatedOpts));\n    }\n    return updatedOpts;\n  }\n}\n\n// Helper Methods\n\nfunction canCreateBufferTransform(props) {\n  if (\n    !isObjectEmpty(props.sourceBuffers) ||\n    !isObjectEmpty(props.feedbackBuffers) ||\n    (props.varyings && props.varyings.length > 0)\n  ) {\n    return true;\n  }\n  return false;\n}\n\nfunction canCreateTextureTransform(props) {\n  if (\n    !isObjectEmpty(props._sourceTextures) ||\n    props._targetTexture ||\n    props._targetTextureVarying\n  ) {\n    return true;\n  }\n\n  return false;\n}\n","/* global window */\nimport {Buffer, isWebGL2, readPixelsToArray, Framebuffer} from '@luma.gl/webgl';\nimport {picking} from '@luma.gl/shadertools';\nimport {AnimationLoop, Model, Transform} from '@luma.gl/engine';\nimport {cssToDevicePixels} from '@luma.gl/webgl';\nimport {Log} from 'probe.gl';\nimport {getRandom} from '../../utils';\n\nconst RED = new Uint8Array([255, 0, 0, 255]);\n\n/* eslint-disable max-len */\nconst INFO_HTML = `\n<p>\n  Instanced triangles animated on the GPU using a luma.gl <code>Transform</code> object.\n\n  This is a port of an example from\n  <a href=\"https://github.com/WebGLSamples/WebGL2Samples/blob/master/samples/transform_feedback_instanced.html\">\n    WebGL2Samples\n  </a>\n`;\n/* eslint-enable max-len */\n\n// Text to be displayed on environments when this demos is not supported.\nconst ALT_TEXT = \"THIS DEMO REQUIRES WEBGL2, BUT YOUR BROWSER DOESN'T SUPPORT IT\";\n\nconst EMIT_VS = `\\\n#version 300 es\n#define OFFSET_LOCATION 0\n#define ROTATION_LOCATION 1\n\n#define M_2PI 6.28318530718\n\n// We simulate the wandering of agents using transform feedback in this vertex shader\n// The simulation goes like this:\n// Assume there's a circle in front of the agent whose radius is WANDER_CIRCLE_R\n// the origin of which has a offset to the agent's pivot point, which is WANDER_CIRCLE_OFFSET\n// Each frame we pick a random point on this circle\n// And the agent moves MOVE_DELTA toward this target point\n// We also record the rotation facing this target point, so it will be the base rotation\n// for our next frame, which means the WANDER_CIRCLE_OFFSET vector will be on this direction\n// Thus we fake a smooth wandering behavior\n\n#define MAP_HALF_LENGTH 1.01\n#define WANDER_CIRCLE_R 0.01\n#define WANDER_CIRCLE_OFFSET 0.04\n#define MOVE_DELTA 0.001\nprecision highp float;\nprecision highp int;\nuniform float u_time;\nlayout(location = OFFSET_LOCATION) in vec2 a_offset;\nlayout(location = ROTATION_LOCATION) in float a_rotation;\nout vec2 v_offset;\nout float v_rotation;\n\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvoid main()\n{\n    float theta = M_2PI * rand(vec2(u_time, a_rotation + a_offset.x + a_offset.y));\n    float cos_r = cos(a_rotation);\n    float sin_r = sin(a_rotation);\n    mat2 rot = mat2(\n        cos_r, sin_r,\n        -sin_r, cos_r\n    );\n\n    vec2 p = WANDER_CIRCLE_R * vec2(cos(theta), sin(theta)) + vec2(WANDER_CIRCLE_OFFSET, 0.0);\n    vec2 move = normalize(rot * p);\n    v_rotation = atan(move.y, move.x);\n    v_offset = a_offset + MOVE_DELTA * move;\n\n    // wrapping at edges\n    v_offset = vec2 (\n        v_offset.x > MAP_HALF_LENGTH ? - MAP_HALF_LENGTH :\n          ( v_offset.x < - MAP_HALF_LENGTH ? MAP_HALF_LENGTH : v_offset.x ) ,\n        v_offset.y > MAP_HALF_LENGTH ? - MAP_HALF_LENGTH :\n          ( v_offset.y < - MAP_HALF_LENGTH ? MAP_HALF_LENGTH : v_offset.y )\n        );\n\n    gl_Position = vec4(v_offset, 0.0, 1.0);\n}\n`;\n\nconst DRAW_VS = `\\\n#version 300 es\n#define OFFSET_LOCATION 0\n#define ROTATION_LOCATION 1\n#define POSITION_LOCATION 2\n#define COLOR_LOCATION 3\nprecision highp float;\nprecision highp int;\nlayout(location = POSITION_LOCATION) in vec2 a_position;\nlayout(location = ROTATION_LOCATION) in float a_rotation;\nlayout(location = OFFSET_LOCATION) in vec2 a_offset;\nlayout(location = COLOR_LOCATION) in vec3 a_color;\nin vec2 instancePickingColors;\nout vec3 v_color;\nvoid main()\n{\n    v_color = a_color;\n\n    float cos_r = cos(a_rotation);\n    float sin_r = sin(a_rotation);\n    mat2 rot = mat2(\n        cos_r, sin_r,\n        -sin_r, cos_r\n    );\n    gl_Position = vec4(rot * a_position + a_offset, 0.0, 1.0);\n    picking_setPickingColor(vec3(0., instancePickingColors));\n}\n`;\n\nconst DRAW_FS = `\\\n#version 300 es\n#define ALPHA 0.9\nprecision highp float;\nprecision highp int;\nin vec3 v_color;\nout vec4 color;\nvoid main()\n{\n    color = vec4(v_color * ALPHA, ALPHA);\n    color = picking_filterColor(color);\n}\n`;\n\nconst random = getRandom();\n\nconst NUM_INSTANCES = 1000;\nconst log = new Log({id: 'transform'}).enable();\n\n// TODO PIKCING TEMPORARILY DISABLED\nlet pickPosition = [0, 0];\n\nfunction mousemove(e) {\n  pickPosition = [e.offsetX, e.offsetY];\n}\n\nfunction mouseleave(e) {\n  pickPosition = null;\n}\n\nexport default class AppAnimationLoop extends AnimationLoop {\n  static getInfo() {\n    return INFO_HTML;\n  }\n\n  constructor(props = {}) {\n    super(Object.assign(props));\n    // Default value is true, so GL context is always created to verify wheter it is WebGL2 or not.\n    this.isDemoSupported = true;\n  }\n  /* eslint-disable max-statements */\n  onInitialize({canvas, gl, width, height}) {\n    this.isDemoSupported = isWebGL2(gl);\n    if (!this.isDemoSupported) {\n      log.error(ALT_TEXT)();\n      return {};\n    }\n    gl.canvas.addEventListener('mousemove', mousemove);\n    gl.canvas.addEventListener('mouseleave', mouseleave);\n\n    // -- Initialize data\n    const trianglePositions = new Float32Array([0.015, 0.0, -0.01, 0.01, -0.01, -0.01]);\n\n    const instanceOffsets = new Float32Array(NUM_INSTANCES * 2);\n    const instanceRotations = new Float32Array(NUM_INSTANCES);\n    const instanceColors = new Float32Array(NUM_INSTANCES * 3);\n    const pickingColors = new Uint8ClampedArray(NUM_INSTANCES * 2);\n\n    for (let i = 0; i < NUM_INSTANCES; ++i) {\n      instanceOffsets[i * 2] = random() * 2.0 - 1.0;\n      instanceOffsets[i * 2 + 1] = random() * 2.0 - 1.0;\n\n      instanceRotations[i] = random() * 2 * Math.PI;\n\n      const randValue = random();\n      if (randValue > 0.5) {\n        instanceColors[i * 3 + 1] = 1.0;\n        instanceColors[i * 3 + 2] = 1.0;\n      } else {\n        instanceColors[i * 3] = 1.0;\n        instanceColors[i * 3 + 2] = 1.0;\n      }\n\n      pickingColors[i * 2] = Math.floor(i / 255);\n      pickingColors[i * 2 + 1] = i - 255 * pickingColors[i * 2];\n    }\n\n    const positionBuffer = new Buffer(gl, trianglePositions);\n    const colorBuffer = new Buffer(gl, instanceColors);\n    const offsetBuffer = new Buffer(gl, instanceOffsets);\n    const rotationBuffer = new Buffer(gl, instanceRotations);\n    const pickingColorBuffer = new Buffer(gl, pickingColors);\n\n    const renderModel = new Model(gl, {\n      id: 'RenderModel',\n      vs: DRAW_VS,\n      fs: DRAW_FS,\n      drawMode: gl.TRIANGLE_FAN,\n      vertexCount: 3,\n      isInstanced: true,\n      instanceCount: NUM_INSTANCES,\n      attributes: {\n        a_position: positionBuffer,\n        a_color: [colorBuffer, {divisor: 1}],\n        a_offset: [offsetBuffer, {divisor: 1}],\n        a_rotation: [rotationBuffer, {divisor: 1}],\n        instancePickingColors: [pickingColorBuffer, {divisor: 1}]\n      },\n      modules: [picking]\n    });\n\n    const transform = new Transform(gl, {\n      vs: EMIT_VS,\n      elementCount: NUM_INSTANCES,\n      sourceBuffers: {\n        a_offset: offsetBuffer,\n        a_rotation: rotationBuffer\n      },\n      feedbackMap: {\n        a_offset: 'v_offset',\n        a_rotation: 'v_rotation'\n      }\n    });\n\n    const pickingFramebuffer = new Framebuffer(gl, {width, height});\n\n    return {\n      positionBuffer,\n      rotationBuffer,\n      colorBuffer,\n      offsetBuffer,\n      renderModel,\n      transform,\n      pickingFramebuffer\n    };\n  }\n  /* eslint-enable max-statements */\n\n  onRender({\n    gl,\n    width,\n    height,\n    renderModel,\n    positionBuffer,\n    colorBuffer,\n    transform,\n    useDevicePixels,\n    time,\n    pickingFramebuffer\n  }) {\n    if (!this.isDemoSupported) {\n      return;\n    }\n    transform.run({\n      uniforms: {\n        u_time: time\n      }\n    });\n\n    transform.swap();\n\n    const offsetBuffer = transform.getBuffer('v_offset');\n    const rotationBuffer = transform.getBuffer('v_rotation');\n\n    offsetBuffer.setAccessor({divisor: 1});\n    rotationBuffer.setAccessor({divisor: 1});\n\n    renderModel.clear({color: [0.0, 0.0, 0.0, 1.0], depth: true});\n    renderModel.draw({\n      attributes: {\n        a_offset: offsetBuffer,\n        a_rotation: rotationBuffer\n      },\n      parameters: {\n        blend: true,\n        blendFunc: [gl.SRC_ALPHA, gl.ONE]\n      }\n    });\n\n    offsetBuffer.setAccessor({divisor: 0});\n    rotationBuffer.setAccessor({divisor: 0});\n\n    if (pickPosition) {\n      // use the center pixel location in device pixel range\n      const devicePixels = cssToDevicePixels(gl, pickPosition);\n      const deviceX = devicePixels.x + Math.floor(devicePixels.width / 2);\n      const deviceY = devicePixels.y + Math.floor(devicePixels.height / 2);\n\n      pickingFramebuffer.resize({width, height});\n\n      pickInstance(gl, deviceX, deviceY, renderModel, pickingFramebuffer);\n    }\n  }\n\n  onFinalize({renderModel, transform}) {\n    if (renderModel) {\n      renderModel.delete();\n    }\n    if (transform) {\n      transform.delete();\n    }\n  }\n\n  isSupported() {\n    return this.isDemoSupported;\n  }\n\n  getAltText() {\n    return ALT_TEXT;\n  }\n}\n\nfunction pickInstance(gl, pickX, pickY, model, framebuffer) {\n  framebuffer.clear({color: true, depth: true});\n  // Render picking colors\n  /* eslint-disable camelcase */\n  model.setUniforms({picking_uActive: 1});\n  model.draw({framebuffer});\n  model.setUniforms({picking_uActive: 0});\n\n  const color = readPixelsToArray(framebuffer, {\n    sourceX: pickX,\n    sourceY: pickY,\n    sourceWidth: 1,\n    sourceHeight: 1,\n    sourceFormat: gl.RGBA,\n    sourceType: gl.UNSIGNED_BYTE\n  });\n\n  if (color[0] + color[1] + color[2] > 0) {\n    model.updateModuleSettings({\n      pickingSelectedColor: color,\n      pickingHighlightColor: RED\n    });\n  } else {\n    model.updateModuleSettings({\n      pickingSelectedColor: null\n    });\n  }\n}\n\n/* global window */\nif (typeof window !== 'undefined' && !window.website) {\n  const animationLoop = new AppAnimationLoop();\n  animationLoop.start();\n}\n","import React from 'react';\nimport AnimationLoopExamplePage from '../../src/components/animation-loop-example-page';\nimport AnimationLoop from '../../../examples/showcase/transform/app';\n\nexport default class Example extends React.Component {\n  render() {\n    return (\n      <AnimationLoopExamplePage AnimationLoop={AnimationLoop} exampleConfig={this.props.pageContext.exampleConfig} />\n    );\n  }\n}\n","/* global window, document */\n\n// Light class implementing the AnimationLoop interface\n// use by examples w/o creating a gl context\nexport class MiniAnimationLoop {\n  static getInfo() {\n    return '';\n  }\n\n  start() {}\n\n  stop() {}\n\n  delete() {}\n\n  _setDisplay() {}\n\n  _getCanvas(props = {}) {\n    let canvas;\n    if (props.canvas) {\n      canvas = document.getElementById(props.canvas);\n      const dpr = window.devicePixelRatio || 1;\n      canvas.height = canvas.clientHeight * dpr;\n      canvas.width = canvas.clientWidth * dpr;\n    } else {\n      canvas = document.createElement('canvas');\n      canvas.width = 800;\n      canvas.height = 600;\n      document.body.appendChild(canvas);\n    }\n\n    return canvas;\n  }\n}\n\n// Create a deterministic pseudorandom number generator\nexport function getRandom() {\n  let s = 1;\n  let c = 1;\n  return () => {\n    s = Math.sin(c * 17.23);\n    c = Math.cos(s * 27.92);\n    return fract(Math.abs(s * c) * 1432.71);\n  };\n}\n\nfunction fract(n) {\n  return n - Math.floor(n);\n}\n","const DEFAULT_HIGHLIGHT_COLOR = new Uint8Array([0, 255, 255, 255]);\n\nconst DEFAULT_MODULE_OPTIONS = {\n  pickingSelectedColor: null, //  Set to a picking color to visually highlight that item\n  pickingHighlightColor: DEFAULT_HIGHLIGHT_COLOR, // Color of visual highlight of \"selected\" item\n  pickingActive: false, // Set to true when rendering to off-screen \"picking\" buffer\n  pickingAttribute: false // Set to true when picking an attribute value instead of object index\n};\n\n/* eslint-disable camelcase */\nfunction getUniforms(opts = DEFAULT_MODULE_OPTIONS) {\n  const uniforms = {};\n  if (opts.pickingSelectedColor !== undefined) {\n    if (!opts.pickingSelectedColor) {\n      uniforms.picking_uSelectedColorValid = 0;\n    } else {\n      const selectedColor = opts.pickingSelectedColor.slice(0, 3);\n      uniforms.picking_uSelectedColorValid = 1;\n      uniforms.picking_uSelectedColor = selectedColor;\n    }\n  }\n  if (opts.pickingHighlightColor) {\n    uniforms.picking_uHighlightColor = opts.pickingHighlightColor.map(x => x / 255);\n  }\n  if (opts.pickingActive !== undefined) {\n    uniforms.picking_uActive = Boolean(opts.pickingActive);\n    uniforms.picking_uAttribute = Boolean(opts.pickingAttribute);\n  }\n  return uniforms;\n}\n\nconst vs = `\\\nuniform bool picking_uActive;\nuniform bool picking_uAttribute;\nuniform vec3 picking_uSelectedColor;\nuniform bool picking_uSelectedColorValid;\n\nout vec4 picking_vRGBcolor_Avalid;\n\nconst float COLOR_SCALE = 1. / 255.;\n\nbool picking_isColorValid(vec3 color) {\n  return dot(color, vec3(1.0)) > 0.001;\n}\n\nbool isVertexPicked(vec3 vertexColor) {\n  return\n    picking_uSelectedColorValid &&\n    !picking_isColorValid(abs(vertexColor - picking_uSelectedColor));\n}\n\nvoid picking_setPickingColor(vec3 pickingColor) {\n  if (picking_uActive) {\n    // Use alpha as the validity flag. If pickingColor is [0, 0, 0] fragment is non-pickable\n    picking_vRGBcolor_Avalid.a = float(picking_isColorValid(pickingColor));\n\n    if (!picking_uAttribute) {\n      // Stores the picking color so that the fragment shader can render it during picking\n      picking_vRGBcolor_Avalid.rgb = pickingColor * COLOR_SCALE;\n    }\n  } else {\n    // Do the comparison with selected item color in vertex shader as it should mean fewer compares\n    picking_vRGBcolor_Avalid.a = float(isVertexPicked(pickingColor));\n  }\n}\n\nvoid picking_setPickingAttribute(float value) {\n  if (picking_uAttribute) {\n    picking_vRGBcolor_Avalid.r = value;\n  }\n}\nvoid picking_setPickingAttribute(vec2 value) {\n  if (picking_uAttribute) {\n    picking_vRGBcolor_Avalid.rg = value;\n  }\n}\nvoid picking_setPickingAttribute(vec3 value) {\n  if (picking_uAttribute) {\n    picking_vRGBcolor_Avalid.rgb = value;\n  }\n}\n`;\n\nconst fs = `\\\nuniform bool picking_uActive;\nuniform vec3 picking_uSelectedColor;\nuniform vec4 picking_uHighlightColor;\n\nin vec4 picking_vRGBcolor_Avalid;\n\n/*\n * Returns highlight color if this item is selected.\n */\nvec4 picking_filterHighlightColor(vec4 color) {\n  if (picking_uActive) {\n    return color;\n  }\n  bool selected = bool(picking_vRGBcolor_Avalid.a);\n\n  if (selected) {\n    float highLightAlpha = picking_uHighlightColor.a;\n    float blendedAlpha = highLightAlpha + color.a * (1.0 - highLightAlpha);\n    float highLightRatio = highLightAlpha / blendedAlpha;\n\n    vec3 blendedRGB = mix(color.rgb, picking_uHighlightColor.rgb, highLightRatio);\n    return vec4(blendedRGB, blendedAlpha);\n  } else {\n    return color;\n  }\n}\n\n/*\n * Returns picking color if picking enabled else unmodified argument.\n */\nvec4 picking_filterPickingColor(vec4 color) {\n  if (picking_uActive) {\n    if (picking_vRGBcolor_Avalid.a == 0.0) {\n      discard;\n    }\n    return picking_vRGBcolor_Avalid;\n  }\n  return color;\n}\n\n/*\n * Returns picking color if picking is enabled if not\n * highlight color if this item is selected, otherwise unmodified argument.\n */\nvec4 picking_filterColor(vec4 color) {\n  vec4 highightColor = picking_filterHighlightColor(color);\n  return picking_filterPickingColor(highightColor);\n}\n\n`;\n\nexport default {\n  name: 'picking',\n  vs,\n  fs,\n  getUniforms\n};\n"],"sourceRoot":""}