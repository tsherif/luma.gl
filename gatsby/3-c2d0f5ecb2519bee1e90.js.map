{"version":3,"sources":["webpack:///../modules/shadertools/src/lib/shader-module-registry.js","webpack:///../modules/shadertools/src/lib/resolve-modules.js","webpack:///../modules/shadertools/src/utils/webgl-info.js","webpack:///../modules/shadertools/src/utils/is-old-ie.js","webpack:///../modules/shadertools/src/lib/platform-defines.js","webpack:///../modules/shadertools/src/lib/assemble-shaders.js","webpack:///../modules/core/src/lib/model-utils.js","webpack:///../modules/webgl/src/utils/format-value.js","webpack:///../modules/webgl/src/debug/debug-vertex-array.js","webpack:///../modules/webgl/src/debug/debug-uniforms.js","webpack:///../modules/webgl/src/debug/debug-program-configuration.js","webpack:///../modules/core/src/debug/seer-integration.js","webpack:///../modules/core/src/lib/base-model.js","webpack:///../modules/core/src/lib/model.js","webpack:///../modules/shadertools/src/lib/transpile-shader.js","webpack:///../modules/shadertools/src/lib/filters/prop-types.js","webpack:///../modules/shadertools/src/lib/shader-module.js","webpack:///../modules/shadertools/src/lib/inject-shader.js","webpack:///../modules/shadertools/src/modules/module-injectors.js","webpack:///../modules/shadertools/src/lib/constants.js","webpack:///../modules/shadertools/src/index.js","webpack:///../modules/shadertools/src/shaders/modular-vertex.glsl.js","webpack:///../modules/shadertools/src/shaders/modular-fragment.glsl.js","webpack:///../modules/shadertools/src/utils/assert.js","webpack:///../modules/webgl/src/classes/transform-feedback.js"],"names":["ShaderModuleRegistry","this","shaderModules","defaultShaderModules","setDefaultShaderModules","resolveModules","modules","getDefaultShaderModules","registerShaderModules","_ref$ignoreMultipleRe","_temp","ignoreMultipleRegistrations","_iterator","shaderModuleList","_isArray","Array","isArray","_i","Symbol","iterator","_ref2","length","next","done","value","shaderModule","_registerShaderModule","getShaderModule","moduleOrName","shader_module","module","assert","_this","map","name","Error","shaderModuleRegistry","shader_module_registry_ShaderModuleRegistry","getShaderDependencies","resolve_modules_getShaderModule","moduleMap","moduleDepth","getDependencyGraph","level","Object","keys","sort","a","b","_ref3","_iterator2","_isArray2","_i2","_ref4","dependencies","GL_VENDOR","GL_RENDERER","GL_VERSION","GL_SHADING_LANGUAGE_VERSION","WEBGL_FEATURES","GLSL_FRAG_DATA","GLSL_FRAG_DEPTH","GLSL_DERIVATIVES","GLSL_TEXTURE_LOD","FEATURES","key","compiledGlslExtensions","canCompileGLGSExtension","gl","cap","opts","feature","navigator","window","userAgent","isMSIE","isTrident","isOldIE","source","shader","VERTEX_SHADER","canCompile","COMPILE_STATUS","getFeature","extensionName","Boolean","isWebGL2","hasFeatures","features","every","getPlatformShaderDefines","info","vendor","UNMASKED_VENDOR_WEBGL","renderer","UNMASKED_RENDERER_WEBGL","gpuVendor","identifyGPUVendor","version","shadingLanguageVersion","getContextInfo","debugInfo","toLowerCase","INJECT_SHADER_DECLARATIONS","inject_shader","SHADER_TYPE","_SHADER_TYPE","constants","HOOK_FUNCTIONS","_HOOK_FUNCTIONS","MODULE_INJECTIONS","FRAGMENT_SHADER_PROLOGUE","createShaderHook","hook","_hook$split","stage","signature","assign","createModuleInjection","moduleName","injection","_opts$order","order","shaderStage","assembleShaders","vs","fs","assembleShader","type","getUniforms","assembleGetUniforms","assembleModuleMap","_ref","id","_ref$defines","defines","_ref$inject","inject","_ref$prologue","prologue","log","isVertex","sourceLines","glslVersion","versionLine","coreSource","allDefines","assembledSource","_ref6","getShaderName","_ref5","toUpperCase","getShaderType","isFragment","versionDefines","behavior","getVersionDefines","count","sourceText","define","Number","getApplicationDefines","injectStandardStubs","hookInjections","mainInjections","injections","_key","result","hookFunctions","hookName","hookFunction","header","_iterator4","_isArray4","_i4","_ref7","footer","getHookFunctions","injectShader","uniforms","moduleUniforms","_iterator3","_isArray3","_i3","GLTF_TO_LUMA_ATTRIBUTE_MAP","POSITION","NORMAL","COLOR_0","TEXCOORD_0","TEXCOORD_1","TEXCOORD_2","mapAttributeName","options","_ref$attributeMap","attributeMap","inferAttributeAccessor","attributeName","attribute","category","size","formatValue","v","_opts$isInteger","isInteger","ArrayBuffer","_opts$maxElts","maxElts","_opts$size","string","i","formatArrayValue","String","Math","decimal","getDebugTableRow","vertexArray","accessor","marker","verts","bytes","classes_buffer","format","buffer","_buffer$getDebugData","getDebugData","data","modified","getKey","getGLSLDeclaration","typeAndName","getCompositeGLType","getDebugTableForUniforms","_ref$header","program","_ref$undefinedOnly","undefinedOnly","uniformLocations","_uniformSetters","table","uniformNames","uniformName","addUniformToTable","_uniformName","_uniformName2","unusedCount","unusedTable","_unusedTable$uniformN","uniform","Type","_table$uniformName","isDefined","isUniformDefined","debug_program_configuration_getGLSLDeclaration","attributeInfo","_attributeInfo$access","models","recursiveSet","obj","path","overrides","Map","seer","payload","model","itemKey","valuePath","__SEER_INITIALIZED__","setOverride","BaseModel","props","isWebGL","_props$id","uid","lastLogTime","initialize","_setBaseModelProps","_createProgram","vertex_array","userData","needsRedraw","_attributes","attributes","animatedUniforms","animated","animationLoop","timerQueryEnabled","timeElapsedQuery","undefined","lastQueryReturned","stats","accumulatedFrameTime","averageFrameTime","profileFrameCount","pickable","setUniforms","getModuleUniforms","moduleSettings","setProps","delete","removeModel","isAnimated","getProgram","overs","getOverrides","_extractAnimatedUniforms","updateModuleSettings","drawGeometry","_opts","_opts$moduleSettings","framebuffer","_opts$uniforms","_opts$attributes","_opts$transformFeedba","transformFeedback","_opts$parameters","parameters","_opts$vertexArray","animationProps","setAttributes","_refreshAnimationProps","logPriority","_logDrawCallStart","drawParams","getDrawParams","isInstanced","isIndexed","indexType","indexOffset","instanceCount","noop","_this$props","_this$props$onBeforeR","onBeforeRender","_this$props$onAfterRe","onAfterRender","_timerQueryStart","didDraw","draw","drawMode","getDrawMode","vertexCount","getVertexCount","offset","_timerQueryEnd","_logDrawCallEnd","Query","_setAnimationProps","_animationProps","_animationLoop","_ref$vs","_ref$fs","_ref$modules","_ref$shaderCache","shaderCache","_ref$varyings","varyings","_ref$bufferMode","bufferMode","GL","SEPARATE_ATTRIBS","_ref$program","x","MODULAR_SHADERS","assembleResult","classes_program","_evaluateAnimateUniforms","valueFunction","foundAnimated","newValue","isObjectEmpty","staticUniforms","query","beginTimeElapsedQuery","end","isResultAvailable","elapsedTime","getTimerMilliseconds","lastFrameTime","logDrawTimeout","priority","Date","now","collapsed","attributeTable","configuration","elements","values","attributeLocation","rowHeader","location","getDebugTableForVertexArray","_getDebugTableForUnif","uniformTable","_getDebugTableForUnif2","missingTable","configTable","config","attributeInfos","_table","JSON","varyingInfos","_table2","varyingInfo","getDebugTableForProgramConfiguration","isReady","attributesObject","uniformsObject","logModel","message","Model","_BaseModel","call","prototype","TRIANGLES","geometryBuffers","instanced","_setModelProps","geometry","_deleteGeometryBuffers","getInstanceCount","getAttributes","setDrawMode","setVertexCount","setInstanceCount","setGeometry","buffers","indices","remappedName","constant","typedArray","Uint32Array","target","ELEMENT_ARRAY_BUFFER","getBuffersFromGeometry","normalizedAttributes","transform","_Object$assign","_opts$discard","discard","feedbackBuffers","_opts$unbindModels","unbindModels","_setFeedbackBuffers","unbindBuffers","bindBuffers","render","_feedbackBuffers","transform_feedback","setBuffers","transpileShader","targetGLSLVersion","convertVertexShaderTo300","convertFragmentShaderTo300","convertVertexShaderTo100","convertFragmentShaderTo100","TYPE_DEFINITIONS","number","validate","propType","min","array","parsePropType","propDef","getTypeOf","ShaderModule","_ref$dependencies","_ref$deprecations","deprecations","vertexShader","fragmentShader","_parseDeprecationDefinitions","propDefs","propTypes","propName","parsePropTypes","getModuleSource","moduleSource","_defaultGetUniforms","getDefines","checkDeprecations","forEach","def","shaderSource","deprecated","RegExp","old","private","MODULE_INJECTORS","_MODULE_INJECTORS","DECLARATION_INJECT_MARKER","REGEX_START_OF_MAIN","REGEX_END_OF_MAIN","fragments","_loop","fragmentData","len","fragmentString","replace","match","combineInjects","injects","__webpack_require__","d","__webpack_exports__","FRAGMENT_SHADER","condition","TransformFeedback","assertWebGL2Context","_Resource","stubRemovedMethods","isSupported","_this2","unused","bindOnUse","bind","_unbindBuffers","_this3","bufferName","setBuffer","_this4","_getVaryingIndex","locationOrName","_this$_getBufferParam","_getBufferParams","bufferOrParams","byteSize","byteOffset","_bindBuffer","begin","primitiveMode","POINTS","bindTransformFeedback","TRANSFORM_FEEDBACK","handle","_bindBuffers","beginTransformFeedback","endTransformFeedback","_getVaryingInfo","getVaryingInfo","bufferIndex","_this$_getBufferParam2","bindBufferRange","TRANSFORM_FEEDBACK_BUFFER","index","bindBufferBase","_createHandle","createTransformFeedback","_deleteHandle","deleteTransformFeedback","_bindHandle","Resource"],"mappings":"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","file":"3-c2d0f5ecb2519bee1e90.js","sourcesContent":["import ShaderModule from './shader-module';\nimport {assert} from '../utils';\n\nexport default class ShaderModuleRegistry {\n  constructor() {\n    this.shaderModules = {};\n    this.defaultShaderModules = [];\n  }\n\n  setDefaultShaderModules(modules) {\n    this.defaultShaderModules = this.resolveModules(modules);\n  }\n\n  getDefaultShaderModules() {\n    return this.defaultShaderModules;\n  }\n\n  registerShaderModules(shaderModuleList, {ignoreMultipleRegistrations = false} = {}) {\n    for (const shaderModule of shaderModuleList) {\n      this._registerShaderModule(shaderModule, ignoreMultipleRegistrations);\n    }\n  }\n\n  getShaderModule(moduleOrName) {\n    // Check if \"inline\" module, return it\n    if (moduleOrName instanceof ShaderModule) {\n      return moduleOrName;\n    }\n\n    // Check if module descriptor\n    if (typeof moduleOrName !== 'string') {\n      return this._registerShaderModule(moduleOrName, true);\n    }\n\n    // Module name - Look up module\n    const module = this.shaderModules[moduleOrName];\n    if (!module) {\n      assert(false, `Unknown shader module ${moduleOrName}`);\n    }\n    return module;\n  }\n\n  // registers any supplied modules, resolves any names into modules\n  // returns a list of modules\n  resolveModules(modules) {\n    return modules.map(moduleOrName => this.getShaderModule(moduleOrName));\n  }\n\n  // PRIVATE API\n\n  _registerShaderModule(module, ignoreMultipleRegistrations = false) {\n    // Check if \"inline\" module, return it\n    if (module instanceof ShaderModule) {\n      return module;\n    }\n\n    assert(module.name, 'shader module has no name');\n\n    if (!this.shaderModules[module.name] || ignoreMultipleRegistrations) {\n      // if ignoreMultipleRegistrations = true, we allow module to be re-registered\n      module = new ShaderModule(module);\n      module.dependencies = this.resolveModules(module.dependencies);\n      this.shaderModules[module.name] = module;\n    } else {\n      // TODO - instead verify that definition is not changing...\n      throw new Error(`shader module ${module.name} already registered`);\n    }\n\n    return this.shaderModules[module.name];\n  }\n}\n","import ShaderModuleRegistry from './shader-module-registry';\n\nconst shaderModuleRegistry = new ShaderModuleRegistry();\n\n/**\n * Registers an array of default shader modules. These will be concatenated\n * automatically at the end of any shader module list passed to\n * `assembleShaders` (plus `resolveModules` and `getShaderDependencies`)\n * @param {Object[]} modules - Array of shader modules\n */\nexport function setDefaultShaderModules(modules) {\n  shaderModuleRegistry.setDefaultShaderModules(modules);\n}\n\nexport function getDefaultShaderModules() {\n  return shaderModuleRegistry.getDefaultShaderModules();\n}\n\n/**\n * Registers an array of shader modules\n * @param {Object[]} shaderModuleList - Array of shader modules\n */\nexport function registerShaderModules(\n  shaderModuleList,\n  {ignoreMultipleRegistrations = false} = {}\n) {\n  shaderModuleRegistry.registerShaderModules(shaderModuleList, {ignoreMultipleRegistrations});\n}\n\n// registers any supplied modules and returns a list of module names\nexport function resolveModules(modules) {\n  modules = modules.concat(shaderModuleRegistry.defaultShaderModules);\n  modules = shaderModuleRegistry.resolveModules(modules);\n  return getShaderDependencies(modules);\n}\n\n// Looks up a moduleName among registered modules and returns definition.\n// If \"inline\" module, returns it directly\nexport function getShaderModule(moduleOrName) {\n  return shaderModuleRegistry.getShaderModule(moduleOrName);\n}\n\n/**\n * Takes a list of shader module names and returns a new list of\n * shader module names that includes all dependencies, sorted so\n * that modules that are dependencies of other modules come first.\n *\n * If the shader glsl code from the returned modules is concatenated\n * in the reverse order, it is guaranteed that all functions be resolved and\n * that all function and variable definitions come before use.\n *\n * @param {String[]} modules - Array of modules (inline modules or module names)\n * @return {String[]} - Array of modules\n */\nfunction getShaderDependencies(modules) {\n  const moduleMap = {};\n  const moduleDepth = {};\n  getDependencyGraph({modules, level: 0, moduleMap, moduleDepth});\n\n  // Return a reverse sort so that dependencies come before the modules that use them\n  return Object.keys(moduleDepth)\n    .sort((a, b) => moduleDepth[b] - moduleDepth[a])\n    .map(name => moduleMap[name]);\n}\n\n/**\n * Recursively checks module dpendencies to calculate dependency\n * level of each module.\n *\n * @param {String[]} modules - Array of modules\n * @param {Number} level - Current level\n * @return {result} - Map of module name to its level\n */\n// Adds another level of dependencies to the result map\nfunction getDependencyGraph({modules, level, moduleMap, moduleDepth}) {\n  if (level >= 5) {\n    throw new Error('Possible loop in shader dependency graph');\n  }\n\n  // Update level on all current modules\n  for (const module of modules) {\n    moduleMap[module.name] = module;\n    if (moduleDepth[module.name] === undefined || moduleDepth[module.name] < level) {\n      moduleDepth[module.name] = level;\n    }\n  }\n\n  // Recurse\n  for (const module of modules) {\n    if (module.dependencies) {\n      getDependencyGraph({modules: module.dependencies, level: level + 1, moduleMap, moduleDepth});\n    }\n  }\n}\n\nexport const TEST_EXPORTS = {\n  getShaderDependencies,\n  getDependencyGraph\n};\n","// Feature detection for WebGL\n//\n// Provides a function that enables simple checking of which WebGL features are\n// available in an WebGL1 or WebGL2 environment.\n\n/* eslint-disable no-inline-comments, max-len */\nimport isOldIE from './is-old-ie';\nimport assert from './assert';\n\nconst GL_VENDOR = 0x1f00;\nconst GL_RENDERER = 0x1f01;\nconst GL_VERSION = 0x1f02;\nconst GL_SHADING_LANGUAGE_VERSION = 0x8b8c;\n\n// Defines luma.gl \"feature\" names and semantics\nconst WEBGL_FEATURES = {\n  // GLSL extensions\n  GLSL_FRAG_DATA: ['WEBGL_draw_buffers', true], // TODO - name makes no sense in GLSL 3.00\n  GLSL_FRAG_DEPTH: ['EXT_frag_depth', true],\n  GLSL_DERIVATIVES: ['OES_standard_derivatives', true],\n  GLSL_TEXTURE_LOD: ['EXT_shader_texture_lod', true]\n};\n\n// Create a key-mirrored FEATURES array\nconst FEATURES = {};\nObject.keys(WEBGL_FEATURES).forEach(key => {\n  FEATURES[key] = key;\n});\n\nexport {FEATURES};\n\nfunction isWebGL2(gl) {\n  return Boolean(gl && gl._version === 2);\n}\n\nexport function getContextInfo(gl) {\n  const info = gl.getExtension('WEBGL_debug_renderer_info');\n  const vendor = gl.getParameter((info && info.UNMASKED_VENDOR_WEBGL) || GL_VENDOR);\n  const renderer = gl.getParameter((info && info.UNMASKED_RENDERER_WEBGL) || GL_RENDERER);\n  const gpuVendor = identifyGPUVendor(vendor, renderer);\n  const gpuInfo = {\n    gpuVendor,\n    vendor,\n    renderer,\n    version: gl.getParameter(GL_VERSION),\n    shadingLanguageVersion: gl.getParameter(GL_SHADING_LANGUAGE_VERSION)\n  };\n  return gpuInfo;\n}\n\nfunction identifyGPUVendor(vendor, renderer) {\n  if (vendor.match(/NVIDIA/i) || renderer.match(/NVIDIA/i)) {\n    return 'NVIDIA';\n  }\n  if (vendor.match(/INTEL/i) || renderer.match(/INTEL/i)) {\n    return 'INTEL';\n  }\n  if (\n    vendor.match(/AMD/i) ||\n    renderer.match(/AMD/i) ||\n    vendor.match(/ATI/i) ||\n    renderer.match(/ATI/i)\n  ) {\n    return 'AMD';\n  }\n  return 'UNKNOWN GPU';\n}\n\nconst compiledGlslExtensions = {};\n\n// Enables feature detection in IE11 due to a bug where gl.getExtension may return true\n// but fail to compile when the extension is enabled in the shader. Specifically,\n// the OES_standard_derivatives and WEBGL_draw_buffers extensions fails to compile in IE11 even though its included\n// in the list of supported extensions.\n// opts allows user agent to be overridden for testing\n/*\n* Inputs :\n*  gl : WebGL context\n*  cap : Key of WEBGL_FEATURES object identifying the extension\n*  opts :\n*   behavior : behavor of extension to be tested, by defualt `enable` is used\n* Returns : true, if shader is compiled successfully, false otherwise\n*/\nexport function canCompileGLGSExtension(gl, cap, opts = {}) {\n  const feature = WEBGL_FEATURES[cap];\n  assert(feature, cap);\n\n  if (!isOldIE(opts)) {\n    return true;\n  }\n\n  if (cap in compiledGlslExtensions) {\n    return compiledGlslExtensions[cap];\n  }\n\n  const extensionName = feature[0];\n  const behavior = opts.behavior || 'enable';\n  const source = `#extension GL_${extensionName} : ${behavior}\\nvoid main(void) {}`;\n\n  const shader = gl.createShader(gl.VERTEX_SHADER);\n  gl.shaderSource(shader, source);\n  gl.compileShader(shader);\n  const canCompile = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\n  gl.deleteShader(shader);\n  compiledGlslExtensions[cap] = canCompile;\n  return canCompile;\n}\n\n// TODO - cache the value\nfunction getFeature(gl, cap) {\n  const feature = WEBGL_FEATURES[cap];\n  assert(feature, cap);\n\n  // Get extension name from table\n  const extensionName = isWebGL2(gl) ? feature[1] || feature[0] : feature[0];\n\n  // Check if the value is dependent on checking an extension\n  const value =\n    typeof extensionName === 'string' ? Boolean(gl.getExtension(extensionName)) : extensionName;\n\n  assert(value === false || value === true);\n\n  return value;\n}\n\nexport function hasFeatures(gl, features) {\n  features = Array.isArray(features) ? features : [features];\n  return features.every(feature => getFeature(gl, feature));\n}\n","/* global window */\n// opts allows user agent to be overridden for testing\nexport default function isOldIE(opts = {}) {\n  const navigator = typeof window !== 'undefined' ? window.navigator || {} : {};\n  const userAgent = opts.userAgent || navigator.userAgent || '';\n  // We only care about older versions of IE (IE 11 and below). Newer versions of IE (Edge)\n  // have much better web standards support.\n  const isMSIE = userAgent.indexOf('MSIE ') !== -1;\n  const isTrident = userAgent.indexOf('Trident/') !== -1;\n  return isMSIE || isTrident;\n}\n","import {getContextInfo, hasFeatures, canCompileGLGSExtension, FEATURES} from '../utils/webgl-info';\n\nexport function getPlatformShaderDefines(gl) {\n  const debugInfo = getContextInfo(gl);\n\n  switch (debugInfo.gpuVendor.toLowerCase()) {\n    case 'nvidia':\n      return `\\\n#define NVIDIA_GPU\n// Nvidia optimizes away the calculation necessary for emulated fp64\n#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1\n`;\n\n    case 'intel':\n      return `\\\n#define INTEL_GPU\n// Intel optimizes away the calculation necessary for emulated fp64\n#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1\n// Intel's built-in 'tan' function doesn't have acceptable precision\n#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1\n// Intel GPU doesn't have full 32 bits precision in same cases, causes overflow\n#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1\n`;\n\n    case 'amd':\n      // AMD Does not eliminate fp64 code\n      return `\\\n#define AMD_GPU\n`;\n\n    default:\n      // We don't know what GPU it is, could be that the GPU driver or\n      // browser is not implementing UNMASKED_RENDERER constant and not\n      // reporting a correct name\n      return `\\\n#define DEFAULT_GPU\n// Prevent driver from optimizing away the calculation necessary for emulated fp64\n#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1\n// Intel's built-in 'tan' function doesn't have acceptable precision\n#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1\n// Intel GPU doesn't have full 32 bits precision in same cases, causes overflow\n#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1\n`;\n  }\n}\n\nexport function getVersionDefines(gl, glslVersion, isFragment) {\n  // Add shadertools defines to let shaders portably v1/v3 check for features\n  let versionDefines = `\\\n#if (__VERSION__ > 120)\n\n# define FRAG_DEPTH\n# define DERIVATIVES\n# define DRAW_BUFFERS\n# define TEXTURE_LOD\n\n#endif // __VERSION\n`;\n\n  if (hasFeatures(gl, FEATURES.GLSL_FRAG_DEPTH)) {\n    versionDefines += `\\\n// FRAG_DEPTH => gl_FragDepth is available\n#ifdef GL_EXT_frag_depth\n#extension GL_EXT_frag_depth : enable\n# define FRAG_DEPTH\n# define gl_FragDepth gl_FragDepthEXT\n#endif\n`;\n  }\n  if (\n    hasFeatures(gl, FEATURES.GLSL_DERIVATIVES) &&\n    canCompileGLGSExtension(gl, FEATURES.GLSL_DERIVATIVES)\n  ) {\n    versionDefines += `\\\n// DERIVATIVES => dxdF, dxdY and fwidth are available\n#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives : enable\n# define DERIVATIVES\n#endif\n`;\n  }\n  if (\n    hasFeatures(gl, FEATURES.GLSL_FRAG_DATA) &&\n    canCompileGLGSExtension(gl, FEATURES.GLSL_FRAG_DATA, {behavior: 'require'})\n  ) {\n    versionDefines += `\\\n// DRAW_BUFFERS => gl_FragData[] is available\n#ifdef GL_EXT_draw_buffers\n#extension GL_EXT_draw_buffers : require\n#define DRAW_BUFFERS\n#endif\n`;\n  }\n  if (hasFeatures(gl, FEATURES.GLSL_TEXTURE_LOD)) {\n    versionDefines += `\\\n// TEXTURE_LOD => texture2DLod etc are available\n#ifdef GL_EXT_shader_texture_lod\n#extension GL_EXT_shader_texture_lod : enable\n# define TEXTURE_LOD\n#define texture2DLod texture2DLodEXT\n#define texture2DProjLod texture2DProjLodEXT\n#define texture2DProjLod texture2DProjLodEXT\n#define textureCubeLod textureCubeLodEXT\n#define texture2DGrad texture2DGradEXT\n#define texture2DProjGrad texture2DProjGradEXT\n#define texture2DProjGrad texture2DProjGradEXT\n#define textureCubeGrad textureCubeGradEXT\n#endif\n`;\n  }\n  return versionDefines;\n}\n","import {VERTEX_SHADER, FRAGMENT_SHADER} from './constants';\nimport {resolveModules, getShaderModule} from './resolve-modules';\nimport {getPlatformShaderDefines, getVersionDefines} from './platform-defines';\nimport injectShader, {DECLARATION_INJECT_MARKER} from './inject-shader';\nimport {assert} from '../utils';\n/* eslint-disable max-depth, complexity */\n\nconst INJECT_SHADER_DECLARATIONS = `\\n\\n${DECLARATION_INJECT_MARKER}\\n\\n`;\n\nconst SHADER_TYPE = {\n  [VERTEX_SHADER]: 'vertex',\n  [FRAGMENT_SHADER]: 'fragment'\n};\n\nconst HOOK_FUNCTIONS = {\n  [VERTEX_SHADER]: {},\n  [FRAGMENT_SHADER]: {}\n};\n\nconst MODULE_INJECTIONS = {};\n\n// Precision prologue to inject before functions are injected in shader\n// TODO - extract any existing prologue in the fragment source and move it up...\nconst FRAGMENT_SHADER_PROLOGUE = `\\\nprecision highp float;\n\n`;\n\nexport function createShaderHook(hook, opts = {}) {\n  hook = hook.trim();\n  const [stage, signature] = hook.split(':');\n  const name = hook.replace(/\\(.+/, '');\n  HOOK_FUNCTIONS[stage][name] = Object.assign(opts, {signature});\n}\n\nexport function createModuleInjection(moduleName, opts) {\n  const {hook, injection, order = 0} = opts;\n  const shaderStage = hook.slice(0, 2);\n\n  MODULE_INJECTIONS[moduleName] = MODULE_INJECTIONS[moduleName] || {};\n  MODULE_INJECTIONS[moduleName][shaderStage] = MODULE_INJECTIONS[moduleName][shaderStage] || {};\n\n  assert(!MODULE_INJECTIONS[moduleName][shaderStage][hook], 'Module injection already created');\n\n  MODULE_INJECTIONS[moduleName][shaderStage][hook] = {\n    injection,\n    order\n  };\n}\n\n// Inject a list of modules\nexport function assembleShaders(gl, opts) {\n  const {vs, fs} = opts;\n  const modules = resolveModules(opts.modules || []);\n  return {\n    gl,\n    vs: assembleShader(gl, Object.assign({}, opts, {source: vs, type: VERTEX_SHADER, modules})),\n    fs: assembleShader(gl, Object.assign({}, opts, {source: fs, type: FRAGMENT_SHADER, modules})),\n    getUniforms: assembleGetUniforms(modules),\n    modules: assembleModuleMap(modules)\n  };\n}\n\n// Pulls together complete source code for either a vertex or a fragment shader\n// adding prologues, requested module chunks, and any final injections.\nfunction assembleShader(\n  gl,\n  {id, source, type, modules, defines = {}, inject = {}, prologue = true, log}\n) {\n  assert(typeof source === 'string', 'shader source must be a string');\n\n  const isVertex = type === VERTEX_SHADER;\n\n  const sourceLines = source.split('\\n');\n  let glslVersion = 100;\n  let versionLine = '';\n  let coreSource = source;\n  // Extract any version directive string from source.\n  // TODO : keep all pre-processor statements at the begining of the shader.\n  if (sourceLines[0].indexOf('#version ') === 0) {\n    glslVersion = 300; // TODO - regexp that matches atual version number\n    versionLine = sourceLines[0];\n    coreSource = sourceLines.slice(1).join('\\n');\n  }\n\n  // Combine Module and Application Defines\n  const allDefines = {};\n  modules.forEach(module => {\n    Object.assign(allDefines, module.getDefines());\n  });\n  Object.assign(allDefines, defines);\n\n  // Add platform defines (use these to work around platform-specific bugs and limitations)\n  // Add common defines (GLSL version compatibility, feature detection)\n  // Add precision declaration for fragment shaders\n  let assembledSource = prologue\n    ? `\\\n${versionLine}\n${getShaderName({id, source, type})}\n${getShaderType({type})}\n${getPlatformShaderDefines(gl)}\n${getVersionDefines(gl, glslVersion, !isVertex)}\n${getApplicationDefines(allDefines)}\n${isVertex ? '' : FRAGMENT_SHADER_PROLOGUE}\n`\n    : `${versionLine}\n`;\n\n  // Add source of dependent modules in resolved order\n  let injectStandardStubs = false;\n  const hookInjections = {};\n  const mainInjections = {};\n\n  for (const key in inject) {\n    const injection =\n      typeof inject[key] === 'string' ? {injection: inject[key], order: 0} : inject[key];\n    if (key.match(/^(v|f)s:/)) {\n      if (key[3] === '#') {\n        mainInjections[key] = [injection];\n      } else {\n        hookInjections[key] = [injection];\n      }\n    } else {\n      // Regex injection\n      mainInjections[key] = [injection];\n    }\n  }\n\n  for (const module of modules) {\n    switch (module.name) {\n      case 'inject':\n        injectStandardStubs = true;\n        break;\n\n      default:\n        if (log) {\n          module.checkDeprecations(coreSource, log);\n        }\n        const moduleSource = module.getModuleSource(type, glslVersion);\n        // Add the module source, and a #define that declares it presence\n        assembledSource += moduleSource;\n\n        if (MODULE_INJECTIONS[module.name]) {\n          const injections = MODULE_INJECTIONS[module.name][type];\n          for (const key in injections) {\n            if (key.match(/^(v|f)s:#/)) {\n              mainInjections[key] = mainInjections[key] || [];\n              mainInjections[key].push(injections[key]);\n            } else {\n              hookInjections[key] = hookInjections[key] || [];\n              hookInjections[key].push(injections[key]);\n            }\n          }\n        }\n    }\n  }\n\n  // For injectShader\n  assembledSource += INJECT_SHADER_DECLARATIONS;\n\n  assembledSource += getHookFunctions(type, hookInjections);\n\n  // Add the version directive and actual source of this shader\n  assembledSource += coreSource;\n\n  // Apply any requested shader injections\n  assembledSource = injectShader(assembledSource, type, mainInjections, injectStandardStubs);\n\n  return assembledSource;\n}\n\n// Returns a combined `getUniforms` covering the options for all the modules,\n// the created function will pass on options to the inidividual `getUniforms`\n// function of each shader module and combine the results into one object that\n// can be passed to setUniforms.\nfunction assembleGetUniforms(modules) {\n  return function getUniforms(opts) {\n    const uniforms = {};\n    for (const module of modules) {\n      // `modules` is already sorted by dependency level. This guarantees that\n      // modules have access to the uniforms that are generated by their dependencies.\n      const moduleUniforms = module.getUniforms(opts, uniforms);\n      Object.assign(uniforms, moduleUniforms);\n    }\n    return uniforms;\n  };\n}\n\n// Returns a map with module names as keys, resolving to their module definitions\n// The presence of a key indicates that the module is available in this program,\n// whether directly included, or through a dependency of some other module\nfunction assembleModuleMap(modules) {\n  const result = {};\n  for (const moduleName of modules) {\n    const shaderModule = getShaderModule(moduleName);\n    result[moduleName] = shaderModule;\n  }\n  return result;\n}\n\nfunction getShaderType({type}) {\n  return `\n#define SHADER_TYPE_${SHADER_TYPE[type].toUpperCase()}\n`;\n}\n\n// Generate \"glslify-compatible\" SHADER_NAME defines\n// These are understood by the GLSL error parsing function\n// If id is provided and no SHADER_NAME constant is present in source, create one\nfunction getShaderName({id, source, type}) {\n  const injectShaderName = id && typeof id === 'string' && source.indexOf('SHADER_NAME') === -1;\n  return injectShaderName\n    ? `\n#define SHADER_NAME ${id}_${SHADER_TYPE[type]}\n\n`\n    : '';\n}\n\n// Generates application defines from an object\nfunction getApplicationDefines(defines = {}) {\n  let count = 0;\n  let sourceText = '';\n  for (const define in defines) {\n    if (count === 0) {\n      sourceText += '\\n// APPLICATION DEFINES\\n';\n    }\n    count++;\n\n    const value = defines[define];\n    if (value || Number.isFinite(value)) {\n      sourceText += `#define ${define.toUpperCase()} ${defines[define]}\\n`;\n    }\n  }\n  if (count === 0) {\n    sourceText += '\\n';\n  }\n  return sourceText;\n}\n\nfunction getHookFunctions(shaderStage, hookInjections) {\n  let result = '';\n  const hookFunctions = HOOK_FUNCTIONS[shaderStage];\n  for (const hookName in hookFunctions) {\n    const hookFunction = hookFunctions[hookName];\n    result += `void ${hookFunction.signature} {\\n`;\n    if (hookFunction.header) {\n      result += `  ${hookFunction.header}`;\n    }\n    if (hookInjections[hookName]) {\n      const injections = hookInjections[hookName];\n      injections.sort((a, b) => a.order - b.order);\n      for (const injection of injections) {\n        result += `  ${injection.injection}\\n`;\n      }\n    }\n    if (hookFunction.footer) {\n      result += `  ${hookFunction.footer}`;\n    }\n    result += '}\\n';\n  }\n\n  return result;\n}\n","import GL from '@luma.gl/constants';\nimport {Buffer} from '@luma.gl/webgl';\nimport {assert} from '../utils';\n\n// Support for mapping new geometries with glTF attribute names to \"classic\" luma.gl shader names\nconst GLTF_TO_LUMA_ATTRIBUTE_MAP = {\n  POSITION: 'positions',\n  NORMAL: 'normals',\n  COLOR_0: 'colors',\n  TEXCOORD_0: 'texCoords',\n  TEXCOORD_1: 'texCoords1',\n  TEXCOORD_2: 'texCoords2'\n};\n\nexport function getBuffersFromGeometry(gl, geometry, options) {\n  const buffers = {};\n  let indices = geometry.indices;\n\n  for (const name in geometry.attributes) {\n    const attribute = geometry.attributes[name];\n    const remappedName = mapAttributeName(name, options);\n\n    if (name === 'indices') {\n      indices = attribute;\n    } else if (attribute.constant) {\n      buffers[remappedName] = attribute.value;\n    } else {\n      const typedArray = attribute.value;\n      // Create accessor by copying the attribute and removing `value``\n      const accessor = {...attribute};\n      delete accessor.value;\n      buffers[remappedName] = [new Buffer(gl, typedArray), accessor];\n\n      inferAttributeAccessor(name, accessor);\n    }\n  }\n\n  if (indices) {\n    const data = indices.value || indices;\n    assert(\n      data instanceof Uint16Array || data instanceof Uint32Array,\n      'attribute array for \"indices\" must be of integer type'\n    );\n    const accessor = {\n      size: 1,\n      isIndexed: indices.isIndexed === undefined ? true : indices.isIndexed\n    };\n    buffers.indices = [\n      new Buffer(gl, {\n        data,\n        target: GL.ELEMENT_ARRAY_BUFFER\n      }),\n      accessor\n    ];\n  }\n\n  return buffers;\n}\n\nfunction mapAttributeName(name, options) {\n  const {attributeMap = GLTF_TO_LUMA_ATTRIBUTE_MAP} = options || {};\n  return (attributeMap && attributeMap[name]) || name;\n}\n\n// Check for well known attribute names\n// eslint-disable-next-line complexity\nexport function inferAttributeAccessor(attributeName, attribute) {\n  let category;\n  switch (attributeName) {\n    case 'texCoords':\n    case 'texCoord1':\n    case 'texCoord2':\n    case 'texCoord3':\n      category = 'uvs';\n      break;\n    case 'vertices':\n    case 'positions':\n    case 'normals':\n    case 'pickingColors':\n      category = 'vectors';\n      break;\n    default:\n  }\n\n  // Check for categorys\n  switch (category) {\n    case 'vectors':\n      attribute.size = attribute.size || 3;\n      break;\n    case 'uvs':\n      attribute.size = attribute.size || 2;\n      break;\n    default:\n  }\n\n  assert(Number.isFinite(attribute.size), `attribute ${attributeName} needs size`);\n}\n","// TODO / DEPRECATED - delete when confident that probe.gl logging implements all opts\n/* eslint-disable no-console */\nfunction formatArrayValue(v, opts) {\n  const {maxElts = 16, size = 1} = opts;\n  let string = '[';\n  for (let i = 0; i < v.length && i < maxElts; ++i) {\n    if (i > 0) {\n      string += `,${i % size === 0 ? ' ' : ''}`;\n    }\n    string += formatValue(v[i], opts);\n  }\n  const terminator = v.length > maxElts ? '...' : ']';\n  return `${string}${terminator}`;\n}\n\nexport function formatValue(v, opts = {}) {\n  const EPSILON = 1e-16;\n  const {isInteger = false} = opts;\n  if (Array.isArray(v) || ArrayBuffer.isView(v)) {\n    return formatArrayValue(v, opts);\n  }\n  if (!Number.isFinite(v)) {\n    return String(v);\n  }\n  if (Math.abs(v) < EPSILON) {\n    return isInteger ? '0' : '0.';\n  }\n  if (isInteger) {\n    return v.toFixed(0);\n  }\n  if (Math.abs(v) > 100 && Math.abs(v) < 10000) {\n    return v.toFixed(0);\n  }\n  const string = v.toPrecision(2);\n  const decimal = string.indexOf('.0');\n  return decimal === string.length - 2 ? string.slice(0, -1) : string;\n}\n","import Buffer from '../classes/buffer';\nimport {getKey} from '../webgl-utils';\nimport {getCompositeGLType} from '../webgl-utils/attribute-utils';\nimport {formatValue} from '../utils';\n\n// Creates object suitable as input for console.table\nexport function getDebugTableForVertexArray({vertexArray, header = 'Attributes'} = {}) {\n  if (!vertexArray.configuration) {\n    return {};\n  }\n\n  const table = {}; // {[header]: {}};\n\n  // Add index (elements) if available\n  if (vertexArray.elements) {\n    // const elements = Object.assign({size: 1}, vertexArray.elements);\n    table.ELEMENT_ARRAY_BUFFER = getDebugTableRow(vertexArray, vertexArray.elements, null, header);\n  }\n\n  // Add used attributes\n  const attributes = vertexArray.values;\n\n  for (const attributeLocation in attributes) {\n    const info = vertexArray._getAttributeInfo(attributeLocation);\n    if (info) {\n      let rowHeader = `${attributeLocation}: ${info.name}`;\n      const accessor = vertexArray.accessors[info.location];\n      if (accessor) {\n        rowHeader = `${attributeLocation}: ${getGLSLDeclaration(info.name, accessor)}`;\n      }\n      table[rowHeader] = getDebugTableRow(\n        vertexArray,\n        attributes[attributeLocation],\n        accessor,\n        header\n      );\n    }\n  }\n\n  return table;\n}\n\n/* eslint-disable max-statements */\nfunction getDebugTableRow(vertexArray, attribute, accessor, header) {\n  // const round = xnum => Math.round(num * 10) / 10;\n  const {gl} = vertexArray;\n\n  let type = 'NOT PROVIDED';\n  let size = 'N/A';\n  let verts = 'N/A';\n  let bytes = 'N/A';\n\n  let isInteger;\n  let marker;\n  let value;\n\n  if (accessor) {\n    type = accessor.type;\n    size = accessor.size;\n\n    // Generate a type name by dropping Array from Float32Array etc.\n    type = String(type).replace('Array', '');\n\n    // Look for 'nt' to detect integer types, e.g. Int32Array, Uint32Array\n    isInteger = type.indexOf('nt') !== -1;\n  }\n\n  if (attribute instanceof Buffer) {\n    const buffer = attribute;\n\n    const {data, modified} = buffer.getDebugData();\n    marker = modified ? '*' : '';\n\n    value = data;\n    bytes = buffer.byteLength;\n    verts = bytes / data.BYTES_PER_ELEMENT / size;\n\n    let format;\n\n    if (accessor) {\n      const instanced = accessor.divisor > 0;\n      format = `${instanced ? 'I ' : 'P '} ${verts} (x${size}=${bytes} bytes ${getKey(gl, type)})`;\n    } else {\n      // element buffer\n      isInteger = true;\n      format = `${bytes} bytes`;\n    }\n\n    return {\n      [header]: `${marker}${formatValue(value, {size, isInteger})}`,\n      'Format ': format\n    };\n  }\n\n  // CONSTANT VALUE\n  value = attribute;\n  size = attribute.length;\n  // Generate a type name by dropping Array from Float32Array etc.\n  type = String(attribute.constructor.name).replace('Array', '');\n  // Look for 'nt' to detect integer types, e.g. Int32Array, Uint32Array\n  isInteger = type.indexOf('nt') !== -1;\n\n  return {\n    [header]: `${formatValue(value, {size, isInteger})} (constant)`,\n    'Format ': `${size}x${type} (constant)`\n  };\n}\n/* eslint-ensable max-statements */\n\nfunction getGLSLDeclaration(name, accessor) {\n  const {type, size} = accessor;\n  const typeAndName = getCompositeGLType(type, size);\n  if (typeAndName) {\n    return `${name} (${typeAndName.name})`;\n  }\n  return name;\n}\n","import {formatValue, assert} from '../utils';\n\n// Prepares a table suitable for console.table\n/* eslint-disable max-statements, complexity */\nexport function getDebugTableForUniforms({\n  header = 'Uniforms',\n  program,\n  uniforms,\n  undefinedOnly = false\n} = {}) {\n  assert(program);\n\n  const SHADER_MODULE_UNIFORM_REGEXP = '.*_.*';\n  const PROJECT_MODULE_UNIFORM_REGEXP = '.*Matrix'; // TODO - Use explicit list\n\n  const uniformLocations = program._uniformSetters;\n  const table = {}; // {[header]: {}};\n\n  // Add program's provided uniforms (in alphabetical order)\n  const uniformNames = Object.keys(uniformLocations).sort();\n\n  let count = 0;\n\n  // First add non-underscored uniforms (assumed not coming from shader modules)\n  for (const uniformName of uniformNames) {\n    if (\n      !uniformName.match(SHADER_MODULE_UNIFORM_REGEXP) &&\n      !uniformName.match(PROJECT_MODULE_UNIFORM_REGEXP)\n    ) {\n      if (addUniformToTable({table, header, uniforms, uniformName, undefinedOnly})) {\n        count++;\n      }\n    }\n  }\n\n  // add underscored uniforms (assumed from shader modules)\n  for (const uniformName of uniformNames) {\n    if (uniformName.match(PROJECT_MODULE_UNIFORM_REGEXP)) {\n      if (addUniformToTable({table, header, uniforms, uniformName, undefinedOnly})) {\n        count++;\n      }\n    }\n  }\n\n  for (const uniformName of uniformNames) {\n    if (!table[uniformName]) {\n      if (addUniformToTable({table, header, uniforms, uniformName, undefinedOnly})) {\n        count++;\n      }\n    }\n  }\n\n  // Create a table of unused uniforms\n  let unusedCount = 0;\n  const unusedTable = {};\n  if (!undefinedOnly) {\n    for (const uniformName in uniforms) {\n      const uniform = uniforms[uniformName];\n      if (!table[uniformName]) {\n        unusedCount++;\n        unusedTable[uniformName] = {\n          Type: `NOT USED: ${uniform}`,\n          [header]: formatValue(uniform)\n        };\n      }\n    }\n  }\n\n  return {table, count, unusedTable, unusedCount};\n}\n\n// Helper\nfunction addUniformToTable({table, header, uniforms, uniformName, undefinedOnly}) {\n  const value = uniforms[uniformName];\n  const isDefined = isUniformDefined(value);\n  if (!undefinedOnly || !isDefined) {\n    table[uniformName] = {\n      // Add program's unprovided uniforms\n      [header]: isDefined ? formatValue(value) : 'N/A',\n      'Uniform Type': isDefined ? value : 'NOT PROVIDED'\n    };\n    return true;\n  }\n  return false;\n}\n\nfunction isUniformDefined(value) {\n  return value !== undefined && value !== null;\n}\n","import {getCompositeGLType} from '../webgl-utils/attribute-utils';\n\nexport function getDebugTableForProgramConfiguration(config) {\n  const table = {};\n\n  const header = `Accessors for ${config.id}`;\n\n  for (const attributeInfo of config.attributeInfos) {\n    if (attributeInfo) {\n      const glslDeclaration = getGLSLDeclaration(attributeInfo);\n      table[`in ${glslDeclaration}`] = {[header]: JSON.stringify(attributeInfo.accessor)};\n    }\n  }\n\n  for (const varyingInfo of config.varyingInfos) {\n    if (varyingInfo) {\n      const glslDeclaration = getGLSLDeclaration(varyingInfo);\n      table[`out ${glslDeclaration}`] = {[header]: JSON.stringify(varyingInfo.accessor)};\n    }\n  }\n\n  return table;\n}\n\nfunction getGLSLDeclaration(attributeInfo) {\n  const {type, size} = attributeInfo.accessor;\n  const typeAndName = getCompositeGLType(type, size);\n  if (typeAndName) {\n    return `${typeAndName.name} ${attributeInfo.name}`;\n  }\n  return attributeInfo.name;\n}\n","import seer from 'seer';\n\nimport {window} from '../utils';\n\nconst models = {};\n\n/**\n * Add a model to our cache indexed by id\n */\nexport const addModel = model => {\n  if (models[model.id]) {\n    return;\n  }\n  models[model.id] = model;\n\n  seer.listItem('luma.gl', model.id);\n};\n\n/**\n * Log a model uniforms and attributes.\n */\nexport const logModel = (model, uniforms) => {\n  if (!seer.isReady() || seer.throttle(`luma.gl:${model.id}`, 1e3)) {\n    return;\n  }\n\n  const attributesObject = model.geometry\n    ? Object.assign({}, model.geometry.attributes, model.attributes)\n    : model.attributes;\n  const uniformsObject = Object.assign({}, model.uniforms, uniforms);\n\n  seer.multiUpdate('luma.gl', model.id, [\n    {path: 'objects.uniforms', data: uniformsObject},\n    {path: 'objects.attributes', data: attributesObject}\n  ]);\n};\n\n/**\n * Remove a previously set model from the cache\n */\nexport const removeModel = id => {\n  delete models[id];\n  seer.deleteItem('luma.gl', id);\n};\n\n/**\n * Recursively traverse an object given a path of properties and set the given value\n */\nconst recursiveSet = (obj, path, value) => {\n  if (!obj) {\n    return;\n  }\n\n  if (path.length > 1) {\n    recursiveSet(obj[path[0]], path.slice(1), value);\n  } else {\n    obj[path[0]] = value;\n  }\n};\n\nconst overrides = new Map();\n\n/**\n * Create an override on the specify layer, indexed by a valuePath array.\n * Do nothing in case Seer as not been initialized to prevent any preformance drawback.\n */\nexport const setOverride = (id, valuePath, value) => {\n  if (!window.__SEER_INITIALIZED__) {\n    return;\n  }\n\n  if (!overrides.has(id)) {\n    overrides.set(id, new Map());\n  }\n\n  const uniforms = overrides.get(id);\n  uniforms.set(valuePath, value);\n};\n\n/**\n * Apply overrides to a specific model's uniforms\n */\nexport const getOverrides = (id, uniforms) => {\n  if (!window.__SEER_INITIALIZED__ || !id) {\n    return;\n  }\n\n  const overs = overrides.get(id);\n  if (!overs) {\n    return;\n  }\n\n  overs.forEach((value, valuePath) => {\n    recursiveSet(uniforms, valuePath, value);\n  });\n};\n\n/**\n * Listen for luma.gl edit events\n */\nseer.listenFor('luma.gl', payload => {\n  const model = models[payload.itemKey];\n  if (!model || payload.type !== 'edit' || payload.valuePath[0] !== 'uniforms') {\n    return;\n  }\n\n  const valuePath = payload.valuePath.slice(1);\n  setOverride(payload.itemKey, valuePath, payload.value);\n\n  const uniforms = model.getUniforms();\n  recursiveSet(uniforms, valuePath, payload.value);\n  model.setUniforms(uniforms);\n});\n","// Shared code between Model and MeshModel\n\nimport GL from '@luma.gl/constants';\nimport {isWebGL, Query, Program, VertexArray} from '@luma.gl/webgl';\nimport {MODULAR_SHADERS, assembleShaders} from '@luma.gl/shadertools';\nimport {\n  getDebugTableForUniforms,\n  getDebugTableForVertexArray,\n  getDebugTableForProgramConfiguration\n} from '@luma.gl/webgl';\nimport {addModel, removeModel, logModel, getOverrides} from '../debug/seer-integration';\nimport {log, isObjectEmpty, uid, assert} from '../utils';\n\nconst LOG_DRAW_PRIORITY = 2;\nconst LOG_DRAW_TIMEOUT = 10000;\n\n// Model abstract O3D Class\nexport default class BaseModel {\n  constructor(gl, props = {}) {\n    assert(isWebGL(gl));\n    const {id = uid('base-model')} = props;\n    this.id = id;\n    this.gl = gl;\n    this.id = props.id || uid('Model');\n    this.lastLogTime = 0; // TODO - move to probe.gl\n    this.initialize(props);\n    this._setBaseModelProps(props);\n  }\n\n  initialize(props) {\n    this.props = {};\n    this.program = this._createProgram(props);\n\n    // Create a vertex array configured after this program\n    this.vertexArray = new VertexArray(this.gl, {program: this.program});\n\n    // Initialize state\n    this.userData = {};\n    this.needsRedraw = true;\n\n    // Attributes and buffers\n    // Model manages auto Buffer creation from typed arrays\n    this._attributes = {}; // All attributes\n    this.attributes = {}; // User defined attributes\n\n    // Model manages uniform animation\n    this.animatedUniforms = {};\n    this.animated = false;\n    this.animationLoop = null; // if set, used as source for animationProps\n\n    this.timerQueryEnabled = false;\n    this.timeElapsedQuery = undefined;\n    this.lastQueryReturned = true;\n\n    this.stats = {\n      accumulatedFrameTime: 0,\n      averageFrameTime: 0,\n      profileFrameCount: 0\n    };\n\n    // picking options\n    this.pickable = true;\n\n    this._setBaseModelProps(props);\n\n    // Make sure we have some reasonable default uniforms in place\n    this.setUniforms(\n      Object.assign(\n        {},\n        this.getModuleUniforms(), // Get all default uniforms\n        this.getModuleUniforms(props.moduleSettings) // Get unforms for supplied parameters\n      )\n    );\n  }\n\n  setProps(props) {\n    this._setBaseModelProps(props);\n  }\n\n  delete() {\n    // delete all attributes created by this model\n    // TODO - should buffer deletes be handled by vertex array?\n    for (const key in this._attributes) {\n      if (this._attributes[key] !== this.attributes[key]) {\n        this._attributes[key].delete();\n      }\n    }\n\n    this.program.delete();\n    this.vertexArray.delete();\n\n    removeModel(this.id);\n  }\n\n  // GETTERS\n\n  isAnimated() {\n    return this.animated;\n  }\n\n  getProgram() {\n    return this.program;\n  }\n\n  getUniforms() {\n    return this.program.uniforms;\n  }\n\n  // SETTERS\n\n  // TODO - should actually set the uniforms\n  setUniforms(uniforms = {}) {\n    // Let Seer override edited uniforms\n    uniforms = Object.assign({}, uniforms);\n    getOverrides(this.id, uniforms);\n\n    // Resolve any animated uniforms so that we have an initial value\n    uniforms = this._extractAnimatedUniforms(uniforms);\n\n    this.program.setUniforms(uniforms);\n\n    return this;\n  }\n\n  updateModuleSettings(opts) {\n    const uniforms = this.getModuleUniforms(opts || {});\n    return this.setUniforms(uniforms);\n  }\n\n  // DRAW CALLS\n\n  /* eslint-disable max-statements  */\n  drawGeometry(opts = {}) {\n    const {\n      moduleSettings = null,\n      framebuffer,\n      uniforms = {},\n      attributes = {},\n      transformFeedback = this.transformFeedback,\n      parameters = {},\n      vertexArray = this.vertexArray,\n      animationProps\n    } = opts;\n\n    // Update module settings\n\n    addModel(this);\n\n    // Update model with any just provided attributes, settings or uniforms\n    this.setAttributes(attributes);\n    this.updateModuleSettings(moduleSettings);\n    this.setUniforms(uniforms);\n\n    // Animate any function valued uniforms\n    this._refreshAnimationProps(animationProps);\n\n    const logPriority = this._logDrawCallStart(2);\n\n    const drawParams = this.vertexArray.getDrawParams(this.props);\n    if (drawParams.isInstanced && !this.isInstanced) {\n      log.warn('Found instanced attributes on non-instanced model', this.id)();\n    }\n\n    const {isIndexed, indexType, indexOffset} = drawParams;\n    const {isInstanced, instanceCount} = this;\n\n    const noop = () => {};\n    const {onBeforeRender = noop, onAfterRender = noop} = this.props;\n\n    onBeforeRender();\n\n    this._timerQueryStart();\n\n    const didDraw = this.program.draw(\n      Object.assign({}, opts, {\n        logPriority,\n        uniforms: null, // Already set (may contain \"function values\" not understood by Program)\n        framebuffer,\n        parameters,\n        drawMode: this.getDrawMode(),\n        vertexCount: this.getVertexCount(),\n        vertexArray,\n        transformFeedback,\n        isIndexed,\n        indexType,\n        isInstanced,\n        instanceCount,\n        offset: isIndexed ? indexOffset : 0\n      })\n    );\n\n    this._timerQueryEnd();\n\n    onAfterRender();\n\n    this._logDrawCallEnd(logPriority, vertexArray, framebuffer);\n\n    return didDraw;\n  }\n  /* eslint-enable max-statements  */\n\n  // PRIVATE METHODS\n\n  // eslint-disable-next-line max-statements, complexity\n  _setBaseModelProps(props) {\n    Object.assign(this.props, props);\n\n    if ('uniforms' in props) {\n      this.setUniforms(props.uniforms);\n    }\n\n    if ('pickable' in props) {\n      this.pickable = props.pickable;\n    }\n\n    // if ('onBeforeRender' in props) {}\n    // if ('onAfterRender' in props) {}\n\n    // Experimental props\n    if ('timerQueryEnabled' in props) {\n      this.timerQueryEnabled = props.timerQueryEnabled && Query.isSupported(this.gl, ['timers']);\n      if (props.timerQueryEnabled && !this.timerQueryEnabled) {\n        log.warn('GPU timer not supported')();\n      }\n    }\n\n    if ('_animationProps' in props) {\n      this._setAnimationProps(props._animationProps);\n    }\n\n    if ('_animationLoop' in props) {\n      this.animationLoop = props._animationLoop;\n    }\n  }\n\n  _createProgram({\n    vs = null,\n    fs = null,\n    // 1: Modular shaders\n    modules = null,\n    defines = {},\n    inject = {},\n    shaderCache = null,\n    // TransformFeedback\n    varyings = null,\n    bufferMode = GL.SEPARATE_ATTRIBS,\n    program = null\n  }) {\n    this.getModuleUniforms = x => {};\n\n    const id = this.id;\n\n    if (!program) {\n      // Assign default shaders if none are provided\n      vs = vs || MODULAR_SHADERS.vs;\n      fs = fs || MODULAR_SHADERS.fs;\n\n      const assembleResult = assembleShaders(this.gl, {vs, fs, modules, inject, defines, log});\n      ({vs, fs} = assembleResult);\n\n      if (shaderCache) {\n        program = shaderCache.getProgram(this.gl, {id, vs, fs});\n      } else {\n        program = new Program(this.gl, {id, vs, fs, varyings, bufferMode});\n      }\n\n      this.getModuleUniforms = assembleResult.getUniforms || (x => {});\n    }\n\n    assert(program instanceof Program, 'Model needs a program');\n    return program;\n  }\n\n  // Refreshes animated uniforms, attempting to get animated props from animationLoop if registered\n  _refreshAnimationProps(animationProps) {\n    // Try to read animationProps\n    animationProps = animationProps || (this.animationLoop && this.animationLoop.animationProps);\n    if (animationProps) {\n      this._setAnimationProps(animationProps);\n    }\n  }\n\n  // Calculate new values for any function uniforms based on supplied animationProps\n  _evaluateAnimateUniforms(animationProps) {\n    if (!this.animated) {\n      return {};\n    }\n    const animatedUniforms = {};\n    for (const uniformName in this.animatedUniforms) {\n      const valueFunction = this.animatedUniforms[uniformName];\n      animatedUniforms[uniformName] = valueFunction(animationProps);\n    }\n    return animatedUniforms;\n  }\n\n  // Extracts a list of function valued uniforms, so we can update them before each draw call\n  // Also removes such uniforms from the returned list\n  _extractAnimatedUniforms(uniforms) {\n    let foundAnimated = false;\n\n    // Keep our animatedUniforms map up-to-date\n    for (const uniformName in uniforms) {\n      const newValue = uniforms[uniformName];\n      if (typeof newValue === 'function') {\n        this.animatedUniforms[uniformName] = newValue;\n        foundAnimated = true;\n      } else {\n        delete this.animatedUniforms[uniformName];\n      }\n    }\n\n    // Update animated flag: `Model` is animated if any uniforms are animated (i.e. functions)\n    this.animated = !isObjectEmpty(this.animatedUniforms);\n\n    if (!foundAnimated) {\n      return uniforms;\n    }\n\n    // If animated uniforms were found, remove them from ordinary uniform list\n    // `Program` class can't (and shouldn't) handle function valued uniforms\n    const staticUniforms = {};\n    for (const uniformName in uniforms) {\n      if (!this.animatedUniforms[uniformName]) {\n        staticUniforms[uniformName] = uniforms[uniformName];\n      }\n    }\n    return staticUniforms;\n  }\n\n  // Timer Queries\n\n  _timerQueryStart() {\n    if (this.timerQueryEnabled === true) {\n      if (!this.timeElapsedQuery) {\n        this.timeElapsedQuery = new Query(this.gl);\n      }\n      if (this.lastQueryReturned) {\n        this.lastQueryReturned = false;\n        this.timeElapsedQuery.beginTimeElapsedQuery();\n      }\n    }\n  }\n\n  _timerQueryEnd() {\n    if (this.timerQueryEnabled === true) {\n      this.timeElapsedQuery.end();\n      // TODO: Skip results if 'gl.getParameter(this.ext.GPU_DISJOINT_EXT)' returns false\n      // should this be incorporated into Query object?\n      if (this.timeElapsedQuery.isResultAvailable()) {\n        this.lastQueryReturned = true;\n        const elapsedTime = this.timeElapsedQuery.getTimerMilliseconds();\n\n        // Update stats (e.g. for seer)\n        this.stats.lastFrameTime = elapsedTime;\n        this.stats.accumulatedFrameTime += elapsedTime;\n        this.stats.profileFrameCount++;\n        this.stats.averageFrameTime =\n          this.stats.accumulatedFrameTime / this.stats.profileFrameCount;\n\n        // Log stats\n        log.log(\n          LOG_DRAW_PRIORITY,\n          `\\\nGPU time ${this.program.id}: ${this.stats.lastFrameTime}ms \\\naverage ${this.stats.averageFrameTime}ms \\\naccumulated: ${this.stats.accumulatedFrameTime}ms \\\ncount: ${this.stats.profileFrameCount}`\n        )();\n      }\n    }\n  }\n\n  _logDrawCallStart(priority) {\n    const logDrawTimeout = priority > 3 ? 0 : LOG_DRAW_TIMEOUT;\n    if (log.priority < priority || Date.now() - this.lastLogTime < logDrawTimeout) {\n      return undefined;\n    }\n\n    this.lastLogTime = Date.now();\n\n    log.group(LOG_DRAW_PRIORITY, `>>> DRAWING MODEL ${this.id}`, {collapsed: log.priority <= 2})();\n\n    return priority;\n  }\n\n  _logDrawCallEnd(priority, vertexArray, uniforms, framebuffer) {\n    // HACK: priority === undefined means logDrawCallStart didn't run\n    if (priority === undefined) {\n      return;\n    }\n\n    const attributeTable = getDebugTableForVertexArray({\n      vertexArray,\n      header: `${this.id} attributes`,\n      attributes: this._attributes\n    });\n\n    const {table: uniformTable, unusedTable, unusedCount} = getDebugTableForUniforms({\n      header: `${this.id} uniforms`,\n      program: this.program,\n      uniforms: Object.assign({}, this.program.uniforms, uniforms)\n    });\n\n    // log missing uniforms\n    const {table: missingTable, count: missingCount} = getDebugTableForUniforms({\n      header: `${this.id} uniforms`,\n      program: this.program,\n      uniforms: Object.assign({}, this.program.uniforms, uniforms),\n      undefinedOnly: true\n    });\n\n    if (missingCount > 0) {\n      log.log('MISSING UNIFORMS', Object.keys(missingTable))();\n      // log.table(priority, missingTable)();\n    }\n    if (unusedCount > 0) {\n      log.log('UNUSED UNIFORMS', Object.keys(unusedTable))();\n      // log.log(priority, 'Unused uniforms ', unusedTable)();\n    }\n\n    const configTable = getDebugTableForProgramConfiguration(this.vertexArray.configuration);\n\n    log.table(priority, attributeTable)();\n\n    log.table(priority, uniformTable)();\n\n    log.table(priority + 1, configTable)();\n\n    logModel(this, uniforms);\n\n    if (framebuffer) {\n      framebuffer.log({priority: LOG_DRAW_PRIORITY, message: `Rendered to ${framebuffer.id}`});\n    }\n\n    log.groupEnd(LOG_DRAW_PRIORITY, `>>> DRAWING MODEL ${this.id}`)();\n  }\n}\n","import GL from '@luma.gl/constants';\nimport {TransformFeedback, Buffer} from '@luma.gl/webgl';\nimport {getBuffersFromGeometry} from './model-utils';\nimport BaseModel from './base-model';\nimport {log, isObjectEmpty, uid, assert} from '../utils';\n\nconst ERR_MODEL_PARAMS = 'Model needs drawMode and vertexCount';\n\nexport default class Model extends BaseModel {\n  constructor(gl, props = {}) {\n    // Deduce a helpful id\n    const {id = uid('model')} = props;\n    super(gl, {...props, id});\n  }\n\n  initialize(props) {\n    super.initialize(props);\n\n    this.drawMode = props.drawMode !== undefined ? props.drawMode : GL.TRIANGLES;\n    this.vertexCount = props.vertexCount || 0;\n\n    // Track buffers created by setGeometry\n    this.geometryBuffers = {};\n\n    // geometry might have set drawMode and vertexCount\n    this.isInstanced = props.isInstanced || props.instanced;\n\n    this._setModelProps(props);\n\n    // TODO - just to unbreak deck.gl 7.0-beta, remove as soon as updated\n    this.geometry = {};\n\n    // assert(program || program instanceof Program);\n    assert(this.drawMode !== undefined && Number.isFinite(this.vertexCount), ERR_MODEL_PARAMS);\n  }\n\n  setProps(props) {\n    super.setProps(props);\n    this._setModelProps(props);\n  }\n\n  delete() {\n    super.delete();\n\n    this._deleteGeometryBuffers();\n  }\n\n  // GETTERS\n\n  getDrawMode() {\n    return this.drawMode;\n  }\n\n  getVertexCount() {\n    return this.vertexCount;\n  }\n\n  getInstanceCount() {\n    return this.instanceCount;\n  }\n\n  getAttributes() {\n    return this.attributes;\n  }\n\n  // SETTERS\n\n  setDrawMode(drawMode) {\n    this.drawMode = drawMode;\n    return this;\n  }\n\n  setVertexCount(vertexCount) {\n    assert(Number.isFinite(vertexCount));\n    this.vertexCount = vertexCount;\n    return this;\n  }\n\n  setInstanceCount(instanceCount) {\n    assert(Number.isFinite(instanceCount));\n    this.instanceCount = instanceCount;\n    return this;\n  }\n\n  setGeometry(geometry) {\n    this.drawMode = geometry.drawMode;\n    this.vertexCount = geometry.getVertexCount();\n\n    this._deleteGeometryBuffers();\n\n    this.geometryBuffers = getBuffersFromGeometry(this.gl, geometry);\n    this.vertexArray.setAttributes(this.geometryBuffers);\n    return this;\n  }\n\n  setAttributes(attributes = {}) {\n    // Avoid setting needsRedraw if no attributes\n    if (isObjectEmpty(attributes)) {\n      return this;\n    }\n\n    const normalizedAttributes = {};\n    for (const name in attributes) {\n      const attribute = attributes[name];\n      // The `getValue` call provides support for deck.gl `Attribute` class\n      // TODO - remove once deck refactoring completes\n      normalizedAttributes[name] = attribute.getValue ? attribute.getValue() : attribute;\n    }\n\n    this.vertexArray.setAttributes(normalizedAttributes);\n    return this;\n  }\n\n  // DRAW CALLS\n\n  draw(options = {}) {\n    return this.drawGeometry(options);\n  }\n\n  // Draw call for transform feedback\n  transform(opts = {}) {\n    const {discard = true, feedbackBuffers, unbindModels = []} = opts;\n\n    let {parameters} = opts;\n\n    if (feedbackBuffers) {\n      this._setFeedbackBuffers(feedbackBuffers);\n    }\n\n    if (discard) {\n      parameters = Object.assign({}, parameters, {[GL.RASTERIZER_DISCARD]: discard});\n    }\n\n    unbindModels.forEach(model => model.vertexArray.unbindBuffers());\n    try {\n      this.draw(Object.assign({}, opts, {parameters}));\n    } finally {\n      unbindModels.forEach(model => model.vertexArray.bindBuffers());\n    }\n\n    return this;\n  }\n\n  // DEPRECATED METHODS\n\n  render(uniforms = {}) {\n    log.warn('Model.render() is deprecated. Use Model.setUniforms() and Model.draw()')();\n    return this.setUniforms(uniforms).draw();\n  }\n\n  // PRIVATE METHODS\n\n  _setModelProps(props) {\n    // params\n    // if ('drawMode' in props) {\n    //   this.drawMode = getDrawMode(props.drawMode);\n    // }\n    // if ('vertexCount' in props) {\n    //   this.vertexCount = props.vertexCount;\n    // }\n    if ('instanceCount' in props) {\n      this.instanceCount = props.instanceCount;\n    }\n    if ('geometry' in props) {\n      this.setGeometry(props.geometry);\n    }\n\n    // webgl settings\n    if ('attributes' in props) {\n      this.setAttributes(props.attributes);\n    }\n    if ('_feedbackBuffers' in props) {\n      this._setFeedbackBuffers(props._feedbackBuffers);\n    }\n  }\n\n  _deleteGeometryBuffers() {\n    for (const name in this.geometryBuffers) {\n      // Buffer is raw value (for indices) or first element of [buffer, accessor] pair\n      const buffer = this.geometryBuffers[name][0] || this.geometryBuffers[name];\n      if (buffer instanceof Buffer) {\n        buffer.delete();\n      }\n    }\n  }\n\n  // Updates (evaluates) all function valued uniforms based on a new set of animationProps\n  // experimental\n  _setAnimationProps(animationProps) {\n    if (this.animated) {\n      assert(animationProps, 'Model.draw(): animated uniforms but no animationProps');\n      const animatedUniforms = this._evaluateAnimateUniforms(animationProps);\n      this.program.setUniforms(animatedUniforms);\n    }\n  }\n\n  // Transform Feedback\n\n  _setFeedbackBuffers(feedbackBuffers = {}) {\n    // Avoid setting needsRedraw if no feedbackBuffers\n    if (isObjectEmpty(feedbackBuffers)) {\n      return this;\n    }\n\n    const {gl} = this.program;\n    this.transformFeedback =\n      this.transformFeedback ||\n      new TransformFeedback(gl, {\n        program: this.program\n      });\n\n    this.transformFeedback.setBuffers(feedbackBuffers);\n    return this;\n  }\n}\n","// Transpiles shader source code to target GLSL version\n// Note: We always run transpiler even if same version e.g. 3.00 => 3.00\n// RFC: https://github.com/uber/luma.gl/blob/7.0-release/dev-docs/RFCs/v6.0/portable-glsl-300-rfc.md\nexport default function transpileShader(source, targetGLSLVersion, isVertex) {\n  switch (targetGLSLVersion) {\n    case 300:\n      return isVertex ? convertVertexShaderTo300(source) : convertFragmentShaderTo300(source);\n    case 100:\n      return isVertex ? convertVertexShaderTo100(source) : convertFragmentShaderTo100(source);\n    default:\n      throw new Error(`unknown GLSL version ${targetGLSLVersion}`);\n  }\n}\n\nfunction convertVertexShaderTo300(source) {\n  return source\n    .replace(/attribute\\s+/g, 'in ')\n    .replace(/varying\\s+/g, 'out ')\n    .replace(/texture2D\\(/g, 'texture(')\n    .replace(/textureCube\\(+/g, 'texture(')\n    .replace(/texture2DLodEXT\\(/g, 'textureLod(')\n    .replace(/textureCubeLodEXT\\(/g, 'textureLod(');\n}\n\nfunction convertFragmentShaderTo300(source) {\n  return source\n    .replace(/varying\\s+/g, 'in ')\n    .replace(/texture2D\\(/g, 'texture(')\n    .replace(/textureCube\\(/g, 'texture(')\n    .replace(/texture2DLodEXT\\(/g, 'textureLod(')\n    .replace(/textureCubeLodEXT\\(/g, 'textureLod(');\n\n  // Deal with fragColor\n  // .replace(/gl_fragColor/g, 'fragColor ');\n}\n\nfunction convertVertexShaderTo100(source) {\n  // /gm - treats each line as a string, so that ^ matches after newlines\n  return source\n    .replace(/^in\\s+/gm, 'attribute ')\n    .replace(/^out\\s+/gm, 'varying ')\n    .replace(/texture\\(/g, 'texture2D(');\n}\n\nfunction convertFragmentShaderTo100(source) {\n  // /gm - treats each line as a string, so that ^ matches after newlines\n  return source.replace(/^in\\s+/gm, 'varying ').replace(/texture\\(/g, 'texture2D(');\n\n  // Deal with fragColor\n  // .replace(/^out\\s+/g, 'varying ')\n}\n","const TYPE_DEFINITIONS = {\n  number: {\n    validate(value, propType) {\n      return (\n        Number.isFinite(value) &&\n        (!('max' in propType) || value <= propType.max) &&\n        (!('min' in propType) || value >= propType.min)\n      );\n    }\n  },\n  array: {\n    validate(value, propType) {\n      return Array.isArray(value) || ArrayBuffer.isView(value);\n    }\n  }\n};\n\nexport function parsePropTypes(propDefs) {\n  const propTypes = {};\n  for (const propName in propDefs) {\n    const propDef = propDefs[propName];\n    const propType = parsePropType(propDef);\n    propTypes[propName] = propType;\n  }\n  return propTypes;\n}\n\n// Parses one property definition entry. Either contains:\n// * a valid prop type object ({type, ...})\n// * or just a default value, in which case type and name inference is used\nfunction parsePropType(propDef) {\n  let type = getTypeOf(propDef);\n  if (type === 'object') {\n    if (!propDef) {\n      return {type: 'object', value: null};\n    }\n    if ('type' in propDef) {\n      return Object.assign({}, propDef, TYPE_DEFINITIONS[propDef.type]);\n    }\n    if (!('value' in propDef)) {\n      // If no type and value this object is likely the value\n      return {type: 'object', value: propDef};\n    }\n    type = getTypeOf(propDef.value);\n    return Object.assign({type}, propDef, TYPE_DEFINITIONS[type]);\n  }\n  return Object.assign({type, value: propDef}, TYPE_DEFINITIONS[type]);\n}\n\n// improved version of javascript typeof that can distinguish arrays and null values\nfunction getTypeOf(value) {\n  if (Array.isArray(value) || ArrayBuffer.isView(value)) {\n    return 'array';\n  }\n  return typeof value;\n}\n","import transpileShader from './transpile-shader';\nimport {assert} from '../utils';\nimport {parsePropTypes} from './filters/prop-types';\n\nconst VERTEX_SHADER = 'vs';\nconst FRAGMENT_SHADER = 'fs';\n\nexport default class ShaderModule {\n  constructor({\n    name,\n    vs,\n    fs,\n    dependencies = [],\n    uniforms,\n    getUniforms,\n    deprecations = [],\n    defines = {},\n    // DEPRECATED\n    vertexShader,\n    fragmentShader\n  }) {\n    assert(typeof name === 'string');\n    this.name = name;\n    this.vs = vs || vertexShader;\n    this.fs = fs || fragmentShader;\n    this.getModuleUniforms = getUniforms;\n    this.dependencies = dependencies;\n    this.deprecations = this._parseDeprecationDefinitions(deprecations);\n    this.defines = defines;\n\n    if (uniforms) {\n      this.uniforms = parsePropTypes(uniforms);\n    }\n  }\n\n  // Extracts the source code chunk for the specified shader type from the named shader module\n  getModuleSource(type, targetGLSLVersion) {\n    let moduleSource;\n    switch (type) {\n      case VERTEX_SHADER:\n        moduleSource = transpileShader(this.vs || '', targetGLSLVersion, true);\n        break;\n      case FRAGMENT_SHADER:\n        moduleSource = transpileShader(this.fs || '', targetGLSLVersion, false);\n        break;\n      default:\n        assert(false);\n    }\n\n    return `\\\n#define MODULE_${this.name.toUpperCase()}\n${moduleSource}\\\n// END MODULE_${this.name}\n\n`;\n  }\n\n  getUniforms(opts, uniforms) {\n    if (this.getModuleUniforms) {\n      return this.getModuleUniforms(opts, uniforms);\n    }\n    // Build uniforms from the uniforms array\n    if (this.uniforms) {\n      return this._defaultGetUniforms(opts);\n    }\n    return {};\n  }\n\n  getDefines() {\n    return this.defines;\n  }\n\n  // Warn about deprecated uniforms or functions\n  checkDeprecations(shaderSource, log) {\n    this.deprecations.forEach(def => {\n      if (def.regex.test(shaderSource)) {\n        if (def.deprecated) {\n          log.deprecated(def.old, def.new)();\n        } else {\n          log.removed(def.old, def.new)();\n        }\n      }\n    });\n  }\n\n  _parseDeprecationDefinitions(deprecations) {\n    deprecations.forEach(def => {\n      switch (def.type) {\n        case 'function':\n          def.regex = new RegExp(`\\\\b${def.old}\\\\(`);\n          break;\n        default:\n          def.regex = new RegExp(`${def.type} ${def.old};`);\n      }\n    });\n\n    return deprecations;\n  }\n\n  _defaultGetUniforms(opts = {}) {\n    const uniforms = {};\n    const propTypes = this.uniforms;\n\n    for (const key in propTypes) {\n      const propDef = propTypes[key];\n      if (key in opts && !propDef.private) {\n        if (propDef.validate) {\n          assert(propDef.validate(opts[key], propDef), `${this.name}: invalid ${key}`);\n        }\n        uniforms[key] = opts[key];\n      } else {\n        uniforms[key] = propDef.value;\n      }\n    }\n\n    return uniforms;\n  }\n}\n\n// This utility mutates the original module\n// Keeping for backward compatibility\n// TODO - remove in v8\nexport function normalizeShaderModule(module) {\n  if (!module.normalized) {\n    module.normalized = true;\n    if (module.uniforms && !module.getUniforms) {\n      const shaderModule = new ShaderModule(module);\n      module.getUniforms = shaderModule.getUniforms.bind(shaderModule);\n    }\n  }\n  return module;\n}\n","import {MODULE_INJECTORS_VS, MODULE_INJECTORS_FS} from '../modules/module-injectors';\nimport {VERTEX_SHADER, FRAGMENT_SHADER} from './constants';\nimport {assert} from '../utils';\n\n// TODO - experimental\nconst MODULE_INJECTORS = {\n  [VERTEX_SHADER]: MODULE_INJECTORS_VS,\n  [FRAGMENT_SHADER]: MODULE_INJECTORS_FS\n};\n\nexport const DECLARATION_INJECT_MARKER = '__LUMA_INJECT_DECLARATIONS__'; // Uniform/attribute declarations\n\nconst REGEX_START_OF_MAIN = /void main\\s*\\([^)]*\\)\\s*\\{\\n?/; // Beginning of main\nconst REGEX_END_OF_MAIN = /}\\n?[^{}]*$/; // End of main, assumes main is last function\nconst fragments = [];\n\n// A minimal shader injection/templating system.\n// RFC: https://github.com/uber/luma.gl/blob/7.0-release/dev-docs/RFCs/v6.0/shader-injection-rfc.md\n/* eslint-disable complexity */\nexport default function injectShader(source, type, inject, injectStandardStubs) {\n  const isVertex = type === VERTEX_SHADER;\n\n  for (const key in inject) {\n    const fragmentData = inject[key];\n    fragmentData.sort((a, b) => a.order - b.order);\n    fragments.length = fragmentData.length;\n    for (let i = 0, len = fragmentData.length; i < len; ++i) {\n      fragments[i] = fragmentData[i].injection;\n    }\n    const fragmentString = `${fragments.join('\\n')}\\n`;\n    switch (key) {\n      // declarations are injected before the main function\n      case 'vs:#decl':\n        if (isVertex) {\n          source = source.replace(DECLARATION_INJECT_MARKER, fragmentString);\n        }\n        break;\n      // main code is injected at the end of main function\n      case 'vs:#main-start':\n        if (isVertex) {\n          source = source.replace(REGEX_START_OF_MAIN, match => match + fragmentString);\n        }\n        break;\n      case 'vs:#main-end':\n        if (isVertex) {\n          source = source.replace(REGEX_END_OF_MAIN, match => fragmentString + match);\n        }\n        break;\n      case 'fs:#decl':\n        if (!isVertex) {\n          source = source.replace(DECLARATION_INJECT_MARKER, fragmentString);\n        }\n        break;\n      case 'fs:#main-start':\n        if (!isVertex) {\n          source = source.replace(REGEX_START_OF_MAIN, match => match + fragmentString);\n        }\n        break;\n      case 'fs:#main-end':\n        if (!isVertex) {\n          source = source.replace(REGEX_END_OF_MAIN, match => fragmentString + match);\n        }\n        break;\n\n      default:\n        // TODO(Tarek): I think this usage should be deprecated.\n\n        // inject code after key, leaving key in place\n        source = source.replace(key, match => match + fragmentString);\n    }\n  }\n\n  // Remove if it hasn't already been replaced\n  source = source.replace(DECLARATION_INJECT_MARKER, '');\n\n  // Finally, if requested, insert an automatic module injector chunk\n  if (injectStandardStubs) {\n    source = source.replace(/\\}\\s*$/, match => match + MODULE_INJECTORS[type]);\n  }\n\n  return source;\n}\n\n/* eslint-enable complexity */\n\n// Takes an array of inject objects and combines them into one\nexport function combineInjects(injects) {\n  const result = {};\n  assert(Array.isArray(injects) && injects.length > 1);\n  injects.forEach(inject => {\n    for (const key in inject) {\n      result[key] = result[key] ? `${result[key]}\\n${inject[key]}` : inject[key];\n    }\n  });\n  return result;\n}\n","export const MODULE_INJECTORS_VS = `\\\n#ifdef MODULE_LOGDEPTH\n  logdepth_adjustPosition(gl_Position);\n#endif\n`;\n\nexport const MODULE_INJECTORS_FS = `\\\n#ifdef MODULE_MATERIAL\n  gl_FragColor = material_filterColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_LIGHTING\n  gl_FragColor = lighting_filterColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_FOG\n  gl_FragColor = fog_filterColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_PICKING\n  gl_FragColor = picking_filterHighlightColor(gl_FragColor);\n  gl_FragColor = picking_filterPickingColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_LOGDEPTH\n  logdepth_setFragDepth();\n#endif\n`;\n","export const VERTEX_SHADER = 'vs';\nexport const FRAGMENT_SHADER = 'fs';\n","// shadertools exports\n\n// DEFAULT SHADERS\n// A set of base shaders that leverage the shader module system,\n// dynamically enabling features depending on which modules are included\nimport MODULAR_VS from './shaders/modular-vertex.glsl';\nimport MODULAR_FS from './shaders/modular-fragment.glsl';\n\n// DOCUMENTED APIS\nexport {\n  registerShaderModules,\n  setDefaultShaderModules,\n  getDefaultShaderModules\n} from './lib/resolve-modules';\nexport {assembleShaders, createShaderHook, createModuleInjection} from './lib/assemble-shaders';\n\n// HELPERS\nexport {combineInjects} from './lib/inject-shader';\nexport {normalizeShaderModule} from './lib/shader-module';\n\n// UTILS\nexport {\n  getQualifierDetails,\n  getPassthroughFS,\n  typeToChannelSuffix,\n  typeToChannelCount,\n  convertToVec4\n} from './utils/shader-utils';\n\n// SHADER MODULES\nexport * from './modules';\n\nexport const MODULAR_SHADERS = {\n  vs: MODULAR_VS,\n  fs: MODULAR_FS,\n  uniforms: {}\n};\n","export default `\\\n#define SHADER_NAME luma_modular_vertex\n\n// object attributes\nattribute vec3 positions;\nattribute vec3 normals;\nattribute vec4 colors;\nattribute vec2 texCoords;\nattribute vec3 pickingColors;\n\nvoid main(void) {\n\n  // Set up position\n#ifdef MODULE_GEOMETRY\n  geometry_setPosition(positions);\n  geometry_setNormal(normals);\n#endif\n\n#ifdef MODULE_PROJECT\n  project_setPositionAndNormal_Model(positions, normals);\n  gl_Position = project_model_to_clipspace(positions);\n#endif\n\n  // Set up depth\n#ifdef MODULE_LOGDEPTH\n  logdepth_adjustPosition(gl_Position);\n#endif\n\n#ifdef MODULE_DIFFUSE\n  diffuse_setTextureCoordinate(texCoords);\n#endif\n\n  // Set up color calculations\n#ifdef MODULE_MATERIAL\n  material_setDiffuseColor(colors);\n  material_setDiffuseTextureCoordinates(texCoords);\n#endif\n\n#ifdef MODULE_LIGHTING\n  lighting_setPositionAndNormal(positions, normals);\n  lighting_apply_light(positions);\n  lighting_apply_reflection(positions);\n#endif\n\n#ifdef MODULE_PICKING\n  picking_setPickingColor(pickingColors);\n#endif\n\n}\n`;\n","export default `\\\n#define SHADER_NAME luma-modular-fragment\n\nprecision highp float;\n\n// varyings\nvarying vec4 vColor;\n\nvoid main(){\n  gl_FragColor = vec4(1., 0., 1., 1.);\n\n#ifdef MODULE_DIFFUSE\n  gl_FragColor = diffuse_filterColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_MATERIAL\n  gl_FragColor = material_filterColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_LIGHTING\n  gl_FragColor = lighting_filterColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_FOG\n  gl_FragColor = fog_filterColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_PICKING\n  gl_FragColor = picking_filterHighlightColor(gl_FragColor);\n  gl_FragColor = picking_filterPickingColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_LOGDEPTH\n  logdepth_setFragDepth(gl_Position);\n#endif\n}\n`;\n","// Recommendation is to ignore message but current test suite checks agains the\n// message so keep it for now.\nexport default function assert(condition, message) {\n  if (!condition) {\n    throw new Error(message || 'shadertools: assertion failed.');\n  }\n}\n","import GL from '@luma.gl/constants';\nimport Resource from './resource';\nimport Buffer from './buffer';\nimport {isWebGL2, assertWebGL2Context} from '../webgl-utils';\nimport {log, isObjectEmpty} from '../utils';\n\n// NOTE: The `bindOnUse` flag is a major workaround:\n// See https://github.com/KhronosGroup/WebGL/issues/2346\n\nexport default class TransformFeedback extends Resource {\n  static isSupported(gl) {\n    return isWebGL2(gl);\n  }\n\n  constructor(gl, props = {}) {\n    assertWebGL2Context(gl);\n    super(gl, props);\n\n    this.initialize(props);\n    this.stubRemovedMethods('TransformFeedback', 'v6.0', ['pause', 'resume']);\n    Object.seal(this);\n  }\n\n  initialize(props = {}) {\n    this.buffers = {};\n    this.unused = {};\n    this.configuration = null;\n    this.bindOnUse = true;\n\n    // Unbind any currently bound buffers\n    if (!isObjectEmpty(this.buffers)) {\n      this.bind(() => this._unbindBuffers());\n    }\n\n    this.setProps(props);\n    return this;\n  }\n\n  setProps(props) {\n    if ('program' in props) {\n      this.configuration = props.program && props.program.configuration;\n    }\n    if ('configuration' in props) {\n      this.configuration = props.configuration;\n    }\n    if ('bindOnUse' in props) {\n      props = props.bindOnUse;\n    }\n    if ('buffers' in props) {\n      this.setBuffers(props.buffers);\n    }\n  }\n\n  setBuffers(buffers = {}) {\n    this.bind(() => {\n      for (const bufferName in buffers) {\n        this.setBuffer(bufferName, buffers[bufferName]);\n      }\n    });\n    return this;\n  }\n\n  setBuffer(locationOrName, bufferOrParams) {\n    const location = this._getVaryingIndex(locationOrName);\n    const {buffer, byteSize, byteOffset} = this._getBufferParams(bufferOrParams);\n\n    if (location < 0) {\n      this.unused[locationOrName] = buffer;\n      log.warn(() => `${this.id} unused varying buffer ${locationOrName}`)();\n      return this;\n    }\n\n    this.buffers[location] = bufferOrParams;\n\n    // Need to avoid chrome bug where buffer that is already bound to a different target\n    // cannot be bound to 'TRANSFORM_FEEDBACK_BUFFER' target.\n    if (!this.bindOnUse) {\n      this._bindBuffer(location, buffer, byteOffset, byteSize);\n    }\n\n    return this;\n  }\n\n  begin(primitiveMode = GL.POINTS) {\n    this.gl.bindTransformFeedback(GL.TRANSFORM_FEEDBACK, this.handle);\n    this._bindBuffers();\n    this.gl.beginTransformFeedback(primitiveMode);\n    return this;\n  }\n\n  end() {\n    this.gl.endTransformFeedback();\n    this._unbindBuffers();\n    this.gl.bindTransformFeedback(GL.TRANSFORM_FEEDBACK, null);\n    return this;\n  }\n\n  // PRIVATE METHODS\n\n  _getBufferParams(bufferOrParams) {\n    let byteOffset;\n    let byteSize;\n    let buffer;\n    if (bufferOrParams instanceof Buffer === false) {\n      buffer = bufferOrParams.buffer;\n      byteSize = bufferOrParams.byteSize;\n      byteOffset = bufferOrParams.byteOffset;\n    } else {\n      buffer = bufferOrParams;\n    }\n    // to use bindBufferRange, either offset or size must be specified, use default value for the other.\n    if (byteOffset !== undefined || byteSize !== undefined) {\n      byteOffset = byteOffset || 0;\n      byteSize = byteSize || buffer.byteLength - byteOffset;\n    }\n    return {buffer, byteOffset, byteSize};\n  }\n\n  _getVaryingInfo(locationOrName) {\n    return this.configuration && this.configuration.getVaryingInfo(locationOrName);\n  }\n\n  _getVaryingIndex(locationOrName) {\n    if (this.configuration) {\n      return this.configuration.getVaryingInfo(locationOrName).location;\n    }\n    const location = Number(locationOrName);\n    return Number.isFinite(location) ? location : -1;\n  }\n\n  // Need to avoid chrome bug where buffer that is already bound to a different target\n  // cannot be bound to 'TRANSFORM_FEEDBACK_BUFFER' target.\n  _bindBuffers() {\n    if (this.bindOnUse) {\n      for (const bufferIndex in this.buffers) {\n        const {buffer, byteSize, byteOffset} = this._getBufferParams(this.buffers[bufferIndex]);\n        this._bindBuffer(bufferIndex, buffer, byteOffset, byteSize);\n      }\n    }\n  }\n\n  _unbindBuffers() {\n    if (this.bindOnUse) {\n      for (const bufferIndex in this.buffers) {\n        this._bindBuffer(bufferIndex, null);\n      }\n    }\n  }\n\n  _bindBuffer(index, buffer, byteOffset = 0, byteSize) {\n    const handle = buffer && buffer.handle;\n    if (!handle || byteSize === undefined) {\n      this.gl.bindBufferBase(GL.TRANSFORM_FEEDBACK_BUFFER, index, handle);\n    } else {\n      this.gl.bindBufferRange(GL.TRANSFORM_FEEDBACK_BUFFER, index, handle, byteOffset, byteSize);\n    }\n    return this;\n  }\n\n  // RESOURCE METHODS\n\n  _createHandle() {\n    return this.gl.createTransformFeedback();\n  }\n\n  _deleteHandle() {\n    this.gl.deleteTransformFeedback(this.handle);\n  }\n\n  _bindHandle(handle) {\n    this.gl.bindTransformFeedback(GL.TRANSFORM_FEEDBACK, this.handle);\n  }\n}\n"],"sourceRoot":""}