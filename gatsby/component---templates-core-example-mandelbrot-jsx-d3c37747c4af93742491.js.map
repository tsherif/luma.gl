{"version":3,"sources":["webpack:///../examples/core/mandelbrot/app.js","webpack:///./templates/core/example-mandelbrot.jsx","webpack:///../modules/core/src/geometry/geometry.js","webpack:///../node_modules/seer/dist/index.js","webpack:///../modules/core/src/lib/clip-space.js"],"names":["ZOOM_THRESHOLD","ZOOM_CENTER_X","ZOOM_CENTER_Y","BASE_CORNERS","centerOffsetX","centerOffsetY","zoom","AppAnimationLoop","getInfo","onInitialize","gl","_ref","cornersBuffer","_animationLoop","buffer","clipSpace","clip_space","fs","attributes","aCoordinate","size","onRender","_ref2","canvas","tick","Math","Float32Array","zoomFactor","corners","_i","_BASE_CORNERS","length","baseCorner","getZoomedCorners","AnimationLoop","window","website","app_AppAnimationLoop","animationLoop","Example","render","react_default","a","createElement","animation_loop_example_page","exampleConfig","this","props","pageContext","React","Component","DRAW_MODE","POINTS","LINES","LINE_LOOP","LINE_STRIP","TRIANGLES","TRIANGLE_STRIP","TRIANGLE_FAN","Geometry","_props","_props$id","id","uid","_props$drawMode","drawMode","_props$attributes","_props$indices","indices","_props$vertexCount","vertexCount","userData","_setAttributes","_calculateVertexCount","getVertexCount","getAttributes","Object","assign","_print","attributeName","ArrayBuffer","isView","value","attribute","assert","undefined","isIndexed","Infinity","constant","Number","__webpack_require__","defineProperty","exports","_typeof","Symbol","iterator","obj","constructor","prototype","isBrowser","addEventListener","timers","Map","isReady","__SEER_INITIALIZED__","throttle","key","delay","time","get","now","Date","set","send","type","data","arguments","seen","Set","payload","JSON","stringify","has","add","toString","call","slice","includes","Array","replacer","postMessage","source","e","console","log","listeners","listener","message","_message$data","typeListeners","forEach","cb","init","__SEER_LISTENER__","list","listItem","itemKey","updateItem","path","multiUpdate","array","deleteItem","addLog","msg","listenFor","Error","push","removeListener","filter","l","clean","removeEventListener","CLIPSPACE_VERTEX_SHADER","POSITIONS","ClipSpace","opts","_this","TEX_COORDS","map","coord","_Model","vs","geometry","_geometry_geometry__WEBPACK_IMPORTED_MODULE_4__","GL","aClipSpacePosition","aTexCoord","setVertexCount","Model"],"mappings":"mKAEA,IAyDMA,EAAN,IACMC,GAAN,kBACMC,EAAN,kBAEMC,EAAe,CAAC,OAAD,KAAe,KAAf,KAA4B,MAA5B,KAAyC,IAA9D,MAEIC,EAAJ,EACIC,EAAJ,EACIC,EAAJ,MAwBqBC,iKACZC,QAAP,WACE,MA3FJ,wPA8FEC,yBAAmC,IAArBC,EAAqBC,EAArBD,GACNE,GAD2BD,EAAjBE,eACM,IAAAC,EAAA,EAAAJ,EAAtB,KAEA,MAAO,CACLK,UAAW,IAAAC,EAAA,EAAAN,EAAkB,CAC3BO,GAzFR,6jCA0FQC,WAAY,CACVC,YAAa,CAAAP,EAAgB,CAACQ,KAAM,OAGxCR,oBAIJS,qBAAuD,IAA7CX,EAA6CY,EAA7CZ,GAAIa,EAAyCD,EAAzCC,OAAcR,GAA2BO,EAAjCE,KAAiCF,EAA3BP,WAAWH,EAAgBU,EAAhBV,cACrCF,eAAkBe,SAASF,EAATE,MAAuBF,EAAzCb,QAAyDe,SAASF,EAATE,MAAuBF,EAAhFb,SAEAE,UAAsB,IAAAc,aA3C1B,SAAAC,QAA6C,IAAnBA,MAAa,OACrCrB,MACAN,IACEM,KAIF,IADA,IAAMsB,EAAN,GACAC,EAAA,EAAAC,EAAA3B,EAAA0B,EAAAC,EAAAC,OAAAF,IAAuC,CAAlC,IAAMG,EAAUF,EAAhBD,GACHD,OAAaI,OAAbJ,EAAmDI,OAAnDJ,GAUF,OAPIxB,IAAJH,IACEG,IAAkBH,EAADG,GAAjBA,IAEEC,IAAJH,IACEG,IAAkBH,EAADG,GAAjBA,IAGFuB,EAyByCK,KAEvClB,aAxB0CmB,KA6B1C,oBAAAC,QAAkCA,OAAtCC,UACwB,IAAtBC,GACAC,kDCtHmBC,kLACnBC,kBACE,OACEC,EAAAC,EAAAC,cAAAC,EAAA,GAA0BV,cAA1BG,EAAwDQ,cAAeC,KAAAC,MAAAC,YAAuBH,oBAH/DI,IAAMC,qVCApC,IAAMC,EAAY,CACvBC,OADuB,EAEvBC,MAFuB,EAGvBC,UAHuB,EAIvBC,WAJuB,EAKvBC,UALuB,EAMvBC,eANuB,EAOvBC,aAPuB,GAWJC,aAKnB,SAAAA,EAAAZ,QAAwB,IAAZA,MAAQ,IAAI,IAAAa,EAAAb,EAAAc,EAAAD,EAAAE,GAEpBA,OAFoB,IAAAD,EAEfE,YAFe,YAAAF,EAAAG,EAAAJ,EAAAK,SAGpBA,OAHoB,IAAAD,EAGTb,EAHSK,UAAAQ,EAAAE,EAAAN,EAAA1C,WAIpBA,OAJoB,IAAAgD,EAAA,GAAAA,EAAAC,EAAAP,EAAAQ,QAKpBA,OALoB,IAAAD,EAAA,KAAAA,EAAAE,EAAAT,EAAAU,YAMpBA,OANoB,IAAAD,EAAA,KAAAA,EAStBvB,KAAAgB,KACAhB,KAAAmB,SAAA,EAAgBA,EAChBnB,KAAA5B,WAAA,GACA4B,KAAAyB,SAAA,GAEAzB,KAAA0B,eAAAtD,EAAAkD,GAEAtB,KAAAwB,YAAmBA,GAAexB,KAAA2B,sBAA2B3B,KAA3B5B,WAA4C4B,KAhBxDsB,mDAHtB,OAAAjB,iCAoCFuB,0BACE,OAAO5B,KAAPwB,eAIFK,yBACE,OAAO7B,KAAAsB,QAAAQ,OAAAC,OAAA,CAAgBT,QAAStB,KAAKsB,SAAYtB,KAA1C5B,YAA6D4B,KAApE5B,cAKF4D,mBACE,kBAAmBhC,KAAnBgB,GAAA,cAAAiB,KAQFP,6BAKE,IAAK,IAALO,KAJAX,IACEtB,KAAAsB,QAAeY,YAAAC,OAAAb,GAA8B,CAACc,MAADd,EAAiBhD,KAAM,GAApEgD,GAGFlD,EAAwC,CACtC,IAAIiE,EAAYjE,EADsB6D,GAItCI,EAAYH,YAAAC,OAAAE,GAAgC,CAACD,MAAOC,GAApDA,EAEAC,YACEJ,mBAAmBG,EADfD,OAEDpC,KAAAgC,OAFCC,GAANK,6DAKKL,gBAAD,cAAiCA,GAAmCI,EAAxE/D,OACE+D,UAIF,YAAIJ,GACFK,aAAQtC,KAARsC,SACAtC,KAAAsB,QAAAe,GAEArC,KAAA5B,WAAA6D,GAAAI,EASJ,OALIrC,KAAAsB,cAAJiB,IAAoBvC,KAAAsB,QAAAkB,YAClBxC,KAAAsB,QAAeQ,iBAAkB9B,KAAjCsB,gBACOtB,KAAAsB,QAAPkB,WAGFxC,QAGF2B,oCACE,GAAAL,EACE,OAAOA,QAAPrC,OAEF,IAAIuC,EAAJiB,IACA,IAAK,IAALR,KAAA7D,EAAwC,CACtC,IAAMiE,EAAYjE,EAAlB6D,GACOG,EAAyBC,EAFMD,MAExB9D,EAAkB+D,EAFM/D,MAEN+D,EAFMK,UAGlCN,GAAsB9D,GAA1B,IACEkD,EAAc7C,WAAsByD,SAApCZ,IAKJ,OADAc,YAAOK,gBAAPL,IACAd,mCA1EA,OAAOxB,KAAPmB,oDChDJyB,EAAQ,IAERA,EAAQ,IAERA,EAAQ,IAERA,EAAQ,IAERA,EAAQ,IAERA,EAAQ,KAERA,EAAQ,KAERA,EAAQ,IAERA,EAAQ,GAERA,EAAQ,GAERA,EAAQ,GAERA,EAAQ,IAERA,EAAQ,IAERA,EAAQ,IAERA,EAAQ,GAERA,EAAQ,GAERd,OAAAe,eAAAC,EAAA,cACAV,OAAA,IAGA,IAAAW,EAAA,mBAAAC,QAAA,iBAAAA,OAAAC,SAAA,SAAAC,GACA,cAAAA,GACC,SAAAA,GACD,OAAAA,GAAA,mBAAAF,QAAAE,EAAAC,cAAAH,QAAAE,IAAAF,OAAAI,UAAA,gBAAAF,GAsBAG,EAAA,oBAAAhE,eAAAiE,iBACAC,EAAA,IAAAC,IAOAC,EAAA,WACA,OAAAJ,GAAAhE,OAAAqE,sBAWAC,EAAA,SAAAC,EAAAC,GACA,IAAAC,EAAAP,EAAAQ,IAAAH,GACAI,EAAAC,KAAAD,MAEA,SAAAF,GAAAE,EAAAF,EAAAD,KAIAN,EAAAW,IAAAN,EAAAI,IACA,IA2BAG,EAAA,SAAAC,GACA,IAAAC,EAAAC,UAAArF,OAAA,QAAAsD,IAAA+B,UAAA,GAAAA,UAAA,MAEA,GAAAjB,GAAAI,IAAA,CAIA,IAAAc,EAAA,IAAAC,IACAC,EAAAC,KAAAC,UAAAN,EAhCA,SAAAE,GACA,gBAAAX,EAAAxB,GACA,IAAAA,GAAA,qBAAAA,EAAA,YAAAW,EAAAX,MAAAmC,EAAAK,IAAAxC,GAOA,OAHAmC,EAAAM,IAAAzC,GACAN,OAAAsB,UAAA0B,SAAAC,KAAA3C,GAAA4C,MAAA,MAAAC,SAAA,SAGAC,MAAA9B,UAAA4B,MAAAD,KAAA3C,EAAA,MAGAA,GAmBA+C,CAAAZ,IAEA,IACAlF,OAAA+F,YAAA,CACAhB,OACAK,UACAY,OAAA,cACK,KACF,MAAAC,GACH,GAAA3B,EAAA,gBACA,OAGA4B,QAAAC,IAAAF,MAIAG,EAAA,IAAAjC,IAEAkC,EAAA,SAAAC,GACA,GAAAA,KAAAtB,MAAA,cAAAsB,EAAAtB,KAAAgB,OAAA,CAIA,IAAAO,EAAAD,EAAAtB,KACAD,EAAAwB,EAAAxB,KACAK,EAAAmB,EAAAnB,QACAoB,EAAAJ,EAAA1B,IAAAK,GAEAyB,GACAA,EAAAC,QAAA,SAAAC,GACA,OAAAA,EAAAtB,OAYAuB,EAAA,WACA3C,IAAAhE,OAAA4G,oBAIA5G,OAAAiE,iBAAA,UAAAoC,GACArG,OAAA4G,mBAAA,IA6JAnD,EAAA,SACAqB,OACAR,WACAF,UACAyC,KA/FA,SAAAtC,EAAAS,GACA,OAAAF,EAAA,QACAP,MACAS,UA6FA8B,SAjFA,SAAAvC,EAAAwC,GACA,IAAA/B,EAAAC,UAAArF,OAAA,QAAAsD,IAAA+B,UAAA,GAAAA,UAAA,MACA,OAAAH,EAAA,aACAP,MACAwC,UACA/B,UA6EAgC,WAhEA,SAAAzC,EAAAwC,EAAAE,EAAAjC,GACA,OAAAF,EAAA,eACAP,MACAwC,UACAE,OACAjC,UA4DAkC,YA7CA,SAAA3C,EAAAwC,EAAAI,GACA,OAAArC,EAAA,qBACAP,MACAwC,UACAI,WA0CAC,WA/BA,SAAA7C,EAAAwC,GACA,OAAAjC,EAAA,eACAP,MACAwC,aA6BAM,OAjBA,SAAA9C,EAAAwC,EAAAO,GACA,OAAAxC,EAAA,WACAP,MACAwC,UACAO,SAcAlB,YACAmB,UAhJA,SAAAxC,EAAA2B,GACA,GAAA1C,EAAA,CAIA,IAAAe,IAAA2B,EACA,UAAAc,MAAA,sCAGApB,EAAAb,IAAAR,IACAqB,EAAAvB,IAAAE,EAAA,IAGA/E,OAAA4G,mBACAD,IAGAP,EAAA1B,IAAAK,GAAA0C,KAAAf,KAgIAgB,eAvHA,SAAAhB,GACAN,EAAAK,QAAA,SAAAD,EAAAjC,GACA6B,EAAAvB,IAAAN,EAAAiC,EAAAmB,OAAA,SAAAC,GACA,OAAAA,IAAAlB,QAqHAC,OACAkB,MAnKA,WACA7D,GAAAhE,OAAA4G,oBAIA5G,OAAA8H,oBAAA,UAAAzB,UACArG,OAAA4G,2ICzLA,IAAMmB,EAAN,kUAkBMC,EAAY,mBAAlB,GAEqBC,sBACnB,SAAAA,EAAA1J,EAAA2J,GAAsB,IAAAC,EACdC,EAAaJ,EAAAK,IAAc,SAAAC,GAAK,OAAKA,QAALA,IADlB,OAGpBH,EAAAI,EAAA7C,KAAA/E,KAAApC,EAEEkE,OAAAC,OAAA,GAAAwF,EAAwB,CACtBM,GADsBT,EAEtBU,SAAU,IAAAC,EAAA,EAAa,CACrB5G,SAAU6G,IADWrH,eAErBa,YAFqB,EAGrBpD,WAAY,CACV6J,mBAAoB,CAAC3J,KAAD,EAAU8D,MAAO,IAAAxD,aAAAyI,IACrCa,UAAW,CAAC5J,KAAD,EAAU8D,MAAO,IAAAxD,aAAA6I,IAC5BpJ,YAAa,CAACC,KAAD,EAAU8D,MAAO,IAAAxD,aAAA6I,WAVtCzH,MAeAmI,eAAA,GAlBoBX,mGADeY","file":"component---templates-core-example-mandelbrot-jsx-d3c37747c4af93742491.js","sourcesContent":["import {AnimationLoop, ClipSpace, Buffer} from '@luma.gl/core';\n\nconst INFO_HTML = `\n<p>\n<code>Mandelbrot</code> set zoom implemented as a GLSL fragment shader.\n<p>\nUses a luma.gl <code>ClipSpace</code> Model to set up a screen spaced model\nin which the <code>fragment shader</code> can render.\n`;\n\n// CONTEXT 1 - 32 bit mandelbrot\n\nconst MANDELBROT_FRAGMENT_SHADER = `\\\n#define SHADER_NAME mandelbrot32\n\nprecision highp float;\n\n// Based on a renderman shader by Michael Rivero\nconst int maxIterations = 1;\nvarying vec2 coordinate;\n\nvoid main (void)\n{\n  vec2 pos = coordinate;\n  float real = pos.x;\n  float imag = pos.y;\n  float Creal = real;\n  float Cimag = imag;\n\n  int divergeIteration = 0;\n  for (int i = 0; i < 100; i++)\n  {\n    // z = z^2 + c\n    float tempreal = real;\n    float tempimag = imag;\n    real = (tempreal * tempreal) - (tempimag * tempimag);\n    imag = 2. * tempreal * tempimag;\n    real += Creal;\n    imag += Cimag;\n    float r2 = (real * real) + (imag * imag);\n    if (divergeIteration == 0 && r2 >= 4.) {\n      divergeIteration = i;\n    }\n  }\n  // Base the color on the number of iterations\n  vec4 color;\n  if (divergeIteration < 9) {\n    color = vec4 (0., 0., 0., 1.0); // black\n  }\n  else\n  {\n    float tmpval = fract((float(divergeIteration) / 100.));\n    color = vec4 (tmpval, 0, tmpval, 1.0);\n    // color = vec4 (coordinate.r, coordinate.g, 0., 1.0);\n  }\n  gl_FragColor = color;\n}\n`;\n\nconst ZOOM_THRESHOLD = 1e5;\nconst ZOOM_CENTER_X = -0.0150086889504513;\nconst ZOOM_CENTER_Y = 0.78186693904085048;\n\nconst BASE_CORNERS = [[-2.2, -1.2], [0.7, -1.2], [-2.2, 1.2], [0.7, 1.2]];\n\nlet centerOffsetX = 0;\nlet centerOffsetY = 0;\nlet zoom = 1;\n\n// Calculate new zoomed extents\nfunction getZoomedCorners(zoomFactor = 1.01) {\n  zoom *= zoomFactor;\n  if (zoom > ZOOM_THRESHOLD) {\n    zoom = 1;\n  }\n\n  const corners = [];\n  for (const baseCorner of BASE_CORNERS) {\n    corners.push(baseCorner[0] / zoom + centerOffsetX, baseCorner[1] / zoom + centerOffsetY);\n  }\n\n  if (centerOffsetX !== ZOOM_CENTER_X) {\n    centerOffsetX += (ZOOM_CENTER_X - centerOffsetX) / 20;\n  }\n  if (centerOffsetY !== ZOOM_CENTER_Y) {\n    centerOffsetY += (ZOOM_CENTER_Y - centerOffsetY) / 20;\n  }\n\n  return corners;\n}\n\nexport default class AppAnimationLoop extends AnimationLoop {\n  static getInfo() {\n    return INFO_HTML;\n  }\n\n  onInitialize({gl, _animationLoop}) {\n    const cornersBuffer = new Buffer(gl, 32);\n\n    return {\n      clipSpace: new ClipSpace(gl, {\n        fs: MANDELBROT_FRAGMENT_SHADER,\n        attributes: {\n          aCoordinate: [cornersBuffer, {size: 2}]\n        }\n      }),\n      cornersBuffer\n    };\n  }\n\n  onRender({gl, canvas, tick, clipSpace, cornersBuffer}) {\n    gl.viewport(0, 0, Math.max(canvas.width, canvas.height), Math.max(canvas.width, canvas.height));\n\n    cornersBuffer.setData(new Float32Array(getZoomedCorners()));\n\n    clipSpace.draw();\n  }\n}\n\n/* global window */\nif (typeof window !== 'undefined' && !window.website) {\n  const animationLoop = new AppAnimationLoop();\n  animationLoop.start();\n}\n","import React from 'react';\nimport AnimationLoopExamplePage from '../../src/components/animation-loop-example-page';\nimport AnimationLoop from '../../../examples/core/mandelbrot/app';\n\nexport default class Example extends React.Component {\n  render() {\n    return (\n      <AnimationLoopExamplePage AnimationLoop={AnimationLoop} exampleConfig={this.props.pageContext.exampleConfig} />\n    );\n  }\n}\n","import {uid, assert} from '../utils';\n\n// Rendering primitives - specify how to extract primitives from vertices.\n// NOTE: These are numerically identical to the corresponding WebGL/OpenGL constants\nexport const DRAW_MODE = {\n  POINTS: 0x0000, // draw single points.\n  LINES: 0x0001, // draw lines. Each vertex connects to the one after it.\n  LINE_LOOP: 0x0002, // draw lines. Each set of two vertices is treated as a separate line segment.\n  LINE_STRIP: 0x0003, // draw a connected group of line segments from the first vertex to the last\n  TRIANGLES: 0x0004, // draw triangles. Each set of three vertices creates a separate triangle.\n  TRIANGLE_STRIP: 0x0005, // draw a connected group of triangles.\n  TRIANGLE_FAN: 0x0006 // draw a connected group of triangles.\n  // Each vertex connects to the previous and the first vertex in the fan.\n};\n\nexport default class Geometry {\n  static get DRAW_MODE() {\n    return DRAW_MODE;\n  }\n\n  constructor(props = {}) {\n    const {\n      id = uid('geometry'),\n      drawMode = DRAW_MODE.TRIANGLES,\n      attributes = {},\n      indices = null,\n      vertexCount = null\n    } = props;\n\n    this.id = id;\n    this.drawMode = drawMode | 0;\n    this.attributes = {};\n    this.userData = {};\n\n    this._setAttributes(attributes, indices);\n\n    this.vertexCount = vertexCount || this._calculateVertexCount(this.attributes, this.indices);\n\n    // stubRemovedMethods(this, [\n    //   'setNeedsRedraw', 'needsRedraw', 'setAttributes'\n    // ], 'Immutable');\n\n    // stubRemovedMethods(this, [\n    //   'hasAttribute', 'getAttribute', 'getArray'\n    // ], 'Use geometry.attributes and geometry.indices');\n\n    // deprecateMethods(this, ['getAttributes'])\n  }\n\n  get mode() {\n    return this.drawMode;\n  }\n\n  getVertexCount() {\n    return this.vertexCount;\n  }\n\n  // Return an object with all attributes plus indices added as a field.\n  getAttributes() {\n    return this.indices ? {indices: this.indices, ...this.attributes} : this.attributes;\n  }\n\n  // PRIVATE\n\n  _print(attributeName) {\n    return `Geometry ${this.id} attribute ${attributeName}`;\n  }\n\n  // Attribute\n  // value: typed array\n  // type: indices, vertices, uvs\n  // size: elements per vertex\n  // target: WebGL buffer type (string or constant)\n  _setAttributes(attributes, indices) {\n    if (indices) {\n      this.indices = ArrayBuffer.isView(indices) ? {value: indices, size: 1} : indices;\n    }\n\n    for (const attributeName in attributes) {\n      let attribute = attributes[attributeName];\n\n      // Wrap \"unwrapped\" arrays and try to autodetect their type\n      attribute = ArrayBuffer.isView(attribute) ? {value: attribute} : attribute;\n\n      assert(\n        ArrayBuffer.isView(attribute.value),\n        `${this._print(attributeName)}: must be typed array or object with value as typed array`\n      );\n\n      if ((attributeName === 'POSITION' || attributeName === 'positions') && !attribute.size) {\n        attribute.size = 3;\n      }\n\n      // Move indices to separate field\n      if (attributeName === 'indices') {\n        assert(!this.indices);\n        this.indices = attribute;\n      } else {\n        this.attributes[attributeName] = attribute;\n      }\n    }\n\n    if (this.indices && this.indices.isIndexed !== undefined) {\n      this.indices = Object.assign({}, this.indices);\n      delete this.indices.isIndexed;\n    }\n\n    return this;\n  }\n\n  _calculateVertexCount(attributes, indices) {\n    if (indices) {\n      return indices.value.length;\n    }\n    let vertexCount = Infinity;\n    for (const attributeName in attributes) {\n      const attribute = attributes[attributeName];\n      const {value, size, constant} = attribute;\n      if (!constant && value && size >= 1) {\n        vertexCount = Math.min(vertexCount, value.length / size);\n      }\n    }\n\n    assert(Number.isFinite(vertexCount));\n    return vertexCount;\n  }\n}\n","'use strict';\n\nrequire(\"core-js/modules/es6.array.filter\");\n\nrequire(\"core-js/modules/es6.array.for-each\");\n\nrequire(\"core-js/modules/es6.set\");\n\nrequire(\"core-js/modules/es6.regexp.to-string\");\n\nrequire(\"core-js/modules/es6.date.to-string\");\n\nrequire(\"core-js/modules/es7.array.includes\");\n\nrequire(\"core-js/modules/es6.string.includes\");\n\nrequire(\"core-js/modules/es6.date.now\");\n\nrequire(\"core-js/modules/web.dom.iterable\");\n\nrequire(\"core-js/modules/es6.array.iterator\");\n\nrequire(\"core-js/modules/es6.object.to-string\");\n\nrequire(\"core-js/modules/es6.string.iterator\");\n\nrequire(\"core-js/modules/es6.map\");\n\nrequire(\"core-js/modules/es7.symbol.async-iterator\");\n\nrequire(\"core-js/modules/es6.symbol\");\n\nrequire(\"core-js/modules/es6.object.define-property\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n}; // Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n\nvar isBrowser = typeof window !== 'undefined' && window.addEventListener;\nvar timers = new Map();\n/**\n * Ready check for Seer initialization\n *\n * @returns {Boolean}\n */\n\nvar isReady = function isReady() {\n  return isBrowser && window.__SEER_INITIALIZED__;\n};\n/**\n * Utility method allowing to throttle a user action based on a key and a minimun delay.\n *\n * @param key {String} A unique key\n * @param delay {Number} The minimal delay to throttle\n * @returns {Boolean}\n */\n\n\nvar throttle = function throttle(key, delay) {\n  var time = timers.get(key);\n  var now = Date.now();\n\n  if (time && now - time < delay) {\n    return true;\n  }\n\n  timers.set(key, now);\n  return false;\n};\n\nvar replacer = function replacer(seen) {\n  return function (key, value) {\n    if (value && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && seen.has(value)) {\n      return;\n    }\n\n    seen.add(value);\n    var isArray = Object.prototype.toString.call(value).slice(8, -1).includes('Array');\n\n    if (isArray) {\n      return Array.prototype.slice.call(value, 0, 20);\n    }\n\n    return value;\n  };\n};\n/**\n * Low-level api leveraging window.postMessage\n *\n * @param type {String} The action type\n * @param payload {Any} The action payload\n */\n\n\nvar send = function send(type) {\n  var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (!isBrowser || !isReady()) {\n    return;\n  }\n\n  var seen = new Set();\n  var payload = JSON.stringify(data, replacer(seen));\n\n  try {\n    window.postMessage({\n      type: type,\n      payload: payload,\n      source: 'seer-agent'\n    }, '*');\n  } catch (e) {\n    if (throttle('seer-log', 2E3)) {\n      return;\n    }\n\n    console.log(e); // eslint-disable-line\n  }\n};\n\nvar listeners = new Map();\n\nvar listener = function listener(message) {\n  if (!message || !message.data || message.data.source !== 'seer-core') {\n    return;\n  }\n\n  var _message$data = message.data,\n      type = _message$data.type,\n      payload = _message$data.payload;\n  var typeListeners = listeners.get(type);\n\n  if (typeListeners) {\n    typeListeners.forEach(function (cb) {\n      return cb(payload);\n    });\n  }\n};\n/**\n * Initilize window listener. There will be only one for the whole process\n * to prevent too many registrations.\n *\n * This method will be called automatically if you use the `listenFor` method.\n */\n\n\nvar init = function init() {\n  if (!isBrowser || window.__SEER_LISTENER__) {\n    return;\n  }\n\n  window.addEventListener('message', listener);\n  window.__SEER_LISTENER__ = true;\n};\n/**\n * Clean listener. Can be useful in case you want to unregister upcoming events\n * or liberate memory.\n */\n\n\nvar clean = function clean() {\n  if (!isBrowser || !window.__SEER_LISTENER__) {\n    return;\n  }\n\n  window.removeEventListener('message', listener);\n  delete window.__SEER_LISTENER__;\n};\n/**\n * Create a listener that will be called upon events of the given key.\n *\n * @param key {String} The unique tab key\n * @param cb {Function} A callback that will receive the message payload\n */\n\n\nvar listenFor = function listenFor(type, cb) {\n  if (!isBrowser) {\n    return;\n  }\n\n  if (!type || !cb) {\n    throw new Error('Please provide a type and callback');\n  }\n\n  if (!listeners.has(type)) {\n    listeners.set(type, []);\n  }\n\n  if (!window.__SEER_LISTENER__) {\n    init();\n  }\n\n  listeners.get(type).push(cb);\n};\n/**\n * Remove an identity listener\n *\n * @param cb {Function} The callback to remove\n */\n\n\nvar removeListener = function removeListener(cb) {\n  listeners.forEach(function (typeListeners, key) {\n    listeners.set(key, typeListeners.filter(function (l) {\n      return l !== cb;\n    }));\n  });\n};\n/**\n * Creates a new indexed list.\n * It works by index to get O(1) accessing and performance.\n *\n * @param key {String} The key of the tab\n * @param data {Object} The indexed object\n */\n\n\nvar list = function list(key, data) {\n  return send('LIST', {\n    key: key,\n    data: data\n  });\n};\n/**\n * Creates an element in the indexed list, based on the itemKey.\n *\n * @param key {String} The key of the tab\n * @param itemKey {String} The key of the item\n * @param data {Any} The value of the item\n */\n\n\nvar listItem = function listItem(key, itemKey) {\n  var data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  return send('LIST_ITEM', {\n    key: key,\n    itemKey: itemKey,\n    data: data\n  });\n};\n/**\n * Update an item property, can be deeply nested.\n *\n * @param key {String} The key of the tab\n * @param itemKey {String} The key of the item\n * @param path {String} The path of the variable you want to update\n * @param data {Object} The new value\n */\n\n\nvar updateItem = function updateItem(key, itemKey, path, data) {\n  return send('UPDATE_ITEM', {\n    key: key,\n    itemKey: itemKey,\n    path: path,\n    data: data\n  });\n};\n/**\n * Similar to updateItem, but allows to pass an array with {path,data} pairs for\n * multiple update of the same item without having to send multiple messages.\n *\n * @param key {String} The key of the tab\n * @param itemKey {String} The key of the item\n * @param array {Array} The array of updates\n * @param array.path {String} The path for this update\n * @param array.data {Object} The value of this update\n */\n\n\nvar multiUpdate = function multiUpdate(key, itemKey, array) {\n  return send('MULTI_UPDATE_ITEM', {\n    key: key,\n    itemKey: itemKey,\n    array: array\n  });\n};\n/**\n * Remove a specific item in a specific tab.\n *\n * @param key {String} They key of the tab\n * @param itemKey {String} The key of the item\n */\n\n\nvar deleteItem = function deleteItem(key, itemKey) {\n  return send('DELETE_ITEM', {\n    key: key,\n    itemKey: itemKey\n  });\n};\n/**\n * Will create a log message to an item, that will be displayde with the current time.\n *\n * @param key {String} The key of the tab\n * @param itemKey {String} The key of the item\n * @param msg {String} The message to display\n */\n\n\nvar addLog = function addLog(key, itemKey, msg) {\n  return send('ADD_LOG', {\n    key: key,\n    itemKey: itemKey,\n    msg: msg\n  });\n};\n\nexports[\"default\"] = {\n  send: send,\n  throttle: throttle,\n  isReady: isReady,\n  list: list,\n  listItem: listItem,\n  updateItem: updateItem,\n  multiUpdate: multiUpdate,\n  deleteItem: deleteItem,\n  addLog: addLog,\n  listeners: listeners,\n  listenFor: listenFor,\n  removeListener: removeListener,\n  init: init,\n  clean: clean\n};","// ClipSpace\nimport GL from '@luma.gl/constants';\nimport Model from '../lib/model';\nimport Geometry from '../geometry/geometry';\n\nconst CLIPSPACE_VERTEX_SHADER = `\\\nattribute vec2 aClipSpacePosition;\nattribute vec2 aTexCoord;\nattribute vec2 aCoordinate;\n\nvarying vec2 position;\nvarying vec2 coordinate;\nvarying vec2 uv;\n\nvoid main(void) {\n  gl_Position = vec4(aClipSpacePosition, 0., 1.);\n  position = aClipSpacePosition;\n  coordinate = aCoordinate;\n  uv = aTexCoord;\n}\n`;\n\n/* eslint-disable indent, no-multi-spaces */\nconst POSITIONS = [-1, -1, 1, -1, -1, 1, 1, 1];\n\nexport default class ClipSpace extends Model {\n  constructor(gl, opts) {\n    const TEX_COORDS = POSITIONS.map(coord => (coord === -1 ? 0 : coord));\n\n    super(\n      gl,\n      Object.assign({}, opts, {\n        vs: CLIPSPACE_VERTEX_SHADER,\n        geometry: new Geometry({\n          drawMode: GL.TRIANGLE_STRIP,\n          vertexCount: 4,\n          attributes: {\n            aClipSpacePosition: {size: 2, value: new Float32Array(POSITIONS)},\n            aTexCoord: {size: 2, value: new Float32Array(TEX_COORDS)},\n            aCoordinate: {size: 2, value: new Float32Array(TEX_COORDS)}\n          }\n        })\n      })\n    );\n    this.setVertexCount(4);\n  }\n}\n"],"sourceRoot":""}