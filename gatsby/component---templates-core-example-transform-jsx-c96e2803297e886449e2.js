(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{281:function(e,t,r){"use strict";r.r(t);var n=r(0),i=r.n(n),o=r(318),s=(r(346),r(307),r(4),r(335),r(433)),a=r(324),u=r(330),c=r(438),f=(r(9),r(3),r(5),r(2),r(413),r(15),r(311),r(308)),l=r.n(f),h=r(332),d=r(321),g={name:"transform",vs:"attribute float transform_elementID;\n\n// returns half of pixel size, used to move the pixel position to center of the pixel.\nvec2 transform_getPixelSizeHalf(vec2 size) {\n  return vec2(1.) / (2. * size);\n}\n\n// returns current elements pixel indeces [x, y],\n// where x ranges in [0 to texSize-1] and y ranges in [0 to texSize-1]\nvec2 transform_getPixelIndices(vec2 texSize, vec2 pixelSizeHalf) {\n  // Add safe offset (half of pixel height) before doing floor\n  float yIndex = floor((transform_elementID / texSize[0]) + pixelSizeHalf[1]);\n  float xIndex = transform_elementID - (yIndex * texSize[0]);\n  return vec2(xIndex, yIndex);\n}\n\n// returns current elementID's texture co-ordianate\nvec2 transform_getTexCoord(vec2 size) {\n  vec2 pixelSizeHalf = transform_getPixelSizeHalf(size);\n  vec2 indices = transform_getPixelIndices(size, pixelSizeHalf);\n  vec2 coord = indices / size + pixelSizeHalf;\n  return coord;\n}\n\n// returns current elementID's position\nvec2 transform_getPos(vec2 size) {\n  vec2 texCoord = transform_getTexCoord(size);\n  // Change from [0 1] range to [-1 1]\n  vec2 pos = (texCoord * (2.0, 2.0)) - (1., 1.);\n  return pos;\n}\n\n// returns current elementID's pixel value\nvec4 transform_getInput(sampler2D texSampler, vec2 size) {\n  vec2 texCoord = transform_getTexCoord(size);\n  vec4 textureColor = texture2D(texSampler, texCoord);\n  return textureColor;\n}\n",fs:null},p=r(400),_=r(368),v=r(395),m=r(391),T=r(342);r(130),r(306),r(62);function b(e){var t=100,r=e.match(/[^\s]+/g);if(r.length>=2&&"#version"===r[0]){var n=parseInt(r[1],10);Number.isFinite(n)&&(t=n)}return t}var x,k=r(386),E=r(351),A=r(434),O=(r(28),"transform_uSampler_"),C="transform_uSize_",w="transform_position";function y(e){var t=e.vs,r=e.sourceTextureMap,n=e.targetTextureVarying,i=e.targetTexture,o=Object.keys(r).length,s=null,a={},u=t,c={};if(o>0||n){var f=u.split("\n"),l=f.slice();if(f.forEach(function(e,t,i){if(o>0){var u=function(e,t){var r={},n=function(e){return Object(d.b)(e,["attribute","in"])}(e);if(!n)return null;var i=n.type,o=n.name;if(o&&t[o]){var s="// "+e+" => Replaced by Transform with a sampler",a=function(e){var t=""+O+e,r=""+C+e;return{samplerName:t,sizeName:r,uniformDeclerations:"  uniform sampler2D "+t+";\n  uniform vec2 "+r+";"}}(o),u=a.samplerName,c=a.sizeName,f=a.uniformDeclerations,l=Object(d.d)(i),h="  "+i+" "+o+" = transform_getInput("+u+", "+c+")."+l+";\n";r[u]=o;var g={"vs:#decl":f,"vs:#main-start":h};return{updatedLine:s,inject:g,samplerTextureMap:r}}return null}(e,r);if(u){var f=u.updatedLine,g=u.inject;l[t]=f,c=Object(h.b)([c,g]),Object.assign(a,u.samplerTextureMap),o--}}n&&!s&&(s=function(e,t){var r=Object(d.b)(e,["varying","out"]);if(!r)return null;return r.name===t?r.type:null}(e,n))}),n){Object(k.a)(i);var g=""+C+n,p={"vs:#decl":"uniform vec2 "+g+";\n","vs:#main-start":"     vec2 "+w+" = transform_getPos("+g+");\n     gl_Position = vec4("+w+", 0, 1.);\n"};c=Object(h.b)([c,p])}u=l.join("\n")}return{vs:u,targetTextureType:s,inject:c,samplerTextureMap:a}}var S=((x={})[l.a.TEXTURE_MIN_FILTER]=l.a.NEAREST,x[l.a.TEXTURE_MAG_FILTER]=l.a.NEAREST,x[l.a.TEXTURE_WRAP_S]=l.a.CLAMP_TO_EDGE,x[l.a.TEXTURE_WRAP_T]=l.a.CLAMP_TO_EDGE,x),I=function(){function e(e,t){void 0===t&&(t={}),Object(k.a)(Object(s.d)(e)),this.gl=e,this.model=null,this.elementCount=0,this.currentIndex=0,this.sourceBuffers=new Array(2),this.sourceTextures=new Array(2),this.feedbackBuffers=new Array(2),this.targetTextures=new Array(2),this.transformFeedbacks=new Array(2),this.framebuffers=new Array(2),this.resources={},this.elementIDBuffer=null,this._targetRefTexName=null,this._initialize(t),Object.seal(this)}e.isSupported=function(e){return Object(s.d)(e)};var t=e.prototype;return t.delete=function(){for(var e in this.resources)this.resources[e].delete();this.model.delete()},t.getBuffer=function(e){void 0===e&&(e=null);var t=e?this.feedbackBuffers[this.currentIndex][e]:null;return t?t instanceof a.a?t:t.buffer:null},t._getTargetTexture=function(){return this.framebuffers[this.currentIndex]?this.framebuffers[this.currentIndex].attachments[l.a.COLOR_ATTACHMENT0]:null},t.getData=function(e){var t=void 0===e?{}:e,r=t.varyingName,n=void 0===r?null:r,i=t.packed,o=void 0!==i&&i,s=this.getBuffer(n);if(s)return s.getData();Object(k.a)(!n||n===this.targetTextureVarying);var a=Object(p.b)(this.framebuffers[this.currentIndex]);if(!o)return a;for(var u=a.constructor,c=Object(d.c)(this.targetTextureType),f=new u(a.length*c/4),l=0,h=0;h<a.length;h+=4)for(var g=0;g<c;g++)f[l++]=a[h+g];return f},t.getFramebuffer=function(){return this.framebuffers[this.currentIndex]},t._getInputs=function(){var e={},t=this.currentIndex,r=Object.assign({},this.sourceBuffers[t]);if(this.hasSourceTextures||this.targetTextureVarying){for(var n in r.transform_elementID=this.elementIDBuffer,this.samplerTextureMap){var i=this.samplerTextureMap[n];e[n]=this.sourceTextures[t][i]}this._setSourceTextureParameters();var o=function(e){var t,r,n=e.sourceTextureMap,i=e.targetTextureVarying,o=e.targetTexture,s={};for(var a in i&&(t=o.width,r=o.height,s[""+C+i]=[t,r]),n){var u=n[a];t=u.width,r=u.height,s[""+C+a]=[t,r]}return s}({sourceTextureMap:this.sourceTextures[t],targetTextureVarying:this.targetTextureVarying,targetTexture:this.targetTextures[t]});Object.assign(e,o)}return{attributes:r,uniforms:e}},t.run=function(e){void 0===e&&(e={});var t=this._getInputs(),r=t.attributes,n=t.uniforms;Object.assign(n,e.uniforms);var i=Object.assign({},e.parameters),o=e.clearRenderTarget,s=void 0===o||o,a=null,u=!0;this.renderingToTexture&&(u=!1,a=this.framebuffers[this.currentIndex],Object(k.a)(a),i.viewport=[0,0,a.width,a.height],s&&a.clear({color:!0})),this.model.setAttributes(r),this.model.transform(Object.assign({},e,{transformFeedback:this.transformFeedbacks[this.currentIndex],uniforms:n,discard:u,framebuffer:a,parameters:i}))},t.swapBuffers=function(){E.a.deprecated("swapBuffers()","swap()")(),this.swap()},t.swap=function(){Object(k.a)(this.feedbackMap||this._swapTexture),this.currentIndex=(this.currentIndex+1)%2},t.update=function(e){void 0===e&&(e={}),e.elementCount&&this._setElementCount(e.elementCount);var t=e,r=t.sourceBuffers,n=void 0===r?null:r,i=t.feedbackBuffers,o=void 0===i?null:i,s=this.currentIndex;if(n||o){for(var u in o)Object(k.a)(o[u]instanceof a.a||o[u].buffer instanceof a.a);Object.assign(this.sourceBuffers[s],n),Object.assign(this.feedbackBuffers[s],o),this._createFeedbackBuffers({feedbackBuffers:o}),this.transformFeedbacks[s]&&this.transformFeedbacks[s].setBuffers(this.feedbackBuffers[s]),this._setupSwapBuffers()}var c=e,f=c._sourceTextures,l=c._targetTexture;(f||l)&&(Object.assign(this.sourceTextures[s],f),this._updateTargetTexture(l||this._targetRefTexName,s),this._setupSwapTextures())},t._setSourceTextureParameters=function(){var e=this.currentIndex;for(var t in this.sourceTextures[e])this.sourceTextures[e][t].setParameters(S)},t._setElementCount=function(e){this.elementCount!==e&&(this.elementCount<e&&this._updateElementIDBuffer(e),this.model.setVertexCount(e),this.elementCount=e)},t._updateTargetTexture=function(e,t){var r,n=this._buildTargetTexture(e,t);n&&(this.targetTextures[t]=n,this.framebuffers[t]&&(this.framebuffers[t].update({attachments:(r={},r[l.a.COLOR_ATTACHMENT0]=this.targetTextures[t],r),resizeAttachments:!1}),this.framebuffers[t].resize({width:n.width,height:n.height})))},t._initialize=function(e){void 0===e&&(e={});var t=this._validateProps(e),r=t.feedbackBuffers,n=t.feedbackMap,i=e,o=i.sourceBuffers,s=i.varyings,a=i._targetTexture,u=i._targetTextureVarying,c=i._swapTexture,f=s;n&&!Array.isArray(s)&&(f=Object.values(n)),this.varyingsArray=f,this.feedbackMap=n,this._swapTexture=c,a&&(this.targetTextureVarying=u,this.renderingToTexture=!0,Object(k.a)(this.targetTextureVarying)),this._setupBuffers({sourceBuffers:o,feedbackBuffers:r}),this._setupTextures(e),this._setupSwapBuffers(),this._setupSwapTextures(),this._buildModel(Object.assign({},e,{id:e.id||"transform-model",drawMode:e.drawMode||l.a.POINTS,varyings:f}))},t._validateProps=function(e){var t=e.feedbackBuffers,r=e.feedbackMap,n=e.destinationBuffers,i=e.sourceDestinationMap;n&&(E.a.deprecated("destinationBuffers","feedbackBuffers")(),t=t||n),i&&(E.a.deprecated("sourceDestinationMap","feedbackMap")(),r=r||i);var o=e.vs,s=e.elementCount,u=e.varyings,c=e._sourceTextures,f=e._targetTexture,l=e._targetTextureVarying,h=e._swapTexture;for(var d in Object(k.a)(o&&(u||r||f)&&s),t||{})Object(k.a)(t[d]instanceof a.a||t[d].buffer instanceof a.a);for(var g in c||{})Object(k.a)(c[g]instanceof _.a);return Object(k.a)(!f||l),Object(k.a)(!h||c[h]),{feedbackBuffers:t,feedbackMap:r}},t._setupBuffers=function(e){var t=e.sourceBuffers,r=void 0===t?null:t,n=e.feedbackBuffers,i=void 0===n?null:n;this.sourceBuffers[0]=Object.assign({},r),this.feedbackBuffers[0]=Object.assign({},i),this._createFeedbackBuffers({feedbackBuffers:i}),this.sourceBuffers[1]={},this.feedbackBuffers[1]={}},t._setupTextures=function(e){void 0===e&&(e={});var t=e,r=t._sourceTextures,n=t._targetTexture;if(this.sourceTextures[0]=Object.assign({},r),this.sourceTextures[1]={},this.hasSourceTextures=Object.keys(this.sourceTextures[0]).length>0,this.targetTextureVarying){var i=this._buildTargetTexture(n,0);Object(k.a)(i),this.targetTextures[0]=i,this.targetTextures[1]=null}},t._buildTargetTexture=function(e,t){var r,n;if(e instanceof _.a)return e;var i=this.sourceTextures[0][e];if(!i)return null;this._targetRefTexName=e;var o=Object(v.a)(i,{parameters:(r={},r[l.a.TEXTURE_MIN_FILTER]=l.a.NEAREST,r[l.a.TEXTURE_MAG_FILTER]=l.a.NEAREST,r[l.a.TEXTURE_WRAP_S]=l.a.CLAMP_TO_EDGE,r[l.a.TEXTURE_WRAP_T]=l.a.CLAMP_TO_EDGE,r),pixelStore:(n={},n[l.a.UNPACK_FLIP_Y_WEBGL]=!1,n)}),s="target-texture-"+t;return this.resources[s]&&this.resources[s].delete(),this.resources[s]=o,o},t._createFeedbackBuffers=function(e){var t=e.feedbackBuffers;if(this.feedbackMap){var r=this.currentIndex;for(var n in this.feedbackMap){var i=this.feedbackMap[n];if(!(i===this.targetTextureVarying||t&&t[i])){var o=this.sourceBuffers[r][n],s=o.byteLength,a=o.usage,u=o.accessor,c=this._createNewBuffer(i,{byteLength:s,usage:a,accessor:u});this.feedbackBuffers[r][i]=c}}}},t._createNewBuffer=function(e,t){var r=new a.a(this.gl,t);return this.resources[e]&&this.resources[e].delete(),this.resources[e]=r,r},t._setupSwapBuffers=function(){if(this.feedbackMap){var e=this.currentIndex,t=(e+1)%2;for(var r in Object.assign(this.sourceBuffers[t],this.sourceBuffers[e]),Object.assign(this.feedbackBuffers[t],this.feedbackBuffers[e]),this.feedbackMap){var n=this.feedbackMap[r];n!==this.targetTextureVarying&&(this.sourceBuffers[t][r]=this.feedbackBuffers[e][n],this.feedbackBuffers[t][n]=this.sourceBuffers[e][r],Object(k.a)(this.feedbackBuffers[t][n]instanceof a.a))}this.transformFeedbacks[t]&&this.transformFeedbacks[t].setBuffers(this.feedbackBuffers[t])}},t._setupSwapTextures=function(){if(this._swapTexture&&this.targetTextureVarying){var e=this.currentIndex,t=(e+1)%2;Object.assign(this.sourceTextures[t],this.sourceTextures[e]),this.sourceTextures[t][this._swapTexture]=this.targetTextures[e],this._updateTargetTexture(this.sourceTextures[e][this._swapTexture],t)}},t._buildModel=function(e){void 0===e&&(e={});var t=this._getShaders(e),r=t.vs,n=t.fs,i=t.modules,o=t.uniforms,s=t.inject,a=t.samplerTextureMap;this.model=new u.a(this.gl,Object.assign({},e,{vs:r,fs:n,vertexCount:e.elementCount,modules:i,uniforms:o,inject:s})),this.samplerTextureMap=a,this._setupTransformFeedback(),this._setupFramebuffers(),this._setElementCount(e.elementCount)},t._setupTransformFeedback=function(){Object(A.a)(this.feedbackBuffers[0])||(this.transformFeedbacks[0]=new m.a(this.gl,{program:this.model.program,buffers:this.feedbackBuffers[0]}),this.feedbackMap&&(this.transformFeedbacks[1]=new m.a(this.gl,{program:this.model.program,buffers:this.feedbackBuffers[1]})))},t._setupFramebuffers=function(){var e;if(this.renderingToTexture){var t=this.targetTextures[0],r=t.width,n=t.height;if(this.framebuffers[0]=new T.a(this.gl,{id:(this.id||"transform")+"-framebuffer-0",width:r,height:n,attachments:(e={},e[l.a.COLOR_ATTACHMENT0]=this.targetTextures[0],e)}),this._swapTexture){var i,o=this.targetTextures[1];r=o.width,n=o.height,this.framebuffers[1]=new T.a(this.gl,{id:(this.id||"transform")+"-framebuffer-1",width:r,height:n,attachments:(i={},i[l.a.COLOR_ATTACHMENT0]=this.targetTextures[1],i)})}}},t._updateElementIDBuffer=function(e){if(this.hasSourceTextures||this.targetTextureVarying){var t=new Float32Array(e);t.forEach(function(e,t,r){r[t]=t}),this.elementIDBuffer?this.elementIDBuffer.setData({data:t}):this.elementIDBuffer=this._createNewBuffer("elementIDBuffer",{data:t,accessor:{size:1}})}},t._getShaders=function(e){void 0===e&&(e={});var t=this._processVertexShader(e.vs),r=t.vs,n=t.uniforms,i=t.targetTextureType,o=t.inject,s=t.samplerTextureMap,a=Object(h.b)([e.inject||{},o]);return this.targetTextureType=i,{vs:r,fs:e._fs||Object(d.a)({version:b(r),input:this.targetTextureVarying,inputType:i,output:"transform_output"}),modules:this.hasSourceTextures||this.targetTextureVarying?[g].concat(e.modules||[]):e.modules,uniforms:n,inject:a,samplerTextureMap:s}},t._processVertexShader=function(e){return y({vs:e,sourceTextureMap:this.sourceTextures[this.currentIndex],targetTextureVarying:this.targetTextureVarying,targetTexture:this.targetTextures[this.currentIndex]})},e}(),L=r(446),R=r(456);var B=new Uint8Array([255,0,0,255]),M="THIS DEMO REQUIRES WEBLG2, BUT YOUR BROWSER DOESN'T SUPPORT IT",N=new R.a({id:"transform"}).enable(),j=[0,0];function F(e){j=[e.offsetX,e.offsetY]}function P(e){j=null}var D=function(e){var t,r;function n(t){var r;return void 0===t&&(t={}),(r=e.call(this,Object.assign(t,{createFramebuffer:!0}))||this).isDemoSupported=!0,r}r=e,(t=n).prototype=Object.create(r.prototype),t.prototype.constructor=t,t.__proto__=r,n.getInfo=function(){return'\n<p>\n  Instanced triangles animated on the GPU using a luma.gl <code>Transform</code> object.\n\n  This is a port of an example from\n  <a href="https://github.com/WebGLSamples/WebGL2Samples/blob/master/samples/transform_feedback_instanced.html">\n    WebGL2Samples\n  </a>\n'};var i=n.prototype;return i.onInitialize=function(e){e.canvas;var t=e.gl;if(this.isDemoSupported=Object(s.d)(t),!this.isDemoSupported)return N.error(M)(),{};t.canvas.addEventListener("mousemove",F),t.canvas.addEventListener("mouseleave",P);for(var r=new Float32Array([.015,0,-.01,.01,-.01,-.01]),n=new Float32Array(2e3),i=new Float32Array(1e3),o=new Float32Array(3e3),f=new Uint8ClampedArray(2e3),l=0;l<1e3;++l){n[2*l]=2*Math.random()-1,n[2*l+1]=2*Math.random()-1,i[l]=2*Math.random()*Math.PI,Math.random()>.5?(o[3*l+1]=1,o[3*l+2]=1):(o[3*l]=1,o[3*l+2]=1),f[2*l]=Math.floor(l/255),f[2*l+1]=l-255*f[2*l]}var h=new a.a(t,r),d=new a.a(t,o),g=new a.a(t,n),p=new a.a(t,i),_=new a.a(t,f);return{positionBuffer:h,rotationBuffer:p,colorBuffer:d,offsetBuffer:g,renderModel:new u.a(t,{id:"RenderModel",vs:"#version 300 es\n#define OFFSET_LOCATION 0\n#define ROTATION_LOCATION 1\n#define POSITION_LOCATION 2\n#define COLOR_LOCATION 3\nprecision highp float;\nprecision highp int;\nlayout(location = POSITION_LOCATION) in vec2 a_position;\nlayout(location = ROTATION_LOCATION) in float a_rotation;\nlayout(location = OFFSET_LOCATION) in vec2 a_offset;\nlayout(location = COLOR_LOCATION) in vec3 a_color;\nin vec2 instancePickingColors;\nout vec3 v_color;\nvoid main()\n{\n    v_color = a_color;\n\n    float cos_r = cos(a_rotation);\n    float sin_r = sin(a_rotation);\n    mat2 rot = mat2(\n        cos_r, sin_r,\n        -sin_r, cos_r\n    );\n    gl_Position = vec4(rot * a_position + a_offset, 0.0, 1.0);\n    picking_setPickingColor(vec3(0., instancePickingColors));\n}\n",fs:"#version 300 es\n#define ALPHA 0.9\nprecision highp float;\nprecision highp int;\nin vec3 v_color;\nout vec4 color;\nvoid main()\n{\n    color = vec4(v_color * ALPHA, ALPHA);\n    color = picking_filterColor(color);\n}\n",drawMode:t.TRIANGLE_FAN,vertexCount:3,isInstanced:!0,instanceCount:1e3,attributes:{a_position:h,a_color:[d,{divisor:1}],a_offset:[g,{divisor:1}],a_rotation:[p,{divisor:1}],instancePickingColors:[_,{divisor:1}]},modules:[c.a]}),transform:new I(t,{vs:"#version 300 es\n#define OFFSET_LOCATION 0\n#define ROTATION_LOCATION 1\n\n#define M_2PI 6.28318530718\n\n// We simulate the wandering of agents using transform feedback in this vertex shader\n// The simulation goes like this:\n// Assume there's a circle in front of the agent whose radius is WANDER_CIRCLE_R\n// the origin of which has a offset to the agent's pivot point, which is WANDER_CIRCLE_OFFSET\n// Each frame we pick a random point on this circle\n// And the agent moves MOVE_DELTA toward this target point\n// We also record the rotation facing this target point, so it will be the base rotation\n// for our next frame, which means the WANDER_CIRCLE_OFFSET vector will be on this direction\n// Thus we fake a smooth wandering behavior\n\n#define MAP_HALF_LENGTH 1.01\n#define WANDER_CIRCLE_R 0.01\n#define WANDER_CIRCLE_OFFSET 0.04\n#define MOVE_DELTA 0.001\nprecision highp float;\nprecision highp int;\nuniform float u_time;\nlayout(location = OFFSET_LOCATION) in vec2 a_offset;\nlayout(location = ROTATION_LOCATION) in float a_rotation;\nout vec2 v_offset;\nout float v_rotation;\n\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvoid main()\n{\n    float theta = M_2PI * rand(vec2(u_time, a_rotation + a_offset.x + a_offset.y));\n    float cos_r = cos(a_rotation);\n    float sin_r = sin(a_rotation);\n    mat2 rot = mat2(\n        cos_r, sin_r,\n        -sin_r, cos_r\n    );\n\n    vec2 p = WANDER_CIRCLE_R * vec2(cos(theta), sin(theta)) + vec2(WANDER_CIRCLE_OFFSET, 0.0);\n    vec2 move = normalize(rot * p);\n    v_rotation = atan(move.y, move.x);\n    v_offset = a_offset + MOVE_DELTA * move;\n\n    // wrapping at edges\n    v_offset = vec2 (\n        v_offset.x > MAP_HALF_LENGTH ? - MAP_HALF_LENGTH :\n          ( v_offset.x < - MAP_HALF_LENGTH ? MAP_HALF_LENGTH : v_offset.x ) ,\n        v_offset.y > MAP_HALF_LENGTH ? - MAP_HALF_LENGTH :\n          ( v_offset.y < - MAP_HALF_LENGTH ? MAP_HALF_LENGTH : v_offset.y )\n        );\n\n    gl_Position = vec4(v_offset, 0.0, 1.0);\n}\n",elementCount:1e3,sourceBuffers:{a_offset:g,a_rotation:p},feedbackMap:{a_offset:"v_offset",a_rotation:"v_rotation"}})}},i.onRender=function(e){var t=e.gl,r=(e.width,e.height,e.renderModel),n=(e.positionBuffer,e.colorBuffer,e.transform),i=e.framebuffer,o=e.useDevicePixels,s=e.time;if(this.isDemoSupported){n.run({uniforms:{u_time:s}}),n.swap();var a=n.getBuffer("v_offset"),u=n.getBuffer("v_rotation");if(a.setAccessor({divisor:1}),u.setAccessor({divisor:1}),r.clear({color:[0,0,0,1],depth:!0}),r.draw({attributes:{a_offset:a,a_rotation:u},parameters:{blend:!0,blendFunc:[t.SRC_ALPHA,t.ONE]}}),a.setAccessor({divisor:0}),u.setAccessor({divisor:0}),j){var c=o&&"undefined"!=typeof window?window.devicePixelRatio:1;!function(e,t,r,n,i){i.clear({color:!0,depth:!0}),n.setUniforms({picking_uActive:1}),n.draw({framebuffer:i}),n.setUniforms({picking_uActive:0});var o=Object(p.b)(i,{sourceX:t,sourceY:r,sourceWidth:1,sourceHeight:1,sourceFormat:e.RGBA,sourceType:e.UNSIGNED_BYTE});o[0]+o[1]+o[2]>0?n.updateModuleSettings({pickingSelectedColor:o,pickingHighlightColor:B}):n.updateModuleSettings({pickingSelectedColor:null})}(t,j[0]*c,t.canvas.height-j[1]*c,r,i)}}},i.onFinalize=function(e){var t=e.renderModel,r=e.transform;t&&t.delete(),r&&r.delete()},i.isSupported=function(){return this.isDemoSupported},i.getAltText=function(){return M},n}(L.a);"undefined"==typeof window||window.website||(new D).start();r.d(t,"default",function(){return H});var H=function(e){var t,r;function n(){return e.apply(this,arguments)||this}return r=e,(t=n).prototype=Object.create(r.prototype),t.prototype.constructor=t,t.__proto__=r,n.prototype.render=function(){return i.a.createElement(o.a,{AnimationLoop:D,exampleConfig:this.props.pageContext.exampleConfig})},n}(i.a.Component)},320:function(e,t,r){"use strict";r(27),r(17),r(98),r(39),r(55),r(131),r(132),r(74),r(3),r(5),r(2),r(73),r(96),r(10),r(7),r(1),Object.defineProperty(t,"__esModule",{value:!0});var n="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},i="undefined"!=typeof window&&window.addEventListener,o=new Map,s=function(){return i&&window.__SEER_INITIALIZED__},a=function(e,t){var r=o.get(e),n=Date.now();return!!(r&&n-r<t)||(o.set(e,n),!1)},u=function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(i&&s()){var r=new Set,o=JSON.stringify(t,function(e){return function(t,r){if(!r||"object"!==(void 0===r?"undefined":n(r))||!e.has(r))return e.add(r),Object.prototype.toString.call(r).slice(8,-1).includes("Array")?Array.prototype.slice.call(r,0,20):r}}(r));try{window.postMessage({type:e,payload:o,source:"seer-agent"},"*")}catch(u){if(a("seer-log",2e3))return;console.log(u)}}},c=new Map,f=function(e){if(e&&e.data&&"seer-core"===e.data.source){var t=e.data,r=t.type,n=t.payload,i=c.get(r);i&&i.forEach(function(e){return e(n)})}},l=function(){i&&!window.__SEER_LISTENER__&&(window.addEventListener("message",f),window.__SEER_LISTENER__=!0)};t.default={send:u,throttle:a,isReady:s,list:function(e,t){return u("LIST",{key:e,data:t})},listItem:function(e,t){var r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return u("LIST_ITEM",{key:e,itemKey:t,data:r})},updateItem:function(e,t,r,n){return u("UPDATE_ITEM",{key:e,itemKey:t,path:r,data:n})},multiUpdate:function(e,t,r){return u("MULTI_UPDATE_ITEM",{key:e,itemKey:t,array:r})},deleteItem:function(e,t){return u("DELETE_ITEM",{key:e,itemKey:t})},addLog:function(e,t,r){return u("ADD_LOG",{key:e,itemKey:t,msg:r})},listeners:c,listenFor:function(e,t){if(i){if(!e||!t)throw new Error("Please provide a type and callback");c.has(e)||c.set(e,[]),window.__SEER_LISTENER__||l(),c.get(e).push(t)}},removeListener:function(e){c.forEach(function(t,r){c.set(r,t.filter(function(t){return t!==e}))})},init:l,clean:function(){i&&window.__SEER_LISTENER__&&(window.removeEventListener("message",f),delete window.__SEER_LISTENER__)}}},321:function(e,t,r){"use strict";r.d(t,"b",function(){return s}),r.d(t,"a",function(){return a}),r.d(t,"d",function(){return u}),r.d(t,"c",function(){return c});r(131),r(132),r(8),r(28);var n=r(352),i="void main() {gl_FragColor = vec4(0);}",o="#version 300 es\nout vec4 transform_output;\nvoid main() {\n  transform_output = vec4(0);\n}";function s(e,t){t=Array.isArray(t)?t:[t];var r=e.replace(/^\s+/,"").split(/\s+/),n=r[0],i=r[1],o=r[2];return t.includes(n)&&i&&o?{qualifier:n,type:i,name:o.split(";")[0]}:null}function a(e){var t=void 0===e?{}:e,r=t.version,s=void 0===r?100:r,a=t.input,u=t.inputType,c=t.output;if(!a)return 300===s?o:i;var f=function(e,t){switch(t){case"float":return"vec4("+e+", 0.0, 0.0, 1.0)";case"vec2":return"vec4("+e+", 0.0, 1.0)";case"vec3":return"vec4("+e+", 1.0)";case"vec4":return e;default:return Object(n.a)(!1),null}}(a,u);return 300===s?"#version 300 es\nin "+u+" "+a+";\nout vec4 "+c+";\nvoid main() {\n  "+c+" = "+f+";\n}":"varying "+u+" "+a+";\nvoid main() {\n  gl_FragColor = "+f+";\n}"}function u(e){switch(e){case"float":return"x";case"vec2":return"xy";case"vec3":return"xyz";case"vec4":return"xyzw";default:return Object(n.a)(!1),null}}function c(e){switch(e){case"float":return 1;case"vec2":return 2;case"vec3":return 3;case"vec4":return 4;default:return Object(n.a)(!1),null}}},413:function(e,t,r){var n=r(6),i=r(441)(!1);n(n.S,"Object",{values:function(e){return i(e)}})},438:function(e,t,r){"use strict";r(335);var n={pickingSelectedColor:null,pickingHighlightColor:new Uint8Array([0,255,255,255]),pickingThreshold:1,pickingActive:!1};t.a={name:"picking",vs:"uniform vec3 picking_uSelectedColor;\nuniform float picking_uThreshold;\nuniform bool picking_uSelectedColorValid;\n\nout vec4 picking_vRGBcolor_Aselected;\n\nconst float COLOR_SCALE = 1. / 255.;\n\nbool isVertexPicked(vec3 vertexColor) {\n  return\n    picking_uSelectedColorValid &&\n    abs(vertexColor.r - picking_uSelectedColor.r) < picking_uThreshold &&\n    abs(vertexColor.g - picking_uSelectedColor.g) < picking_uThreshold &&\n    abs(vertexColor.b - picking_uSelectedColor.b) < picking_uThreshold;\n}\n\nvoid picking_setPickingColor(vec3 pickingColor) {\n  // Do the comparison with selected item color in vertex shader as it should mean fewer compares\n  picking_vRGBcolor_Aselected.a =\n    float(isVertexPicked(pickingColor));\n\n  // Stores the picking color so that the fragment shader can render it during picking\n  picking_vRGBcolor_Aselected.rgb = pickingColor * COLOR_SCALE;\n}\n",fs:"uniform bool picking_uActive; // true during rendering to offscreen picking buffer\nuniform vec3 picking_uSelectedColor;\nuniform vec4 picking_uHighlightColor;\n\nin vec4 picking_vRGBcolor_Aselected;\n\nconst float COLOR_SCALE = 1. / 255.;\n\n/*\n * Returns highlight color if this item is selected.\n */\nvec4 picking_filterHighlightColor(vec4 color) {\n  bool selected = bool(picking_vRGBcolor_Aselected.a);\n\n  if (selected) {\n    vec4 highLightColor = picking_uHighlightColor * COLOR_SCALE;\n\n    float highLightAlpha = highLightColor.a;\n    float blendedAlpha = highLightAlpha + color.a * (1.0 - highLightAlpha);\n    float highLightRatio = highLightAlpha / blendedAlpha;\n\n    vec3 blendedRGB = mix(color.rgb, highLightColor.rgb, highLightRatio);\n    return vec4(blendedRGB, blendedAlpha);\n  } else {\n    return color;\n  }\n}\n\n/*\n * Returns picking color if picking enabled else unmodified argument.\n */\nvec4 picking_filterPickingColor(vec4 color) {\n  vec3 pickingColor = picking_vRGBcolor_Aselected.rgb;\n  if (picking_uActive && length(pickingColor) < 0.001) {\n    discard;\n  }\n  return picking_uActive ? vec4(pickingColor, 1.0) : color;\n}\n\n/*\n * Returns picking color if picking is enabled if not\n * highlight color if this item is selected, otherwise unmodified argument.\n */\nvec4 picking_filterColor(vec4 color) {\n  vec4 highightColor = picking_filterHighlightColor(color);\n  return picking_filterPickingColor(highightColor);\n}\n\n",getUniforms:function(e){void 0===e&&(e=n);var t={};if(void 0!==e.pickingSelectedColor)if(null===e.pickingSelectedColor)t.picking_uSelectedColorValid=0;else{var r=[e.pickingSelectedColor[0],e.pickingSelectedColor[1],e.pickingSelectedColor[2]];t.picking_uSelectedColorValid=1,t.picking_uSelectedColor=r}return void 0!==e.pickingHighlightColor&&(t.picking_uHighlightColor=e.pickingHighlightColor),void 0!==e.pickingThreshold&&(t.picking_uThreshold=e.pickingThreshold),void 0!==e.pickingActive&&(t.picking_uActive=e.pickingActive?1:0),t}}},441:function(e,t,r){var n=r(22),i=r(59),o=r(57),s=r(83).f;e.exports=function(e){return function(t){for(var r,a=o(t),u=i(a),c=u.length,f=0,l=[];c>f;)r=u[f++],n&&!s.call(a,r)||l.push(e?[r,a[r]]:a[r]);return l}}}}]);
//# sourceMappingURL=component---templates-core-example-transform-jsx-c96e2803297e886449e2.js.map