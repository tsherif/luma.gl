{"version":3,"sources":["webpack:///../modules/shadertools/src/modules/transform/transform.js","webpack:///../modules/webgl/src/glsl-utils/get-shader-version.js","webpack:///../modules/core/src/lib/transform-shader-utils.js","webpack:///../modules/core/src/lib/transform.js","webpack:///../examples/core/transform/app.js","webpack:///./templates/core/example-transform.jsx","webpack:///../node_modules/seer/dist/index.js","webpack:///../modules/shadertools/src/utils/shader-utils.js","webpack:///./node_modules/core-js/modules/es7.object.values.js","webpack:///../modules/shadertools/src/modules/picking/picking.js","webpack:///./node_modules/core-js/modules/_object-to-array.js"],"names":["transform_transform","name","vs","fs","getShaderVersion","source","version","words","v","parseInt","Number","SAMPLER_UNIFORM_PREFIX","SIZE_UNIFORM_PREFIX","VS_POS_VARIABLE","updateForTextures","_ref","sourceTextureMap","targetTextureVarying","targetTexture","sourceCount","Object","length","targetTextureType","samplerTextureMap","updatedVs","finalInject","vsLines","updateVsLines","slice","line","index","lines","updated","textureMap","attributeData","getQualifierDetails","getAttributeDefinition","type","updatedLine","_getSamplerDecleratio","textureName","samplerName","sizeName","uniformDeclerations","getSamplerDeclerations","channels","typeToChannelSuffix","sampleInstruction","inject","vs:#decl","vs:#main-start","processAttributeDefinition","combineInjects","varying","qualaiferDetails","getVaryingType","assert","SRC_TEX_PARAMETER_OVERRIDES","_SRC_TEX_PARAMETER_OV","GL","TEXTURE_MIN_FILTER","NEAREST","TEXTURE_MAG_FILTER","TEXTURE_WRAP_S","CLAMP_TO_EDGE","TEXTURE_WRAP_T","Transform","gl","props","isWebGL2","this","model","elementCount","currentIndex","sourceBuffers","Array","sourceTextures","feedbackBuffers","targetTextures","transformFeedbacks","framebuffers","resources","elementIDBuffer","_targetRefTexName","_initialize","isSupported","delete","getBuffer","varyingName","bufferOrParams","buffer","_getTargetTexture","attachments","COLOR_ATTACHMENT0","getData","_temp","_ref$varyingName","_ref$packed","packed","pixels","readPixelsToArray","ArrayType","constructor","channelCount","typeToChannelCount","packedPixels","packCount","i","j","getFramebuffer","_getInputs","uniforms","current","attributes","hasSourceTextures","sampler","_setSourceTextureParameters","sizeUniforms","_ref2","width","height","_sourceTextureMap$tex","getSizeUniforms","run","opts","_this$_getInputs","parameters","_opts$clearRenderTarg","clearRenderTarget","framebuffer","discard","renderingToTexture","color","setAttributes","transform","assign","transformFeedback","swapBuffers","log","swap","feedbackMap","update","_setElementCount","_opts2","_opts2$sourceBuffers","_opts2$feedbackBuffer","bufferName","_createFeedbackBuffers","setBuffers","_setupSwapBuffers","_opts3","_sourceTextures","_targetTexture","_updateTargetTexture","_setupSwapTextures","setParameters","_updateElementIDBuffer","setVertexCount","_attachments","_buildTargetTexture","texture","resizeAttachments","resize","_this$_validateProps","_validateProps","_props","varyings","_targetTextureVarying","_swapTexture","varyingsArray","_setupBuffers","_setupTextures","_buildModel","id","drawMode","POINTS","destinationBuffers","sourceDestinationMap","_ref2$sourceBuffers","_ref2$feedbackBuffers","_props2","_parameters","_pixelStore","textureOrAttribute","texture_2d","refTexture","cloneTextureFrom","pixelStore","UNPACK_FLIP_Y_WEBGL","resourceName","_ref3","sourceBufferName","feedbackBufferName","sourceBuffer","byteLength","usage","accessor","_createNewBuffer","classes_buffer","next","srcName","dstName","_this$_getShaders","_getShaders","modules","lib_model","vertexCount","_setupTransformFeedback","_setupFramebuffers","isObjectEmpty","transform_feedback","program","buffers","_attachments2","_this$targetTextures$","classes_framebuffer","_attachments3","_this$targetTextures$2","elementIds","Float32Array","_","array","setData","data","size","_this$_processVertexS","_processVertexShader","combinedInject","getPassthroughFS","input","inputType","output","concat","RED","Uint8Array","ALT_TEXT","lib_log","enable","pickPosition","mousemove","e","offsetX","mouseleave","AppAnimationLoop","_this","_AnimationLoop","call","createFramebuffer","isDemoSupported","getInfo","onInitialize","canvas","trianglePositions","instanceOffsets","NUM_INSTANCES","instanceRotations","instanceColors","pickingColors","Uint8ClampedArray","Math","random","positionBuffer","colorBuffer","offsetBuffer","rotationBuffer","pickingColorBuffer","renderModel","TRIANGLE_FAN","isInstanced","instanceCount","a_position","a_color","divisor","a_offset","a_rotation","instancePickingColors","picking","transform_Transform","onRender","useDevicePixels","time","u_time","depth","blend","blendFunc","SRC_ALPHA","ONE","dpr","window","devicePixelRatio","pickX","pickY","picking_uActive","sourceX","sourceY","sourceWidth","sourceHeight","sourceFormat","RGBA","sourceType","UNSIGNED_BYTE","pickingSelectedColor","pickingHighlightColor","pickInstance","onFinalize","getAltText","AnimationLoop","website","app_AppAnimationLoop","animationLoop","Example","render","react_default","a","createElement","animation_loop_example_page","exampleConfig","pageContext","React","Component","__webpack_require__","defineProperty","exports","value","_typeof","Symbol","iterator","obj","prototype","isBrowser","addEventListener","timers","Map","isReady","__SEER_INITIALIZED__","throttle","key","delay","get","now","Date","set","send","arguments","undefined","seen","Set","payload","JSON","stringify","has","add","toString","includes","replacer","postMessage","console","listeners","listener","message","_message$data","typeListeners","forEach","cb","init","__SEER_LISTENER__","list","listItem","itemKey","updateItem","path","multiUpdate","deleteItem","addLog","msg","listenFor","Error","push","removeListener","filter","l","clean","removeEventListener","FS100","FS300","qualifiers","qualifier","definition","_ref$version","outputValue","variable","convertToVec4","$export","$values","S","values","it","DEFAULT_MODULE_OPTIONS","pickingThreshold","pickingActive","__webpack_exports__","getUniforms","selectedColor","DESCRIPTORS","getKeys","toIObject","isEnum","f","module","isEntries","O","keys","result"],"mappings":"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","file":"component---templates-core-example-transform-jsx-c96e2803297e886449e2.js","sourcesContent":["// Private shader module used by `Transform`\n\nconst vs = `\\\nattribute float transform_elementID;\n\n// returns half of pixel size, used to move the pixel position to center of the pixel.\nvec2 transform_getPixelSizeHalf(vec2 size) {\n  return vec2(1.) / (2. * size);\n}\n\n// returns current elements pixel indeces [x, y],\n// where x ranges in [0 to texSize-1] and y ranges in [0 to texSize-1]\nvec2 transform_getPixelIndices(vec2 texSize, vec2 pixelSizeHalf) {\n  // Add safe offset (half of pixel height) before doing floor\n  float yIndex = floor((transform_elementID / texSize[0]) + pixelSizeHalf[1]);\n  float xIndex = transform_elementID - (yIndex * texSize[0]);\n  return vec2(xIndex, yIndex);\n}\n\n// returns current elementID's texture co-ordianate\nvec2 transform_getTexCoord(vec2 size) {\n  vec2 pixelSizeHalf = transform_getPixelSizeHalf(size);\n  vec2 indices = transform_getPixelIndices(size, pixelSizeHalf);\n  vec2 coord = indices / size + pixelSizeHalf;\n  return coord;\n}\n\n// returns current elementID's position\nvec2 transform_getPos(vec2 size) {\n  vec2 texCoord = transform_getTexCoord(size);\n  // Change from [0 1] range to [-1 1]\n  vec2 pos = (texCoord * (2.0, 2.0)) - (1., 1.);\n  return pos;\n}\n\n// returns current elementID's pixel value\nvec4 transform_getInput(sampler2D texSampler, vec2 size) {\n  vec2 texCoord = transform_getTexCoord(size);\n  vec4 textureColor = texture2D(texSampler, texCoord);\n  return textureColor;\n}\n`;\n\nexport default {\n  name: 'transform',\n  vs,\n  fs: null\n};\n","// returns GLSL shader version of given shader string\nexport default function getShaderVersion(source) {\n  let version = 100;\n  const words = source.match(/[^\\s]+/g);\n  if (words.length >= 2 && words[0] === '#version') {\n    const v = parseInt(words[1], 10);\n    if (Number.isFinite(v)) {\n      version = v;\n    }\n  }\n  return version;\n}\n","import {assert} from '../utils';\nimport {combineInjects, getQualifierDetails, typeToChannelSuffix} from '@luma.gl/shadertools';\n\nconst SAMPLER_UNIFORM_PREFIX = 'transform_uSampler_';\nconst SIZE_UNIFORM_PREFIX = 'transform_uSize_';\nconst VS_POS_VARIABLE = 'transform_position';\n\n// Scan provided vertex shader\n// for each texture attribute, inject sampler instructions and build uniforms for sampler\n// for texture target, get varying type and inject position instruction\nexport function updateForTextures({vs, sourceTextureMap, targetTextureVarying, targetTexture}) {\n  const texAttributeNames = Object.keys(sourceTextureMap);\n  let sourceCount = texAttributeNames.length;\n  let targetTextureType = null;\n  const samplerTextureMap = {};\n  let updatedVs = vs;\n  let finalInject = {};\n\n  if (sourceCount > 0 || targetTextureVarying) {\n    const vsLines = updatedVs.split('\\n');\n    const updateVsLines = vsLines.slice();\n    vsLines.forEach((line, index, lines) => {\n      // TODO add early exit\n      if (sourceCount > 0) {\n        const updated = processAttributeDefinition(line, sourceTextureMap);\n        if (updated) {\n          const {updatedLine, inject} = updated;\n          updateVsLines[index] = updatedLine;\n          // sampleInstructions.push(sampleInstruction);\n          finalInject = combineInjects([finalInject, inject]);\n          Object.assign(samplerTextureMap, updated.samplerTextureMap);\n          sourceCount--;\n        }\n      }\n      if (targetTextureVarying && !targetTextureType) {\n        targetTextureType = getVaryingType(line, targetTextureVarying);\n      }\n    });\n\n    if (targetTextureVarying) {\n      assert(targetTexture);\n      const sizeName = `${SIZE_UNIFORM_PREFIX}${targetTextureVarying}`;\n\n      const uniformDeclaration = `uniform vec2 ${sizeName};\\n`;\n      const posInstructions = `\\\n     vec2 ${VS_POS_VARIABLE} = transform_getPos(${sizeName});\n     gl_Position = vec4(${VS_POS_VARIABLE}, 0, 1.);\\n`;\n      const inject = {\n        'vs:#decl': uniformDeclaration,\n        'vs:#main-start': posInstructions\n      };\n      finalInject = combineInjects([finalInject, inject]);\n    }\n    updatedVs = updateVsLines.join('\\n');\n  }\n  return {\n    // updated vertex shader (commented texture attribute definition)\n    vs: updatedVs,\n    // type (float, vec2, vec3 of vec4) target texture varying\n    targetTextureType,\n    // required vertex and fragment shader injects\n    inject: finalInject,\n    // map of sampler name to texture name, can be used to set attributes\n    // usefull when swapping textures, as source and destination texture change when swap is called.\n    samplerTextureMap\n  };\n}\n\n// builds and returns an object contaning size uniform for each texture\nexport function getSizeUniforms({sourceTextureMap, targetTextureVarying, targetTexture}) {\n  const uniforms = {};\n  let width;\n  let height;\n  if (targetTextureVarying) {\n    ({width, height} = targetTexture);\n    uniforms[`${SIZE_UNIFORM_PREFIX}${targetTextureVarying}`] = [width, height];\n  }\n  for (const textureName in sourceTextureMap) {\n    ({width, height} = sourceTextureMap[textureName]);\n    uniforms[`${SIZE_UNIFORM_PREFIX}${textureName}`] = [width, height];\n  }\n  return uniforms;\n}\n\n// Checks if provided line is defining an attribute, if so returns details otherwise null\nfunction getAttributeDefinition(line) {\n  return getQualifierDetails(line, ['attribute', 'in']);\n}\n\nfunction getSamplerDeclerations(textureName) {\n  const samplerName = `${SAMPLER_UNIFORM_PREFIX}${textureName}`;\n  const sizeName = `${SIZE_UNIFORM_PREFIX}${textureName}`;\n  const uniformDeclerations = `\\\n  uniform sampler2D ${samplerName};\n  uniform vec2 ${sizeName};`;\n  return {samplerName, sizeName, uniformDeclerations};\n}\n\n// Return size (float, vec2 etc) of a given varying, null if doens't exist.\nexport function getVaryingType(line, varying) {\n  const qualaiferDetails = getQualifierDetails(line, ['varying', 'out']);\n  if (!qualaiferDetails) {\n    return null;\n  }\n  return qualaiferDetails.name === varying ? qualaiferDetails.type : null;\n}\n\n// build required definitions, sample instructions for each texture attribute\nexport function processAttributeDefinition(line, textureMap) {\n  const samplerTextureMap = {};\n  const attributeData = getAttributeDefinition(line);\n  if (!attributeData) {\n    return null;\n  }\n  const {type, name} = attributeData;\n  if (name && textureMap[name]) {\n    // eslint-disable-next-line no-useless-escape\n    const updatedLine = `\\// ${line} => Replaced by Transform with a sampler`;\n    const {samplerName, sizeName, uniformDeclerations} = getSamplerDeclerations(name);\n\n    const channels = typeToChannelSuffix(type);\n    const sampleInstruction = `  ${type} ${name} = transform_getInput(${samplerName}, ${sizeName}).${channels};\\n`;\n\n    samplerTextureMap[samplerName] = name;\n    const inject = {\n      'vs:#decl': uniformDeclerations,\n      'vs:#main-start': sampleInstruction\n    };\n\n    // samplerNameMap\n    return {\n      // update vertex shader line.\n      updatedLine,\n      // inject object with sampler instructions.\n      inject,\n      // sampler name to texture name map\n      samplerTextureMap\n    };\n  }\n  return null;\n}\n","import GL from '@luma.gl/constants';\nimport {combineInjects} from '@luma.gl/shadertools';\nimport {_transform as transform, getPassthroughFS, typeToChannelCount} from '@luma.gl/shadertools';\nimport {\n  isWebGL2,\n  Buffer,\n  Framebuffer,\n  Texture2D,\n  TransformFeedback,\n  readPixelsToArray,\n  getShaderVersion,\n  cloneTextureFrom\n} from '@luma.gl/webgl';\nimport {log, isObjectEmpty, assert} from '../utils';\nimport Model from './model';\nimport {updateForTextures, getSizeUniforms} from './transform-shader-utils';\n\n// Texture parameters needed so sample can precisely pick pixel for given element id.\nconst SRC_TEX_PARAMETER_OVERRIDES = {\n  [GL.TEXTURE_MIN_FILTER]: GL.NEAREST,\n  [GL.TEXTURE_MAG_FILTER]: GL.NEAREST,\n  [GL.TEXTURE_WRAP_S]: GL.CLAMP_TO_EDGE,\n  [GL.TEXTURE_WRAP_T]: GL.CLAMP_TO_EDGE\n};\nconst FS_OUTPUT_VARIABLE = 'transform_output';\n\nexport default class Transform {\n  static isSupported(gl) {\n    // For now WebGL2 only\n    return isWebGL2(gl);\n  }\n\n  constructor(gl, props = {}) {\n    assert(isWebGL2(gl));\n\n    this.gl = gl;\n    this.model = null;\n    this.elementCount = 0;\n    this.currentIndex = 0;\n\n    // Source and destination resources are stored in two element Arrays for easier swapping when\n    // 'feedbackMap' is provided. If not only the first array elment is used.\n\n    // Each array element is an object with attribute name as Key and Buffer object as value.\n    this.sourceBuffers = new Array(2);\n\n    // Each array element is an object with attribute name as Key and Texture object as value.\n    this.sourceTextures = new Array(2);\n\n    // Each array element is an object with varying name as Key and Buffer object as value.\n    this.feedbackBuffers = new Array(2);\n\n    // Each array element is a Texture object used as color attachment for framebuffer.\n    this.targetTextures = new Array(2);\n\n    // Each array element is a TransformFeedback object.\n    this.transformFeedbacks = new Array(2);\n\n    // Each array element is a Framebuffer object.\n    this.framebuffers = new Array(2);\n\n    this.resources = {}; // resources to be deleted\n\n    this.elementIDBuffer = null;\n\n    // reference source texture name for target texture\n    this._targetRefTexName = null;\n\n    this._initialize(props);\n    Object.seal(this);\n  }\n\n  // Delete owned resources.\n  delete() {\n    for (const name in this.resources) {\n      this.resources[name].delete();\n    }\n    this.model.delete();\n  }\n\n  // Return Buffer object for given varying name.\n  getBuffer(varyingName = null) {\n    const bufferOrParams = varyingName\n      ? this.feedbackBuffers[this.currentIndex][varyingName]\n      : null;\n    if (!bufferOrParams) {\n      return null;\n    }\n    return bufferOrParams instanceof Buffer ? bufferOrParams : bufferOrParams.buffer;\n  }\n\n  // Returns the color attachment textuer from current framebuffer target\n  _getTargetTexture() {\n    if (this.framebuffers[this.currentIndex]) {\n      return this.framebuffers[this.currentIndex].attachments[GL.COLOR_ATTACHMENT0];\n    }\n    return null;\n  }\n\n  // Return data either from Buffer or from Texture\n  getData({varyingName = null, packed = false} = {}) {\n    // Either there should be specified feedbackBuffer or we should be rendering to a texture\n    const buffer = this.getBuffer(varyingName);\n    if (buffer) {\n      return buffer.getData();\n    }\n\n    // When varyingName is not provided return data from framebuffer object.\n    assert(!varyingName || varyingName === this.targetTextureVarying);\n\n    const pixels = readPixelsToArray(this.framebuffers[this.currentIndex]);\n\n    if (!packed) {\n      return pixels;\n    }\n\n    // readPixels returns 4 elements for each pixel, pack the elements when requested\n    const ArrayType = pixels.constructor;\n    const channelCount = typeToChannelCount(this.targetTextureType);\n    const packedPixels = new ArrayType((pixels.length * channelCount) / 4);\n    let packCount = 0;\n    for (let i = 0; i < pixels.length; i += 4) {\n      for (let j = 0; j < channelCount; j++) {\n        packedPixels[packCount++] = pixels[i + j];\n      }\n    }\n    return packedPixels;\n  }\n\n  // returns current framebuffer object that is being used.\n  getFramebuffer() {\n    return this.framebuffers[this.currentIndex];\n  }\n\n  _getInputs() {\n    const uniforms = {};\n    const current = this.currentIndex;\n\n    // Buffer inputs\n    const attributes = Object.assign({}, this.sourceBuffers[current]);\n\n    // Texture inputs\n    if (this.hasSourceTextures || this.targetTextureVarying) {\n      // TODO: add option not generate position using element id.\n      attributes.transform_elementID = this.elementIDBuffer;\n      for (const sampler in this.samplerTextureMap) {\n        const textureName = this.samplerTextureMap[sampler];\n        uniforms[sampler] = this.sourceTextures[current][textureName];\n      }\n      // Also update size uniforms , add samplerSizeMap\n      this._setSourceTextureParameters();\n\n      // get texture size uniforms\n      const sizeUniforms = getSizeUniforms({\n        sourceTextureMap: this.sourceTextures[current],\n        targetTextureVarying: this.targetTextureVarying,\n        targetTexture: this.targetTextures[current]\n      });\n      Object.assign(uniforms, sizeUniforms);\n    }\n    return {attributes, uniforms};\n  }\n\n  // Run one transform feedback loop.\n  run(opts = {}) {\n    const {attributes, uniforms} = this._getInputs();\n    Object.assign(uniforms, opts.uniforms);\n    const parameters = Object.assign({}, opts.parameters);\n    const {clearRenderTarget = true} = opts;\n    let framebuffer = null;\n    let discard = true;\n\n    if (this.renderingToTexture) {\n      discard = false;\n      framebuffer = this.framebuffers[this.currentIndex];\n      assert(framebuffer);\n      parameters.viewport = [0, 0, framebuffer.width, framebuffer.height];\n      if (clearRenderTarget) {\n        framebuffer.clear({color: true});\n      }\n    }\n    this.model.setAttributes(attributes);\n    this.model.transform(\n      Object.assign({}, opts, {\n        transformFeedback: this.transformFeedbacks[this.currentIndex],\n        uniforms,\n        discard,\n        framebuffer,\n        parameters\n      })\n    );\n  }\n\n  // Swap source and destination buffers and textures.\n  swapBuffers() {\n    log.deprecated('swapBuffers()', 'swap()')();\n    this.swap();\n  }\n\n  // Swap source and destination buffers and textures.\n  swap() {\n    assert(this.feedbackMap || this._swapTexture);\n    this.currentIndex = (this.currentIndex + 1) % 2;\n  }\n\n  // Update some or all buffer bindings.\n  update(opts = {}) {\n    if (opts.elementCount) {\n      this._setElementCount(opts.elementCount);\n    }\n\n    const {sourceBuffers = null, feedbackBuffers = null} = opts;\n    const {currentIndex} = this;\n    if (sourceBuffers || feedbackBuffers) {\n      for (const bufferName in feedbackBuffers) {\n        assert(\n          feedbackBuffers[bufferName] instanceof Buffer ||\n            feedbackBuffers[bufferName].buffer instanceof Buffer\n        );\n      }\n\n      Object.assign(this.sourceBuffers[currentIndex], sourceBuffers);\n      Object.assign(this.feedbackBuffers[currentIndex], feedbackBuffers);\n      this._createFeedbackBuffers({feedbackBuffers});\n      if (this.transformFeedbacks[currentIndex]) {\n        this.transformFeedbacks[currentIndex].setBuffers(this.feedbackBuffers[currentIndex]);\n      }\n\n      // Buffers have changed, need to re-setup swap buffers.\n      this._setupSwapBuffers();\n    }\n\n    const {_sourceTextures, _targetTexture} = opts;\n    if (_sourceTextures || _targetTexture) {\n      Object.assign(this.sourceTextures[currentIndex], _sourceTextures);\n      // if _targetTexture specified use it, other wise rebuild traget texture using\n      // '_targetRefTexName' as coresponding source texture may have been update.\n      this._updateTargetTexture(_targetTexture || this._targetRefTexName, currentIndex);\n      // textures have changed, need to re-setup swap textures.\n      this._setupSwapTextures();\n    }\n  }\n\n  // set texture filtering parameters on source textures.\n  _setSourceTextureParameters() {\n    const index = this.currentIndex;\n    for (const name in this.sourceTextures[index]) {\n      this.sourceTextures[index][name].setParameters(SRC_TEX_PARAMETER_OVERRIDES);\n    }\n  }\n\n  // set element count and updated elementID buffer if needed.\n  _setElementCount(elementCount) {\n    if (this.elementCount === elementCount) {\n      return;\n    }\n    if (this.elementCount < elementCount) {\n      this._updateElementIDBuffer(elementCount);\n    }\n    this.model.setVertexCount(elementCount);\n    this.elementCount = elementCount;\n  }\n\n  // sets target texture for rendering by updating framebuffer\n  _updateTargetTexture(texture, index) {\n    const targetTexture = this._buildTargetTexture(texture, index);\n    if (targetTexture) {\n      this.targetTextures[index] = targetTexture;\n      if (this.framebuffers[index]) {\n        // First update texture without re-sizing attachments\n        this.framebuffers[index].update({\n          attachments: {[GL.COLOR_ATTACHMENT0]: this.targetTextures[index]},\n          resizeAttachments: false\n        });\n        // Resize to new taget texture size\n        this.framebuffers[index].resize({\n          width: targetTexture.width,\n          height: targetTexture.height\n        });\n      }\n    }\n  }\n\n  // Private\n\n  _initialize(props = {}) {\n    const {feedbackBuffers, feedbackMap} = this._validateProps(props);\n    const {sourceBuffers, varyings, _targetTexture, _targetTextureVarying, _swapTexture} = props;\n\n    let varyingsArray = varyings;\n    if (feedbackMap && !Array.isArray(varyings)) {\n      varyingsArray = Object.values(feedbackMap);\n    }\n    this.varyingsArray = varyingsArray;\n    this.feedbackMap = feedbackMap;\n    this._swapTexture = _swapTexture;\n    if (_targetTexture) {\n      this.targetTextureVarying = _targetTextureVarying;\n      this.renderingToTexture = true;\n      assert(this.targetTextureVarying);\n    }\n\n    this._setupBuffers({sourceBuffers, feedbackBuffers});\n    this._setupTextures(props);\n    this._setupSwapBuffers();\n    this._setupSwapTextures();\n    this._buildModel(\n      Object.assign({}, props, {\n        id: props.id || 'transform-model',\n        drawMode: props.drawMode || GL.POINTS,\n        varyings: varyingsArray\n      })\n    );\n  }\n\n  // assert on required parameters\n  /* eslint-disable complexity */\n  _validateProps(props) {\n    let {feedbackBuffers, feedbackMap} = props;\n\n    // backward compitability\n    const {destinationBuffers, sourceDestinationMap} = props;\n    if (destinationBuffers) {\n      log.deprecated('destinationBuffers', 'feedbackBuffers')();\n      feedbackBuffers = feedbackBuffers || destinationBuffers;\n    }\n    if (sourceDestinationMap) {\n      log.deprecated('sourceDestinationMap', 'feedbackMap')();\n      feedbackMap = feedbackMap || sourceDestinationMap;\n    }\n\n    // assert on required parameters\n    const {vs, elementCount, varyings} = props;\n    const {_sourceTextures, _targetTexture, _targetTextureVarying, _swapTexture} = props;\n\n    assert(\n      vs &&\n        // destinations are provided\n        (varyings || feedbackMap || _targetTexture) &&\n        // when only writting to textures auto-duduce from texture dimenstions\n        elementCount\n    );\n\n    for (const bufferName in feedbackBuffers || {}) {\n      assert(\n        feedbackBuffers[bufferName] instanceof Buffer ||\n          feedbackBuffers[bufferName].buffer instanceof Buffer\n      );\n    }\n    for (const textureName in _sourceTextures || {}) {\n      assert(_sourceTextures[textureName] instanceof Texture2D);\n    }\n\n    // If rendering to texture , varying is provided\n    assert(!_targetTexture || _targetTextureVarying);\n\n    // swap texture must be a valid source texture\n    assert(!_swapTexture || _sourceTextures[_swapTexture]);\n\n    return {feedbackBuffers, feedbackMap};\n  }\n  /* eslint-enable complexity */\n\n  // setup source and destination buffers\n  _setupBuffers({sourceBuffers = null, feedbackBuffers = null}) {\n    this.sourceBuffers[0] = Object.assign({}, sourceBuffers);\n    this.feedbackBuffers[0] = Object.assign({}, feedbackBuffers);\n    this._createFeedbackBuffers({feedbackBuffers});\n    this.sourceBuffers[1] = {};\n    this.feedbackBuffers[1] = {};\n  }\n\n  // setup source and destination textures\n  _setupTextures(props = {}) {\n    const {_sourceTextures, _targetTexture} = props;\n    // Setup source texture\n    this.sourceTextures[0] = Object.assign({}, _sourceTextures);\n    this.sourceTextures[1] = {};\n    this.hasSourceTextures = Object.keys(this.sourceTextures[0]).length > 0;\n\n    if (this.targetTextureVarying) {\n      const texture = this._buildTargetTexture(_targetTexture, 0);\n      // Either a texture or refAttribute must be provided\n      assert(texture);\n      this.targetTextures[0] = texture;\n      this.targetTextures[1] = null;\n    }\n  }\n\n  // Builds target texture using source reference or provided texture object.\n  _buildTargetTexture(textureOrAttribute, index) {\n    if (textureOrAttribute instanceof Texture2D) {\n      return textureOrAttribute;\n    }\n    const refTexture = this.sourceTextures[0][textureOrAttribute];\n    if (!refTexture) {\n      return null;\n    }\n    // save reference texture name, when corresponding source texture is updated\n    // we also update target texture.\n    this._targetRefTexName = textureOrAttribute;\n    const texture = cloneTextureFrom(refTexture, {\n      parameters: {\n        [GL.TEXTURE_MIN_FILTER]: GL.NEAREST,\n        [GL.TEXTURE_MAG_FILTER]: GL.NEAREST,\n        [GL.TEXTURE_WRAP_S]: GL.CLAMP_TO_EDGE,\n        [GL.TEXTURE_WRAP_T]: GL.CLAMP_TO_EDGE\n      },\n      pixelStore: {\n        [GL.UNPACK_FLIP_Y_WEBGL]: false\n      }\n    });\n\n    // track the new texture created above\n    // there can only be two target textures, index 0 and index 1\n    const resourceName = `target-texture-${index}`;\n    if (this.resources[resourceName]) {\n      this.resources[resourceName].delete();\n    }\n    this.resources[resourceName] = texture;\n\n    return texture;\n  }\n\n  // auto create any feedback buffers\n  _createFeedbackBuffers({feedbackBuffers}) {\n    if (!this.feedbackMap) {\n      // feedbackMap required to auto create buffers.\n      return;\n    }\n    const current = this.currentIndex;\n    for (const sourceBufferName in this.feedbackMap) {\n      const feedbackBufferName = this.feedbackMap[sourceBufferName];\n      if (\n        feedbackBufferName !== this.targetTextureVarying &&\n        (!feedbackBuffers || !feedbackBuffers[feedbackBufferName])\n      ) {\n        // Create new buffer with same layout and settings as source buffer\n        const sourceBuffer = this.sourceBuffers[current][sourceBufferName];\n        const {byteLength, usage, accessor} = sourceBuffer;\n        const buffer = this._createNewBuffer(feedbackBufferName, {byteLength, usage, accessor});\n        this.feedbackBuffers[current][feedbackBufferName] = buffer;\n      }\n    }\n  }\n\n  // Create a buffer and add to list of buffers to be deleted.\n  _createNewBuffer(name, opts) {\n    const buffer = new Buffer(this.gl, opts);\n    if (this.resources[name]) {\n      this.resources[name].delete();\n    }\n    this.resources[name] = buffer;\n    return buffer;\n  }\n\n  // setup buffers for swapping.\n  // Second set of source and feedback objects are setup to point\n  // to corresponding feedback and source buffers.\n  _setupSwapBuffers() {\n    if (!this.feedbackMap) {\n      // feedbackMap required set up swap buffers.\n      return;\n    }\n    const current = this.currentIndex;\n    const next = (current + 1) % 2;\n\n    // Copy all buffers/textures so un-mapped sources will remain same\n    Object.assign(this.sourceBuffers[next], this.sourceBuffers[current]);\n    Object.assign(this.feedbackBuffers[next], this.feedbackBuffers[current]);\n\n    for (const srcName in this.feedbackMap) {\n      const dstName = this.feedbackMap[srcName];\n      // TODO: add textureMap and remove this if loop\n      if (dstName !== this.targetTextureVarying) {\n        this.sourceBuffers[next][srcName] = this.feedbackBuffers[current][dstName];\n        this.feedbackBuffers[next][dstName] = this.sourceBuffers[current][srcName];\n\n        // make sure the new destination buffer is a Buffer object\n        assert(this.feedbackBuffers[next][dstName] instanceof Buffer);\n      }\n    }\n\n    // When triggered by `update()` TranformFeedback objects are already set up,\n    // if so update buffers\n    if (this.transformFeedbacks[next]) {\n      this.transformFeedbacks[next].setBuffers(this.feedbackBuffers[next]);\n    }\n\n    // TODO: add swap support for targetTexture and framebuffers\n  }\n\n  // setup textures for swapping.\n  _setupSwapTextures() {\n    if (!this._swapTexture || !this.targetTextureVarying) {\n      // Must be rendering to a texture and _swapTexture is provided\n      return;\n    }\n    const current = this.currentIndex;\n    const next = (current + 1) % 2;\n\n    Object.assign(this.sourceTextures[next], this.sourceTextures[current]);\n\n    this.sourceTextures[next][this._swapTexture] = this.targetTextures[current];\n\n    this._updateTargetTexture(this.sourceTextures[current][this._swapTexture], next);\n  }\n\n  // build Model and TransformFeedback objects\n  _buildModel(props = {}) {\n    const {vs, fs, modules, uniforms, inject, samplerTextureMap} = this._getShaders(props);\n    this.model = new Model(\n      this.gl,\n      Object.assign({}, props, {\n        vs,\n        fs,\n        vertexCount: props.elementCount,\n        modules,\n        uniforms,\n        inject\n      })\n    );\n    this.samplerTextureMap = samplerTextureMap;\n\n    // setup TF to capture varyings.\n    this._setupTransformFeedback();\n\n    // setup Framebuffer object for rendering to Texture.\n    this._setupFramebuffers();\n\n    // create buffer to access source texture pixesl.\n    this._setElementCount(props.elementCount);\n  }\n\n  // setup TransformFeedback objects to capture the results\n  _setupTransformFeedback() {\n    if (isObjectEmpty(this.feedbackBuffers[0])) {\n      return;\n    }\n    this.transformFeedbacks[0] = new TransformFeedback(this.gl, {\n      program: this.model.program,\n      buffers: this.feedbackBuffers[0]\n    });\n\n    // If buffers are swappable setup second transform feedback object.\n    if (this.feedbackMap) {\n      this.transformFeedbacks[1] = new TransformFeedback(this.gl, {\n        program: this.model.program,\n        buffers: this.feedbackBuffers[1]\n      });\n    }\n  }\n\n  // setup framebuffers with texture attachments, to which results are rendered\n  _setupFramebuffers() {\n    if (!this.renderingToTexture) {\n      return;\n    }\n\n    let {width, height} = this.targetTextures[0];\n    this.framebuffers[0] = new Framebuffer(this.gl, {\n      id: `${this.id || 'transform'}-framebuffer-0`,\n      width,\n      height,\n      attachments: {\n        [GL.COLOR_ATTACHMENT0]: this.targetTextures[0]\n      }\n    });\n\n    if (this._swapTexture) {\n      ({width, height} = this.targetTextures[1]);\n\n      this.framebuffers[1] = new Framebuffer(this.gl, {\n        id: `${this.id || 'transform'}-framebuffer-1`,\n        width,\n        height,\n        attachments: {\n          [GL.COLOR_ATTACHMENT0]: this.targetTextures[1]\n        }\n      });\n    }\n  }\n\n  // create/update buffer to access source texture's individual pixels.\n  _updateElementIDBuffer(elementCount) {\n    if (!this.hasSourceTextures && !this.targetTextureVarying) {\n      return;\n    }\n    // NOTE: using float so this will work with GLSL 1.0 shaders.\n    const elementIds = new Float32Array(elementCount);\n    elementIds.forEach((_, index, array) => {\n      array[index] = index;\n    });\n    if (!this.elementIDBuffer) {\n      this.elementIDBuffer = this._createNewBuffer('elementIDBuffer', {\n        data: elementIds,\n        accessor: {size: 1}\n      });\n    } else {\n      this.elementIDBuffer.setData({data: elementIds});\n    }\n  }\n\n  // build and return shader releated parameters\n  _getShaders(props = {}) {\n    const {vs, uniforms, targetTextureType, inject, samplerTextureMap} = this._processVertexShader(\n      props.vs\n    );\n    const combinedInject = combineInjects([props.inject || {}, inject]);\n    this.targetTextureType = targetTextureType;\n    const fs =\n      props._fs ||\n      getPassthroughFS({\n        version: getShaderVersion(vs),\n        input: this.targetTextureVarying,\n        inputType: targetTextureType,\n        output: FS_OUTPUT_VARIABLE\n      });\n    const modules =\n      this.hasSourceTextures || this.targetTextureVarying\n        ? [transform].concat(props.modules || [])\n        : props.modules;\n    return {vs, fs, modules, uniforms, inject: combinedInject, samplerTextureMap};\n  }\n\n  // scan and update vertex shader for texture atrributes.\n  _processVertexShader(vs) {\n    return updateForTextures({\n      vs,\n      sourceTextureMap: this.sourceTextures[this.currentIndex],\n      targetTextureVarying: this.targetTextureVarying,\n      targetTexture: this.targetTextures[this.currentIndex]\n    });\n  }\n}\n","/* global window */\nimport {\n  AnimationLoop,\n  Buffer,\n  Model,\n  picking,\n  Transform,\n  isWebGL2,\n  readPixelsToArray\n} from '@luma.gl/core';\nimport {Log} from 'probe.gl';\n\nconst RED = new Uint8Array([255, 0, 0, 255]);\n\n/* eslint-disable max-len */\nconst INFO_HTML = `\n<p>\n  Instanced triangles animated on the GPU using a luma.gl <code>Transform</code> object.\n\n  This is a port of an example from\n  <a href=\"https://github.com/WebGLSamples/WebGL2Samples/blob/master/samples/transform_feedback_instanced.html\">\n    WebGL2Samples\n  </a>\n`;\n/* eslint-enable max-len */\n\n// Text to be displayed on environments when this demos is not supported.\nconst ALT_TEXT = \"THIS DEMO REQUIRES WEBLG2, BUT YOUR BROWSER DOESN'T SUPPORT IT\";\n\nconst EMIT_VS = `\\\n#version 300 es\n#define OFFSET_LOCATION 0\n#define ROTATION_LOCATION 1\n\n#define M_2PI 6.28318530718\n\n// We simulate the wandering of agents using transform feedback in this vertex shader\n// The simulation goes like this:\n// Assume there's a circle in front of the agent whose radius is WANDER_CIRCLE_R\n// the origin of which has a offset to the agent's pivot point, which is WANDER_CIRCLE_OFFSET\n// Each frame we pick a random point on this circle\n// And the agent moves MOVE_DELTA toward this target point\n// We also record the rotation facing this target point, so it will be the base rotation\n// for our next frame, which means the WANDER_CIRCLE_OFFSET vector will be on this direction\n// Thus we fake a smooth wandering behavior\n\n#define MAP_HALF_LENGTH 1.01\n#define WANDER_CIRCLE_R 0.01\n#define WANDER_CIRCLE_OFFSET 0.04\n#define MOVE_DELTA 0.001\nprecision highp float;\nprecision highp int;\nuniform float u_time;\nlayout(location = OFFSET_LOCATION) in vec2 a_offset;\nlayout(location = ROTATION_LOCATION) in float a_rotation;\nout vec2 v_offset;\nout float v_rotation;\n\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvoid main()\n{\n    float theta = M_2PI * rand(vec2(u_time, a_rotation + a_offset.x + a_offset.y));\n    float cos_r = cos(a_rotation);\n    float sin_r = sin(a_rotation);\n    mat2 rot = mat2(\n        cos_r, sin_r,\n        -sin_r, cos_r\n    );\n\n    vec2 p = WANDER_CIRCLE_R * vec2(cos(theta), sin(theta)) + vec2(WANDER_CIRCLE_OFFSET, 0.0);\n    vec2 move = normalize(rot * p);\n    v_rotation = atan(move.y, move.x);\n    v_offset = a_offset + MOVE_DELTA * move;\n\n    // wrapping at edges\n    v_offset = vec2 (\n        v_offset.x > MAP_HALF_LENGTH ? - MAP_HALF_LENGTH :\n          ( v_offset.x < - MAP_HALF_LENGTH ? MAP_HALF_LENGTH : v_offset.x ) ,\n        v_offset.y > MAP_HALF_LENGTH ? - MAP_HALF_LENGTH :\n          ( v_offset.y < - MAP_HALF_LENGTH ? MAP_HALF_LENGTH : v_offset.y )\n        );\n\n    gl_Position = vec4(v_offset, 0.0, 1.0);\n}\n`;\n\nconst DRAW_VS = `\\\n#version 300 es\n#define OFFSET_LOCATION 0\n#define ROTATION_LOCATION 1\n#define POSITION_LOCATION 2\n#define COLOR_LOCATION 3\nprecision highp float;\nprecision highp int;\nlayout(location = POSITION_LOCATION) in vec2 a_position;\nlayout(location = ROTATION_LOCATION) in float a_rotation;\nlayout(location = OFFSET_LOCATION) in vec2 a_offset;\nlayout(location = COLOR_LOCATION) in vec3 a_color;\nin vec2 instancePickingColors;\nout vec3 v_color;\nvoid main()\n{\n    v_color = a_color;\n\n    float cos_r = cos(a_rotation);\n    float sin_r = sin(a_rotation);\n    mat2 rot = mat2(\n        cos_r, sin_r,\n        -sin_r, cos_r\n    );\n    gl_Position = vec4(rot * a_position + a_offset, 0.0, 1.0);\n    picking_setPickingColor(vec3(0., instancePickingColors));\n}\n`;\n\nconst DRAW_FS = `\\\n#version 300 es\n#define ALPHA 0.9\nprecision highp float;\nprecision highp int;\nin vec3 v_color;\nout vec4 color;\nvoid main()\n{\n    color = vec4(v_color * ALPHA, ALPHA);\n    color = picking_filterColor(color);\n}\n`;\n\nconst NUM_INSTANCES = 1000;\nconst log = new Log({id: 'transform'}).enable();\n\n// TODO PIKCING TEMPORARILY DISABLED\nlet pickPosition = [0, 0];\n\nfunction mousemove(e) {\n  pickPosition = [e.offsetX, e.offsetY];\n}\n\nfunction mouseleave(e) {\n  pickPosition = null;\n}\n\nfunction getDevicePixelRatio() {\n  return typeof window !== 'undefined' ? window.devicePixelRatio : 1;\n}\n\nexport default class AppAnimationLoop extends AnimationLoop {\n  static getInfo() {\n    return INFO_HTML;\n  }\n\n  constructor(props = {}) {\n    super(Object.assign(props, {createFramebuffer: true}));\n    // Default value is true, so GL context is always created to verify wheter it is WebGL2 or not.\n    this.isDemoSupported = true;\n  }\n  /* eslint-disable max-statements */\n  onInitialize({canvas, gl}) {\n    this.isDemoSupported = isWebGL2(gl);\n    if (!this.isDemoSupported) {\n      log.error(ALT_TEXT)();\n      return {};\n    }\n    gl.canvas.addEventListener('mousemove', mousemove);\n    gl.canvas.addEventListener('mouseleave', mouseleave);\n\n    // -- Initialize data\n    const trianglePositions = new Float32Array([0.015, 0.0, -0.01, 0.01, -0.01, -0.01]);\n\n    const instanceOffsets = new Float32Array(NUM_INSTANCES * 2);\n    const instanceRotations = new Float32Array(NUM_INSTANCES);\n    const instanceColors = new Float32Array(NUM_INSTANCES * 3);\n    const pickingColors = new Uint8ClampedArray(NUM_INSTANCES * 2);\n\n    for (let i = 0; i < NUM_INSTANCES; ++i) {\n      instanceOffsets[i * 2] = Math.random() * 2.0 - 1.0;\n      instanceOffsets[i * 2 + 1] = Math.random() * 2.0 - 1.0;\n\n      instanceRotations[i] = Math.random() * 2 * Math.PI;\n\n      const randValue = Math.random();\n      if (randValue > 0.5) {\n        instanceColors[i * 3 + 1] = 1.0;\n        instanceColors[i * 3 + 2] = 1.0;\n      } else {\n        instanceColors[i * 3] = 1.0;\n        instanceColors[i * 3 + 2] = 1.0;\n      }\n\n      pickingColors[i * 2] = Math.floor(i / 255);\n      pickingColors[i * 2 + 1] = i - 255 * pickingColors[i * 2];\n    }\n\n    const positionBuffer = new Buffer(gl, trianglePositions);\n    const colorBuffer = new Buffer(gl, instanceColors);\n    const offsetBuffer = new Buffer(gl, instanceOffsets);\n    const rotationBuffer = new Buffer(gl, instanceRotations);\n    const pickingColorBuffer = new Buffer(gl, pickingColors);\n\n    const renderModel = new Model(gl, {\n      id: 'RenderModel',\n      vs: DRAW_VS,\n      fs: DRAW_FS,\n      drawMode: gl.TRIANGLE_FAN,\n      vertexCount: 3,\n      isInstanced: true,\n      instanceCount: NUM_INSTANCES,\n      attributes: {\n        a_position: positionBuffer,\n        a_color: [colorBuffer, {divisor: 1}],\n        a_offset: [offsetBuffer, {divisor: 1}],\n        a_rotation: [rotationBuffer, {divisor: 1}],\n        instancePickingColors: [pickingColorBuffer, {divisor: 1}]\n      },\n      modules: [picking]\n    });\n\n    const transform = new Transform(gl, {\n      vs: EMIT_VS,\n      elementCount: NUM_INSTANCES,\n      sourceBuffers: {\n        a_offset: offsetBuffer,\n        a_rotation: rotationBuffer\n      },\n      feedbackMap: {\n        a_offset: 'v_offset',\n        a_rotation: 'v_rotation'\n      }\n    });\n\n    return {\n      positionBuffer,\n      rotationBuffer,\n      colorBuffer,\n      offsetBuffer,\n      renderModel,\n      transform\n    };\n  }\n  /* eslint-enable max-statements */\n\n  onRender({\n    gl,\n    width,\n    height,\n    renderModel,\n    positionBuffer,\n    colorBuffer,\n    transform,\n    framebuffer,\n    useDevicePixels,\n    time\n  }) {\n    if (!this.isDemoSupported) {\n      return;\n    }\n    transform.run({\n      uniforms: {\n        u_time: time\n      }\n    });\n\n    transform.swap();\n\n    const offsetBuffer = transform.getBuffer('v_offset');\n    const rotationBuffer = transform.getBuffer('v_rotation');\n\n    offsetBuffer.setAccessor({divisor: 1});\n    rotationBuffer.setAccessor({divisor: 1});\n\n    renderModel.clear({color: [0.0, 0.0, 0.0, 1.0], depth: true});\n    renderModel.draw({\n      attributes: {\n        a_offset: offsetBuffer,\n        a_rotation: rotationBuffer\n      },\n      parameters: {\n        blend: true,\n        blendFunc: [gl.SRC_ALPHA, gl.ONE]\n      }\n    });\n\n    offsetBuffer.setAccessor({divisor: 0});\n    rotationBuffer.setAccessor({divisor: 0});\n\n    if (pickPosition) {\n      const dpr = useDevicePixels ? getDevicePixelRatio() : 1;\n\n      const pickX = pickPosition[0] * dpr;\n      const pickY = gl.canvas.height - pickPosition[1] * dpr;\n\n      pickInstance(gl, pickX, pickY, renderModel, framebuffer);\n    }\n  }\n\n  onFinalize({renderModel, transform}) {\n    if (renderModel) {\n      renderModel.delete();\n    }\n    if (transform) {\n      transform.delete();\n    }\n  }\n\n  isSupported() {\n    return this.isDemoSupported;\n  }\n\n  getAltText() {\n    return ALT_TEXT;\n  }\n}\n\nfunction pickInstance(gl, pickX, pickY, model, framebuffer) {\n  framebuffer.clear({color: true, depth: true});\n  // Render picking colors\n  /* eslint-disable camelcase */\n  model.setUniforms({picking_uActive: 1});\n  model.draw({framebuffer});\n  model.setUniforms({picking_uActive: 0});\n\n  const color = readPixelsToArray(framebuffer, {\n    sourceX: pickX,\n    sourceY: pickY,\n    sourceWidth: 1,\n    sourceHeight: 1,\n    sourceFormat: gl.RGBA,\n    sourceType: gl.UNSIGNED_BYTE\n  });\n\n  if (color[0] + color[1] + color[2] > 0) {\n    model.updateModuleSettings({\n      pickingSelectedColor: color,\n      pickingHighlightColor: RED\n    });\n  } else {\n    model.updateModuleSettings({\n      pickingSelectedColor: null\n    });\n  }\n}\n\n/* global window */\nif (typeof window !== 'undefined' && !window.website) {\n  const animationLoop = new AppAnimationLoop();\n  animationLoop.start();\n}\n","import React from 'react';\nimport AnimationLoopExamplePage from '../../src/components/animation-loop-example-page';\nimport AnimationLoop from '../../../examples/core/transform/app';\n\nexport default class Example extends React.Component {\n  render() {\n    return (\n      <AnimationLoopExamplePage AnimationLoop={AnimationLoop} exampleConfig={this.props.pageContext.exampleConfig} />\n    );\n  }\n}\n","'use strict';\n\nrequire(\"core-js/modules/es6.array.filter\");\n\nrequire(\"core-js/modules/es6.array.for-each\");\n\nrequire(\"core-js/modules/es6.set\");\n\nrequire(\"core-js/modules/es6.regexp.to-string\");\n\nrequire(\"core-js/modules/es6.date.to-string\");\n\nrequire(\"core-js/modules/es7.array.includes\");\n\nrequire(\"core-js/modules/es6.string.includes\");\n\nrequire(\"core-js/modules/es6.date.now\");\n\nrequire(\"core-js/modules/web.dom.iterable\");\n\nrequire(\"core-js/modules/es6.array.iterator\");\n\nrequire(\"core-js/modules/es6.object.to-string\");\n\nrequire(\"core-js/modules/es6.string.iterator\");\n\nrequire(\"core-js/modules/es6.map\");\n\nrequire(\"core-js/modules/es7.symbol.async-iterator\");\n\nrequire(\"core-js/modules/es6.symbol\");\n\nrequire(\"core-js/modules/es6.object.define-property\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n}; // Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n\nvar isBrowser = typeof window !== 'undefined' && window.addEventListener;\nvar timers = new Map();\n/**\n * Ready check for Seer initialization\n *\n * @returns {Boolean}\n */\n\nvar isReady = function isReady() {\n  return isBrowser && window.__SEER_INITIALIZED__;\n};\n/**\n * Utility method allowing to throttle a user action based on a key and a minimun delay.\n *\n * @param key {String} A unique key\n * @param delay {Number} The minimal delay to throttle\n * @returns {Boolean}\n */\n\n\nvar throttle = function throttle(key, delay) {\n  var time = timers.get(key);\n  var now = Date.now();\n\n  if (time && now - time < delay) {\n    return true;\n  }\n\n  timers.set(key, now);\n  return false;\n};\n\nvar replacer = function replacer(seen) {\n  return function (key, value) {\n    if (value && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && seen.has(value)) {\n      return;\n    }\n\n    seen.add(value);\n    var isArray = Object.prototype.toString.call(value).slice(8, -1).includes('Array');\n\n    if (isArray) {\n      return Array.prototype.slice.call(value, 0, 20);\n    }\n\n    return value;\n  };\n};\n/**\n * Low-level api leveraging window.postMessage\n *\n * @param type {String} The action type\n * @param payload {Any} The action payload\n */\n\n\nvar send = function send(type) {\n  var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (!isBrowser || !isReady()) {\n    return;\n  }\n\n  var seen = new Set();\n  var payload = JSON.stringify(data, replacer(seen));\n\n  try {\n    window.postMessage({\n      type: type,\n      payload: payload,\n      source: 'seer-agent'\n    }, '*');\n  } catch (e) {\n    if (throttle('seer-log', 2E3)) {\n      return;\n    }\n\n    console.log(e); // eslint-disable-line\n  }\n};\n\nvar listeners = new Map();\n\nvar listener = function listener(message) {\n  if (!message || !message.data || message.data.source !== 'seer-core') {\n    return;\n  }\n\n  var _message$data = message.data,\n      type = _message$data.type,\n      payload = _message$data.payload;\n  var typeListeners = listeners.get(type);\n\n  if (typeListeners) {\n    typeListeners.forEach(function (cb) {\n      return cb(payload);\n    });\n  }\n};\n/**\n * Initilize window listener. There will be only one for the whole process\n * to prevent too many registrations.\n *\n * This method will be called automatically if you use the `listenFor` method.\n */\n\n\nvar init = function init() {\n  if (!isBrowser || window.__SEER_LISTENER__) {\n    return;\n  }\n\n  window.addEventListener('message', listener);\n  window.__SEER_LISTENER__ = true;\n};\n/**\n * Clean listener. Can be useful in case you want to unregister upcoming events\n * or liberate memory.\n */\n\n\nvar clean = function clean() {\n  if (!isBrowser || !window.__SEER_LISTENER__) {\n    return;\n  }\n\n  window.removeEventListener('message', listener);\n  delete window.__SEER_LISTENER__;\n};\n/**\n * Create a listener that will be called upon events of the given key.\n *\n * @param key {String} The unique tab key\n * @param cb {Function} A callback that will receive the message payload\n */\n\n\nvar listenFor = function listenFor(type, cb) {\n  if (!isBrowser) {\n    return;\n  }\n\n  if (!type || !cb) {\n    throw new Error('Please provide a type and callback');\n  }\n\n  if (!listeners.has(type)) {\n    listeners.set(type, []);\n  }\n\n  if (!window.__SEER_LISTENER__) {\n    init();\n  }\n\n  listeners.get(type).push(cb);\n};\n/**\n * Remove an identity listener\n *\n * @param cb {Function} The callback to remove\n */\n\n\nvar removeListener = function removeListener(cb) {\n  listeners.forEach(function (typeListeners, key) {\n    listeners.set(key, typeListeners.filter(function (l) {\n      return l !== cb;\n    }));\n  });\n};\n/**\n * Creates a new indexed list.\n * It works by index to get O(1) accessing and performance.\n *\n * @param key {String} The key of the tab\n * @param data {Object} The indexed object\n */\n\n\nvar list = function list(key, data) {\n  return send('LIST', {\n    key: key,\n    data: data\n  });\n};\n/**\n * Creates an element in the indexed list, based on the itemKey.\n *\n * @param key {String} The key of the tab\n * @param itemKey {String} The key of the item\n * @param data {Any} The value of the item\n */\n\n\nvar listItem = function listItem(key, itemKey) {\n  var data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  return send('LIST_ITEM', {\n    key: key,\n    itemKey: itemKey,\n    data: data\n  });\n};\n/**\n * Update an item property, can be deeply nested.\n *\n * @param key {String} The key of the tab\n * @param itemKey {String} The key of the item\n * @param path {String} The path of the variable you want to update\n * @param data {Object} The new value\n */\n\n\nvar updateItem = function updateItem(key, itemKey, path, data) {\n  return send('UPDATE_ITEM', {\n    key: key,\n    itemKey: itemKey,\n    path: path,\n    data: data\n  });\n};\n/**\n * Similar to updateItem, but allows to pass an array with {path,data} pairs for\n * multiple update of the same item without having to send multiple messages.\n *\n * @param key {String} The key of the tab\n * @param itemKey {String} The key of the item\n * @param array {Array} The array of updates\n * @param array.path {String} The path for this update\n * @param array.data {Object} The value of this update\n */\n\n\nvar multiUpdate = function multiUpdate(key, itemKey, array) {\n  return send('MULTI_UPDATE_ITEM', {\n    key: key,\n    itemKey: itemKey,\n    array: array\n  });\n};\n/**\n * Remove a specific item in a specific tab.\n *\n * @param key {String} They key of the tab\n * @param itemKey {String} The key of the item\n */\n\n\nvar deleteItem = function deleteItem(key, itemKey) {\n  return send('DELETE_ITEM', {\n    key: key,\n    itemKey: itemKey\n  });\n};\n/**\n * Will create a log message to an item, that will be displayde with the current time.\n *\n * @param key {String} The key of the tab\n * @param itemKey {String} The key of the item\n * @param msg {String} The message to display\n */\n\n\nvar addLog = function addLog(key, itemKey, msg) {\n  return send('ADD_LOG', {\n    key: key,\n    itemKey: itemKey,\n    msg: msg\n  });\n};\n\nexports[\"default\"] = {\n  send: send,\n  throttle: throttle,\n  isReady: isReady,\n  list: list,\n  listItem: listItem,\n  updateItem: updateItem,\n  multiUpdate: multiUpdate,\n  deleteItem: deleteItem,\n  addLog: addLog,\n  listeners: listeners,\n  listenFor: listenFor,\n  removeListener: removeListener,\n  init: init,\n  clean: clean\n};","import {assert} from '../utils';\nconst FS100 = 'void main() {gl_FragColor = vec4(0);}';\nconst FS300 = `\\\n#version 300 es\nout vec4 transform_output;\nvoid main() {\n  transform_output = vec4(0);\n}`;\n\n// Prase given glsl line and return qualifier details or null\nexport function getQualifierDetails(line, qualifiers) {\n  qualifiers = Array.isArray(qualifiers) ? qualifiers : [qualifiers];\n  const words = line.replace(/^\\s+/, '').split(/\\s+/);\n  // TODO add support for precession qualifiers (highp, mediump and lowp)\n  const [qualifier, type, definition] = words;\n  if (!qualifiers.includes(qualifier) || !type || !definition) {\n    return null;\n  }\n  const name = definition.split(';')[0];\n  return {qualifier, type, name};\n}\n\n// Given the shader version, input and output variable names,\n// builds and return a pass through fragment shader.\nexport function getPassthroughFS({version = 100, input, inputType, output} = {}) {\n  if (!input) {\n    return version === 300 ? FS300 : FS100;\n  }\n  const outputValue = convertToVec4(input, inputType);\n  if (version === 300) {\n    return `\\\n#version 300 es\nin ${inputType} ${input};\nout vec4 ${output};\nvoid main() {\n  ${output} = ${outputValue};\n}`;\n  }\n  // version 100\n  return `\\\nvarying ${inputType} ${input};\nvoid main() {\n  gl_FragColor = ${outputValue};\n}`;\n}\n\n// convert glsl type to suffix\nexport function typeToChannelSuffix(type) {\n  switch (type) {\n    case 'float':\n      return 'x';\n    case 'vec2':\n      return 'xy';\n    case 'vec3':\n      return 'xyz';\n    case 'vec4':\n      return 'xyzw';\n    default:\n      assert(false);\n      return null;\n  }\n}\n\n// convert glsl type to channel count\nexport function typeToChannelCount(type) {\n  switch (type) {\n    case 'float':\n      return 1;\n    case 'vec2':\n      return 2;\n    case 'vec3':\n      return 3;\n    case 'vec4':\n      return 4;\n    default:\n      assert(false);\n      return null;\n  }\n}\n\n// Returns glsl instruction for converting to vec4\nexport function convertToVec4(variable, type) {\n  switch (type) {\n    case 'float':\n      return `vec4(${variable}, 0.0, 0.0, 1.0)`;\n    case 'vec2':\n      return `vec4(${variable}, 0.0, 1.0)`;\n    case 'vec3':\n      return `vec4(${variable}, 1.0)`;\n    case 'vec4':\n      return variable;\n    default:\n      assert(false);\n      return null;\n  }\n}\n","// https://github.com/tc39/proposal-object-values-entries\nvar $export = require('./_export');\nvar $values = require('./_object-to-array')(false);\n\n$export($export.S, 'Object', {\n  values: function values(it) {\n    return $values(it);\n  }\n});\n","const DEFAULT_HIGHLIGHT_COLOR = new Uint8Array([0, 255, 255, 255]);\n\nconst DEFAULT_MODULE_OPTIONS = {\n  pickingSelectedColor: null, //  Set to a picking color to visually highlight that item\n  pickingHighlightColor: DEFAULT_HIGHLIGHT_COLOR, // Color of visual highlight of \"selected\" item\n  pickingThreshold: 1.0,\n  pickingActive: false // Set to true when rendering to off-screen \"picking\" buffer\n};\n\n/* eslint-disable camelcase */\nfunction getUniforms(opts = DEFAULT_MODULE_OPTIONS) {\n  const uniforms = {};\n  if (opts.pickingSelectedColor !== undefined) {\n    if (opts.pickingSelectedColor === null) {\n      uniforms.picking_uSelectedColorValid = 0;\n    } else {\n      const selectedColor = [\n        opts.pickingSelectedColor[0],\n        opts.pickingSelectedColor[1],\n        opts.pickingSelectedColor[2]\n      ];\n      uniforms.picking_uSelectedColorValid = 1;\n      uniforms.picking_uSelectedColor = selectedColor;\n    }\n  }\n  if (opts.pickingHighlightColor !== undefined) {\n    uniforms.picking_uHighlightColor = opts.pickingHighlightColor;\n  }\n  // TODO - major hack - decide on normalization and remove\n  if (opts.pickingThreshold !== undefined) {\n    uniforms.picking_uThreshold = opts.pickingThreshold;\n  }\n  if (opts.pickingActive !== undefined) {\n    uniforms.picking_uActive = opts.pickingActive ? 1 : 0;\n  }\n  return uniforms;\n}\n\nconst vs = `\\\nuniform vec3 picking_uSelectedColor;\nuniform float picking_uThreshold;\nuniform bool picking_uSelectedColorValid;\n\nout vec4 picking_vRGBcolor_Aselected;\n\nconst float COLOR_SCALE = 1. / 255.;\n\nbool isVertexPicked(vec3 vertexColor) {\n  return\n    picking_uSelectedColorValid &&\n    abs(vertexColor.r - picking_uSelectedColor.r) < picking_uThreshold &&\n    abs(vertexColor.g - picking_uSelectedColor.g) < picking_uThreshold &&\n    abs(vertexColor.b - picking_uSelectedColor.b) < picking_uThreshold;\n}\n\nvoid picking_setPickingColor(vec3 pickingColor) {\n  // Do the comparison with selected item color in vertex shader as it should mean fewer compares\n  picking_vRGBcolor_Aselected.a =\n    float(isVertexPicked(pickingColor));\n\n  // Stores the picking color so that the fragment shader can render it during picking\n  picking_vRGBcolor_Aselected.rgb = pickingColor * COLOR_SCALE;\n}\n`;\n\nconst fs = `\\\nuniform bool picking_uActive; // true during rendering to offscreen picking buffer\nuniform vec3 picking_uSelectedColor;\nuniform vec4 picking_uHighlightColor;\n\nin vec4 picking_vRGBcolor_Aselected;\n\nconst float COLOR_SCALE = 1. / 255.;\n\n/*\n * Returns highlight color if this item is selected.\n */\nvec4 picking_filterHighlightColor(vec4 color) {\n  bool selected = bool(picking_vRGBcolor_Aselected.a);\n\n  if (selected) {\n    vec4 highLightColor = picking_uHighlightColor * COLOR_SCALE;\n\n    float highLightAlpha = highLightColor.a;\n    float blendedAlpha = highLightAlpha + color.a * (1.0 - highLightAlpha);\n    float highLightRatio = highLightAlpha / blendedAlpha;\n\n    vec3 blendedRGB = mix(color.rgb, highLightColor.rgb, highLightRatio);\n    return vec4(blendedRGB, blendedAlpha);\n  } else {\n    return color;\n  }\n}\n\n/*\n * Returns picking color if picking enabled else unmodified argument.\n */\nvec4 picking_filterPickingColor(vec4 color) {\n  vec3 pickingColor = picking_vRGBcolor_Aselected.rgb;\n  if (picking_uActive && length(pickingColor) < 0.001) {\n    discard;\n  }\n  return picking_uActive ? vec4(pickingColor, 1.0) : color;\n}\n\n/*\n * Returns picking color if picking is enabled if not\n * highlight color if this item is selected, otherwise unmodified argument.\n */\nvec4 picking_filterColor(vec4 color) {\n  vec4 highightColor = picking_filterHighlightColor(color);\n  return picking_filterPickingColor(highightColor);\n}\n\n`;\n\nexport default {\n  name: 'picking',\n  vs,\n  fs,\n  getUniforms\n};\n","var DESCRIPTORS = require('./_descriptors');\nvar getKeys = require('./_object-keys');\nvar toIObject = require('./_to-iobject');\nvar isEnum = require('./_object-pie').f;\nmodule.exports = function (isEntries) {\n  return function (it) {\n    var O = toIObject(it);\n    var keys = getKeys(O);\n    var length = keys.length;\n    var i = 0;\n    var result = [];\n    var key;\n    while (length > i) {\n      key = keys[i++];\n      if (!DESCRIPTORS || isEnum.call(O, key)) {\n        result.push(isEntries ? [key, O[key]] : O[key]);\n      }\n    }\n    return result;\n  };\n};\n"],"sourceRoot":""}