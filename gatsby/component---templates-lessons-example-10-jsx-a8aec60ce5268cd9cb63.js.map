{"version":3,"sources":["webpack:///../examples/lessons/10/world.js","webpack:///../examples/lessons/10/app.js","webpack:///./templates/lessons/example-10.jsx","webpack:///../modules/core/src/geometry/geometry.js","webpack:///../modules/shadertools/src/lib/shader-module-registry.js","webpack:///../modules/shadertools/src/lib/resolve-modules.js","webpack:///../modules/shadertools/src/utils/webgl-info.js","webpack:///../modules/shadertools/src/utils/is-old-ie.js","webpack:///../modules/shadertools/src/lib/platform-defines.js","webpack:///../modules/shadertools/src/lib/assemble-shaders.js","webpack:///../modules/core/src/lib/model-utils.js","webpack:///../modules/webgl/src/utils/format-value.js","webpack:///../modules/webgl/src/debug/debug-vertex-array.js","webpack:///../modules/webgl/src/debug/debug-uniforms.js","webpack:///../modules/webgl/src/debug/debug-program-configuration.js","webpack:///../modules/core/src/debug/seer-integration.js","webpack:///../modules/core/src/lib/base-model.js","webpack:///../modules/core/src/lib/model.js","webpack:///../modules/shadertools/src/lib/transpile-shader.js","webpack:///../modules/shadertools/src/lib/filters/prop-types.js","webpack:///../modules/shadertools/src/lib/shader-module.js","webpack:///../modules/shadertools/src/lib/inject-shader.js","webpack:///../modules/shadertools/src/modules/module-injectors.js","webpack:///../modules/shadertools/src/lib/constants.js","webpack:///../modules/shadertools/src/index.js","webpack:///../modules/shadertools/src/shaders/modular-vertex.glsl.js","webpack:///../modules/shadertools/src/shaders/modular-fragment.glsl.js","webpack:///../modules/core/src/scenegraph/nodes/scenegraph-node.js","webpack:///../modules/core/src/scenegraph/nodes/model-node.js","webpack:///../modules/shadertools/src/utils/assert.js","webpack:///../modules/webgl/src/classes/transform-feedback.js"],"names":["VERTEX_SHADER","FRAGMENT_SHADER","World","_ModelNode","opts","program","classes_program","gl","fs","vs","call","this","geometry","uniforms","uSampler","texture","model_node","cameraInfo","pitch","pitchRate","yaw","yawRate","xPos","yPos","zPos","speed","joggingAngle","direction","timeLine","lastTime","currentlyPressedKeys","AppAnimationLoop","getInfo","onInitialize","_parameters","canvas","_ref","eventManager","esm","addKeyboardHandler","keydown","e","keyup","mouseDown","currentX","currentY","panstart","panend","panmove","dx","dy","addMouseHandler","setParameters","clearColor","clearDepth","depthTest","texture_2d","data","parameters","TEXTURE_WRAP_S","MIRRORED_REPEAT","TEXTURE_WRAP_T","Object","load_file","then","file","lines","vertexPositions","vertexTextureCoords","i","vals","parseFloat","geometry_geometry","vertexCount","attributes","positions","Float32Array","texCoords","loadWorldGeometry","world","world_World","onRender","_ref2","aspect","tick","eyePos","centerPos","matrix4","rotateX","radians","rotateY","transformVector3","add","uMVMatrix","lookAt","eye","center","up","Equal","Minus","KeyA","KeyD","KeyW","KeyS","handleKeys","timeNow","Date","getTime","elapsed","Math","animate","GL","setUniforms","uPMatrix","perspective","fov","PI","near","far","draw","onFinalize","destroy","AnimationLoop","window","website","app_AppAnimationLoop","animationLoop","Example","render","react_default","a","createElement","animation_loop_example_page","exampleConfig","props","pageContext","React","Component","DRAW_MODE","POINTS","LINES","LINE_LOOP","LINE_STRIP","TRIANGLES","TRIANGLE_STRIP","TRIANGLE_FAN","Geometry","_props","_props$id","id","uid","_props$drawMode","drawMode","_props$attributes","_props$indices","indices","_props$vertexCount","userData","_setAttributes","_calculateVertexCount","getVertexCount","getAttributes","assign","_print","attributeName","ArrayBuffer","isView","value","size","attribute","assert","undefined","isIndexed","length","Infinity","constant","Number","ShaderModuleRegistry","shaderModules","defaultShaderModules","setDefaultShaderModules","resolveModules","modules","getDefaultShaderModules","registerShaderModules","_ref$ignoreMultipleRe","_temp","ignoreMultipleRegistrations","_iterator","shaderModuleList","_isArray","Array","isArray","_i","Symbol","iterator","next","done","shaderModule","_registerShaderModule","getShaderModule","moduleOrName","shader_module","module","_this","map","name","Error","shaderModuleRegistry","shader_module_registry_ShaderModuleRegistry","getShaderDependencies","resolve_modules_getShaderModule","moduleMap","moduleDepth","getDependencyGraph","level","keys","sort","b","_ref3","_iterator2","_isArray2","_i2","_ref4","dependencies","GL_VENDOR","GL_RENDERER","GL_VERSION","GL_SHADING_LANGUAGE_VERSION","WEBGL_FEATURES","GLSL_FRAG_DATA","GLSL_FRAG_DEPTH","GLSL_DERIVATIVES","GLSL_TEXTURE_LOD","FEATURES","key","compiledGlslExtensions","canCompileGLGSExtension","cap","feature","navigator","userAgent","isMSIE","isTrident","isOldIE","source","shader","canCompile","COMPILE_STATUS","getFeature","extensionName","Boolean","isWebGL2","hasFeatures","features","every","getPlatformShaderDefines","info","vendor","UNMASKED_VENDOR_WEBGL","renderer","UNMASKED_RENDERER_WEBGL","gpuVendor","identifyGPUVendor","version","shadingLanguageVersion","getContextInfo","debugInfo","toLowerCase","INJECT_SHADER_DECLARATIONS","inject_shader","SHADER_TYPE","_SHADER_TYPE","constants","HOOK_FUNCTIONS","_HOOK_FUNCTIONS","MODULE_INJECTIONS","FRAGMENT_SHADER_PROLOGUE","createShaderHook","hook","_hook$split","stage","signature","createModuleInjection","moduleName","injection","_opts$order","order","shaderStage","assembleShaders","assembleShader","type","getUniforms","assembleGetUniforms","assembleModuleMap","_ref$defines","defines","_ref$inject","inject","_ref$prologue","prologue","log","isVertex","sourceLines","glslVersion","versionLine","coreSource","allDefines","assembledSource","_ref6","getShaderName","_ref5","toUpperCase","getShaderType","isFragment","versionDefines","behavior","getVersionDefines","count","sourceText","define","getApplicationDefines","injectStandardStubs","hookInjections","mainInjections","injections","_key","result","hookFunctions","hookName","hookFunction","header","_iterator4","_isArray4","_i4","_ref7","footer","getHookFunctions","injectShader","moduleUniforms","_iterator3","_isArray3","_i3","GLTF_TO_LUMA_ATTRIBUTE_MAP","POSITION","NORMAL","COLOR_0","TEXCOORD_0","TEXCOORD_1","TEXCOORD_2","mapAttributeName","options","_ref$attributeMap","attributeMap","inferAttributeAccessor","category","formatValue","v","_opts$isInteger","isInteger","_opts$maxElts","maxElts","_opts$size","string","formatArrayValue","String","decimal","getDebugTableRow","vertexArray","accessor","marker","verts","bytes","classes_buffer","format","buffer","_buffer$getDebugData","getDebugData","modified","getKey","getGLSLDeclaration","typeAndName","getCompositeGLType","getDebugTableForUniforms","_ref$header","_ref$undefinedOnly","undefinedOnly","uniformLocations","_uniformSetters","table","uniformNames","uniformName","addUniformToTable","_uniformName","_uniformName2","unusedCount","unusedTable","_unusedTable$uniformN","uniform","Type","_table$uniformName","isDefined","isUniformDefined","debug_program_configuration_getGLSLDeclaration","attributeInfo","_attributeInfo$access","models","recursiveSet","obj","path","overrides","Map","seer","payload","model","itemKey","valuePath","__SEER_INITIALIZED__","setOverride","BaseModel","isWebGL","lastLogTime","initialize","_setBaseModelProps","_createProgram","vertex_array","needsRedraw","_attributes","animatedUniforms","animated","timerQueryEnabled","timeElapsedQuery","lastQueryReturned","stats","accumulatedFrameTime","averageFrameTime","profileFrameCount","pickable","getModuleUniforms","moduleSettings","setProps","delete","removeModel","isAnimated","getProgram","overs","getOverrides","_extractAnimatedUniforms","updateModuleSettings","drawGeometry","_opts","_opts$moduleSettings","framebuffer","_opts$uniforms","_opts$attributes","_opts$transformFeedba","transformFeedback","_opts$parameters","_opts$vertexArray","animationProps","setAttributes","_refreshAnimationProps","logPriority","_logDrawCallStart","drawParams","getDrawParams","isInstanced","indexType","indexOffset","instanceCount","noop","_this$props","_this$props$onBeforeR","onBeforeRender","_this$props$onAfterRe","onAfterRender","_timerQueryStart","didDraw","getDrawMode","offset","_timerQueryEnd","_logDrawCallEnd","Query","_setAnimationProps","_animationProps","_animationLoop","_ref$vs","_ref$fs","_ref$modules","_ref$shaderCache","shaderCache","_ref$varyings","varyings","_ref$bufferMode","bufferMode","SEPARATE_ATTRIBS","_ref$program","x","MODULAR_SHADERS","assembleResult","_evaluateAnimateUniforms","valueFunction","foundAnimated","newValue","isObjectEmpty","staticUniforms","query","beginTimeElapsedQuery","end","isResultAvailable","elapsedTime","getTimerMilliseconds","lastFrameTime","logDrawTimeout","priority","now","collapsed","attributeTable","configuration","elements","values","attributeLocation","rowHeader","location","getDebugTableForVertexArray","_getDebugTableForUnif","uniformTable","_getDebugTableForUnif2","missingTable","configTable","config","attributeInfos","_table","JSON","varyingInfos","_table2","varyingInfo","getDebugTableForProgramConfiguration","isReady","attributesObject","uniformsObject","logModel","message","Model","_BaseModel","prototype","geometryBuffers","instanced","_setModelProps","_deleteGeometryBuffers","getInstanceCount","setDrawMode","setVertexCount","setInstanceCount","setGeometry","buffers","remappedName","typedArray","Uint32Array","target","ELEMENT_ARRAY_BUFFER","getBuffersFromGeometry","normalizedAttributes","transform","_Object$assign","_opts$discard","discard","feedbackBuffers","_opts$unbindModels","unbindModels","_setFeedbackBuffers","unbindBuffers","bindBuffers","_feedbackBuffers","transform_feedback","setBuffers","transpileShader","targetGLSLVersion","convertVertexShaderTo300","convertFragmentShaderTo300","convertVertexShaderTo100","convertFragmentShaderTo100","TYPE_DEFINITIONS","number","validate","propType","min","array","parsePropType","propDef","getTypeOf","ShaderModule","_ref$dependencies","_ref$deprecations","deprecations","vertexShader","fragmentShader","_parseDeprecationDefinitions","propDefs","propTypes","propName","parsePropTypes","getModuleSource","moduleSource","_defaultGetUniforms","getDefines","checkDeprecations","forEach","def","shaderSource","deprecated","RegExp","old","private","MODULE_INJECTORS","_MODULE_INJECTORS","DECLARATION_INJECT_MARKER","REGEX_START_OF_MAIN","REGEX_END_OF_MAIN","fragments","_loop","fragmentData","len","fragmentString","replace","match","combineInjects","injects","__webpack_require__","d","__webpack_exports__","ScenegraphNode","constructor","display","position","vector3","rotation","scale","matrix","_setScenegraphNodeProps","toString","setPosition","setRotation","setScale","setMatrix","copyMatrix","copy","setMatrixComponents","_ref$update","update","updateMatrix","pos","rot","identity","translate","rotateXYZ","getCoordinateUniforms","modelMatrix","worldMatrix","viewMatrix","multiplyRight","worldInverse","invert","worldInverseTranspose","transpose","objectMatrix","worldInverseMatrix","worldInverseTransposeMatrix","ModelNode","_ScenegraphNode","AfterRender","_setModelNodeProps","managedResources","resource","_this$model","apply","arguments","_this$model2","_this$model3","_this$model4","condition","TransformFeedback","assertWebGL2Context","_Resource","stubRemovedMethods","isSupported","_this2","unused","bindOnUse","bind","_unbindBuffers","_this3","bufferName","setBuffer","_this4","_getVaryingIndex","locationOrName","_this$_getBufferParam","_getBufferParams","bufferOrParams","byteSize","byteOffset","_bindBuffer","begin","primitiveMode","bindTransformFeedback","TRANSFORM_FEEDBACK","handle","_bindBuffers","beginTransformFeedback","endTransformFeedback","_getVaryingInfo","getVaryingInfo","bufferIndex","_this$_getBufferParam2","bindBufferRange","TRANSFORM_FEEDBACK_BUFFER","index","bindBufferBase","_createHandle","createTransformFeedback","_deleteHandle","deleteTransformFeedback","_bindHandle","Resource"],"mappings":"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","file":"component---templates-lessons-example-10-jsx-a8aec60ce5268cd9cb63.js","sourcesContent":["import {Program, Geometry, ModelNode} from '@luma.gl/core';\n\nconst VERTEX_SHADER = `\\\nattribute vec3 positions;\nattribute vec2 texCoords;\n\nuniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void) {\n  gl_Position = uPMatrix * uMVMatrix * vec4(positions, 1.0);\n  vTextureCoord = texCoords;\n}\n`;\n\nconst FRAGMENT_SHADER = `\\\nprecision highp float;\n\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\n\nvoid main(void) {\n  gl_FragColor = vec4(texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t)).rgb, 1.0);\n}\n`;\n\nfunction loadWorldGeometry(data) {\n  const lines = data.split('\\n');\n  const vertexPositions = [];\n  const vertexTextureCoords = [];\n  for (const i in lines) {\n    const vals = lines[i].replace(/^\\s+/, '').split(/\\s+/);\n    if (vals.length === 5 && vals[0] !== '//') {\n      // It is a line describing a vertex; get X, Y and Z first\n      vertexPositions.push(parseFloat(vals[0]));\n      vertexPositions.push(parseFloat(vals[1]));\n      vertexPositions.push(parseFloat(vals[2]));\n      // And then the texture coords\n      vertexTextureCoords.push(parseFloat(vals[3]));\n      vertexTextureCoords.push(parseFloat(vals[4]));\n    }\n  }\n  return new Geometry({\n    vertexCount: vertexPositions.length / 3,\n    attributes: {\n      positions: new Float32Array(vertexPositions),\n      texCoords: new Float32Array(vertexTextureCoords)\n    }\n  });\n}\n\nexport class World extends ModelNode {\n  constructor(opts = {}) {\n    const program = new Program(opts.gl, {\n      fs: FRAGMENT_SHADER,\n      vs: VERTEX_SHADER\n    });\n\n    super(opts.gl, {\n      program,\n      geometry: opts.geometry,\n      uniforms: {\n        uSampler: opts.texture\n      }\n    });\n  }\n}\n\nexport {loadWorldGeometry};\n","import GL from '@luma.gl/constants';\nimport {AnimationLoop, Texture2D, loadFile, setParameters} from '@luma.gl/core';\nimport {Matrix4, radians} from 'math.gl';\nimport {loadWorldGeometry, World} from './world';\nimport {EventManager} from 'mjolnir.js';\n/* eslint-disable complexity */\n\n/*\n  Cave texture from: http://texturelib.com/texture/?path=/Textures/rock/cave/rock_cave_0019\n  \"Free for personal and commercial use.\" http://texturelib.com/about/\n*/\n\nconst INFO_HTML = `\n<p>\n  <a href=\"http://learningwebgl.com/blog/?p=1067\" target=\"_blank\">\n    Loading a world, and the most basic kind of camera\n  </a>\n\n  </br>\n  </br>\n  Use the cursor keys or WASD to run around, and <code>+</code>/<code>-</code> to look up and down.\n<p>\nThe classic WebGL Lessons in luma.gl\n`;\n\nconst cameraInfo = {\n  pitch: 0,\n  pitchRate: 0,\n  yaw: 0,\n  yawRate: 0,\n  xPos: 0,\n  yPos: 0.4,\n  zPos: 0,\n  speed: 0,\n  joggingAngle: 0, // Used to make us \"jog\" up and down as we move forward.\n  direction: [0, 0, -1]\n};\n\nconst timeLine = {\n  lastTime: 0\n};\n\nconst currentlyPressedKeys = {};\n\nexport default class AppAnimationLoop extends AnimationLoop {\n  static getInfo() {\n    return INFO_HTML;\n  }\n\n  onInitialize({canvas, gl}) {\n    // Use mjolnir.js (hammer.js)'s EventManager to handle gestures on both\n    // desktop and mobile\n    this.eventManager = new EventManager(canvas);\n    addKeyboardHandler(this.eventManager);\n    addMouseHandler(this.eventManager);\n\n    setParameters(gl, {\n      clearColor: [0, 0, 0, 1],\n      clearDepth: 1,\n      depthTest: true\n    });\n\n    const texture = new Texture2D(gl, {\n      data: 'cave.jpg',\n      parameters: {\n        [gl.TEXTURE_WRAP_S]: gl.MIRRORED_REPEAT,\n        [gl.TEXTURE_WRAP_T]: gl.MIRRORED_REPEAT\n      }\n    });\n\n    return loadFile('world.txt').then(file => {\n      const geometry = loadWorldGeometry(file);\n      const world = new World({\n        gl,\n        geometry,\n        texture\n      });\n      return {world};\n    });\n  }\n\n  onRender({gl, tick, aspect, world}) {\n    // Update Camera Position\n    const eyePos = [cameraInfo.xPos, cameraInfo.yPos, cameraInfo.zPos];\n    const centerPos = new Matrix4()\n      .rotateX(radians(cameraInfo.pitch))\n      .rotateY(radians(cameraInfo.yaw))\n      .transformVector3(cameraInfo.direction)\n      .add(eyePos);\n\n    const uMVMatrix = new Matrix4().lookAt({eye: eyePos, center: centerPos, up: [0, 1, 0]});\n\n    handleKeys(cameraInfo, currentlyPressedKeys);\n    animate(cameraInfo, timeLine);\n\n    gl.clear(GL.COLOR_BUFFER_BIT | GL.DEPTH_BUFFER_BIT);\n\n    return world\n      .setUniforms({\n        uMVMatrix,\n        uPMatrix: new Matrix4().perspective({\n          fov: (45 * Math.PI) / 180,\n          aspect,\n          near: 0.1,\n          far: 100\n        })\n      })\n      .draw();\n  }\n\n  onFinalize() {\n    this.eventManager.destroy();\n  }\n}\n\nfunction addKeyboardHandler(eventManager) {\n  eventManager.on({\n    keydown(e) {\n      currentlyPressedKeys[e.srcEvent.code] = true;\n    },\n    keyup(e) {\n      currentlyPressedKeys[e.srcEvent.code] = false;\n    }\n  });\n}\n\nfunction addMouseHandler(eventManager) {\n  let mouseDown = false;\n  let currentX = 0;\n  let currentY = 0;\n\n  eventManager.on({\n    panstart(e) {\n      mouseDown = true;\n      currentX = e.offsetCenter.x;\n      currentY = e.offsetCenter.y;\n    },\n    panend() {\n      mouseDown = false;\n    },\n    panmove(e) {\n      if (!mouseDown) {\n        return;\n      }\n      const dx = e.offsetCenter.x - currentX;\n      const dy = e.offsetCenter.y - currentY;\n      cameraInfo.yaw += dx * 0.1;\n      cameraInfo.pitch += dy * 0.1;\n      currentX = e.offsetCenter.x;\n      currentY = e.offsetCenter.y;\n    }\n  });\n}\n\nfunction handleKeys() {\n  if (currentlyPressedKeys.PageUp || currentlyPressedKeys.Equal) {\n    cameraInfo.pitchRate = 0.1;\n  } else if (currentlyPressedKeys.PageDown || currentlyPressedKeys.Minus) {\n    cameraInfo.pitchRate = -0.1;\n  } else {\n    cameraInfo.pitchRate = 0;\n  }\n  if (currentlyPressedKeys.ArrowLeft || currentlyPressedKeys.KeyA) {\n    cameraInfo.yawRate = 0.1;\n  } else if (currentlyPressedKeys.ArrowRight || currentlyPressedKeys.KeyD) {\n    cameraInfo.yawRate = -0.1;\n  } else {\n    cameraInfo.yawRate = 0;\n  }\n  if (currentlyPressedKeys.ArrowUp || currentlyPressedKeys.KeyW) {\n    cameraInfo.speed = 0.003;\n  } else if (currentlyPressedKeys.ArrowDown || currentlyPressedKeys.KeyS) {\n    cameraInfo.speed = -0.003;\n  } else {\n    cameraInfo.speed = 0;\n  }\n}\n\nfunction animate() {\n  const timeNow = new Date().getTime();\n  if (timeLine.lastTime !== 0) {\n    const elapsed = timeNow - timeLine.lastTime;\n    if (cameraInfo.speed !== 0) {\n      cameraInfo.xPos -= Math.sin(radians(cameraInfo.yaw)) * cameraInfo.speed * elapsed;\n      cameraInfo.zPos -= Math.cos(radians(cameraInfo.yaw)) * cameraInfo.speed * elapsed;\n      cameraInfo.joggingAngle += elapsed * 0.6; // 0.6 \"fiddle factor\" - feel more realistic :-)\n      cameraInfo.yPos = Math.sin(radians(cameraInfo.joggingAngle)) / 20 + 0.4;\n    }\n    cameraInfo.yaw += cameraInfo.yawRate * elapsed;\n    cameraInfo.pitch += cameraInfo.pitchRate * elapsed;\n  }\n  timeLine.lastTime = timeNow;\n}\n\n/* global window */\nif (typeof window !== 'undefined' && !window.website) {\n  const animationLoop = new AppAnimationLoop();\n  animationLoop.start();\n}\n","import React from 'react';\nimport AnimationLoopExamplePage from '../../src/components/animation-loop-example-page';\nimport AnimationLoop from '../../../examples/lessons/10/app';\n\nexport default class Example extends React.Component {\n  render() {\n    return (\n      <AnimationLoopExamplePage AnimationLoop={AnimationLoop} exampleConfig={this.props.pageContext.exampleConfig} />\n    );\n  }\n}\n","import {uid, assert} from '../utils';\n\n// Rendering primitives - specify how to extract primitives from vertices.\n// NOTE: These are numerically identical to the corresponding WebGL/OpenGL constants\nexport const DRAW_MODE = {\n  POINTS: 0x0000, // draw single points.\n  LINES: 0x0001, // draw lines. Each vertex connects to the one after it.\n  LINE_LOOP: 0x0002, // draw lines. Each set of two vertices is treated as a separate line segment.\n  LINE_STRIP: 0x0003, // draw a connected group of line segments from the first vertex to the last\n  TRIANGLES: 0x0004, // draw triangles. Each set of three vertices creates a separate triangle.\n  TRIANGLE_STRIP: 0x0005, // draw a connected group of triangles.\n  TRIANGLE_FAN: 0x0006 // draw a connected group of triangles.\n  // Each vertex connects to the previous and the first vertex in the fan.\n};\n\nexport default class Geometry {\n  static get DRAW_MODE() {\n    return DRAW_MODE;\n  }\n\n  constructor(props = {}) {\n    const {\n      id = uid('geometry'),\n      drawMode = DRAW_MODE.TRIANGLES,\n      attributes = {},\n      indices = null,\n      vertexCount = null\n    } = props;\n\n    this.id = id;\n    this.drawMode = drawMode | 0;\n    this.attributes = {};\n    this.userData = {};\n\n    this._setAttributes(attributes, indices);\n\n    this.vertexCount = vertexCount || this._calculateVertexCount(this.attributes, this.indices);\n\n    // stubRemovedMethods(this, [\n    //   'setNeedsRedraw', 'needsRedraw', 'setAttributes'\n    // ], 'Immutable');\n\n    // stubRemovedMethods(this, [\n    //   'hasAttribute', 'getAttribute', 'getArray'\n    // ], 'Use geometry.attributes and geometry.indices');\n\n    // deprecateMethods(this, ['getAttributes'])\n  }\n\n  get mode() {\n    return this.drawMode;\n  }\n\n  getVertexCount() {\n    return this.vertexCount;\n  }\n\n  // Return an object with all attributes plus indices added as a field.\n  getAttributes() {\n    return this.indices ? {indices: this.indices, ...this.attributes} : this.attributes;\n  }\n\n  // PRIVATE\n\n  _print(attributeName) {\n    return `Geometry ${this.id} attribute ${attributeName}`;\n  }\n\n  // Attribute\n  // value: typed array\n  // type: indices, vertices, uvs\n  // size: elements per vertex\n  // target: WebGL buffer type (string or constant)\n  _setAttributes(attributes, indices) {\n    if (indices) {\n      this.indices = ArrayBuffer.isView(indices) ? {value: indices, size: 1} : indices;\n    }\n\n    for (const attributeName in attributes) {\n      let attribute = attributes[attributeName];\n\n      // Wrap \"unwrapped\" arrays and try to autodetect their type\n      attribute = ArrayBuffer.isView(attribute) ? {value: attribute} : attribute;\n\n      assert(\n        ArrayBuffer.isView(attribute.value),\n        `${this._print(attributeName)}: must be typed array or object with value as typed array`\n      );\n\n      if ((attributeName === 'POSITION' || attributeName === 'positions') && !attribute.size) {\n        attribute.size = 3;\n      }\n\n      // Move indices to separate field\n      if (attributeName === 'indices') {\n        assert(!this.indices);\n        this.indices = attribute;\n      } else {\n        this.attributes[attributeName] = attribute;\n      }\n    }\n\n    if (this.indices && this.indices.isIndexed !== undefined) {\n      this.indices = Object.assign({}, this.indices);\n      delete this.indices.isIndexed;\n    }\n\n    return this;\n  }\n\n  _calculateVertexCount(attributes, indices) {\n    if (indices) {\n      return indices.value.length;\n    }\n    let vertexCount = Infinity;\n    for (const attributeName in attributes) {\n      const attribute = attributes[attributeName];\n      const {value, size, constant} = attribute;\n      if (!constant && value && size >= 1) {\n        vertexCount = Math.min(vertexCount, value.length / size);\n      }\n    }\n\n    assert(Number.isFinite(vertexCount));\n    return vertexCount;\n  }\n}\n","import ShaderModule from './shader-module';\nimport {assert} from '../utils';\n\nexport default class ShaderModuleRegistry {\n  constructor() {\n    this.shaderModules = {};\n    this.defaultShaderModules = [];\n  }\n\n  setDefaultShaderModules(modules) {\n    this.defaultShaderModules = this.resolveModules(modules);\n  }\n\n  getDefaultShaderModules() {\n    return this.defaultShaderModules;\n  }\n\n  registerShaderModules(shaderModuleList, {ignoreMultipleRegistrations = false} = {}) {\n    for (const shaderModule of shaderModuleList) {\n      this._registerShaderModule(shaderModule, ignoreMultipleRegistrations);\n    }\n  }\n\n  getShaderModule(moduleOrName) {\n    // Check if \"inline\" module, return it\n    if (moduleOrName instanceof ShaderModule) {\n      return moduleOrName;\n    }\n\n    // Check if module descriptor\n    if (typeof moduleOrName !== 'string') {\n      return this._registerShaderModule(moduleOrName, true);\n    }\n\n    // Module name - Look up module\n    const module = this.shaderModules[moduleOrName];\n    if (!module) {\n      assert(false, `Unknown shader module ${moduleOrName}`);\n    }\n    return module;\n  }\n\n  // registers any supplied modules, resolves any names into modules\n  // returns a list of modules\n  resolveModules(modules) {\n    return modules.map(moduleOrName => this.getShaderModule(moduleOrName));\n  }\n\n  // PRIVATE API\n\n  _registerShaderModule(module, ignoreMultipleRegistrations = false) {\n    // Check if \"inline\" module, return it\n    if (module instanceof ShaderModule) {\n      return module;\n    }\n\n    assert(module.name, 'shader module has no name');\n\n    if (!this.shaderModules[module.name] || ignoreMultipleRegistrations) {\n      // if ignoreMultipleRegistrations = true, we allow module to be re-registered\n      module = new ShaderModule(module);\n      module.dependencies = this.resolveModules(module.dependencies);\n      this.shaderModules[module.name] = module;\n    } else {\n      // TODO - instead verify that definition is not changing...\n      throw new Error(`shader module ${module.name} already registered`);\n    }\n\n    return this.shaderModules[module.name];\n  }\n}\n","import ShaderModuleRegistry from './shader-module-registry';\n\nconst shaderModuleRegistry = new ShaderModuleRegistry();\n\n/**\n * Registers an array of default shader modules. These will be concatenated\n * automatically at the end of any shader module list passed to\n * `assembleShaders` (plus `resolveModules` and `getShaderDependencies`)\n * @param {Object[]} modules - Array of shader modules\n */\nexport function setDefaultShaderModules(modules) {\n  shaderModuleRegistry.setDefaultShaderModules(modules);\n}\n\nexport function getDefaultShaderModules() {\n  return shaderModuleRegistry.getDefaultShaderModules();\n}\n\n/**\n * Registers an array of shader modules\n * @param {Object[]} shaderModuleList - Array of shader modules\n */\nexport function registerShaderModules(\n  shaderModuleList,\n  {ignoreMultipleRegistrations = false} = {}\n) {\n  shaderModuleRegistry.registerShaderModules(shaderModuleList, {ignoreMultipleRegistrations});\n}\n\n// registers any supplied modules and returns a list of module names\nexport function resolveModules(modules) {\n  modules = modules.concat(shaderModuleRegistry.defaultShaderModules);\n  modules = shaderModuleRegistry.resolveModules(modules);\n  return getShaderDependencies(modules);\n}\n\n// Looks up a moduleName among registered modules and returns definition.\n// If \"inline\" module, returns it directly\nexport function getShaderModule(moduleOrName) {\n  return shaderModuleRegistry.getShaderModule(moduleOrName);\n}\n\n/**\n * Takes a list of shader module names and returns a new list of\n * shader module names that includes all dependencies, sorted so\n * that modules that are dependencies of other modules come first.\n *\n * If the shader glsl code from the returned modules is concatenated\n * in the reverse order, it is guaranteed that all functions be resolved and\n * that all function and variable definitions come before use.\n *\n * @param {String[]} modules - Array of modules (inline modules or module names)\n * @return {String[]} - Array of modules\n */\nfunction getShaderDependencies(modules) {\n  const moduleMap = {};\n  const moduleDepth = {};\n  getDependencyGraph({modules, level: 0, moduleMap, moduleDepth});\n\n  // Return a reverse sort so that dependencies come before the modules that use them\n  return Object.keys(moduleDepth)\n    .sort((a, b) => moduleDepth[b] - moduleDepth[a])\n    .map(name => moduleMap[name]);\n}\n\n/**\n * Recursively checks module dpendencies to calculate dependency\n * level of each module.\n *\n * @param {String[]} modules - Array of modules\n * @param {Number} level - Current level\n * @return {result} - Map of module name to its level\n */\n// Adds another level of dependencies to the result map\nfunction getDependencyGraph({modules, level, moduleMap, moduleDepth}) {\n  if (level >= 5) {\n    throw new Error('Possible loop in shader dependency graph');\n  }\n\n  // Update level on all current modules\n  for (const module of modules) {\n    moduleMap[module.name] = module;\n    if (moduleDepth[module.name] === undefined || moduleDepth[module.name] < level) {\n      moduleDepth[module.name] = level;\n    }\n  }\n\n  // Recurse\n  for (const module of modules) {\n    if (module.dependencies) {\n      getDependencyGraph({modules: module.dependencies, level: level + 1, moduleMap, moduleDepth});\n    }\n  }\n}\n\nexport const TEST_EXPORTS = {\n  getShaderDependencies,\n  getDependencyGraph\n};\n","// Feature detection for WebGL\n//\n// Provides a function that enables simple checking of which WebGL features are\n// available in an WebGL1 or WebGL2 environment.\n\n/* eslint-disable no-inline-comments, max-len */\nimport isOldIE from './is-old-ie';\nimport assert from './assert';\n\nconst GL_VENDOR = 0x1f00;\nconst GL_RENDERER = 0x1f01;\nconst GL_VERSION = 0x1f02;\nconst GL_SHADING_LANGUAGE_VERSION = 0x8b8c;\n\n// Defines luma.gl \"feature\" names and semantics\nconst WEBGL_FEATURES = {\n  // GLSL extensions\n  GLSL_FRAG_DATA: ['WEBGL_draw_buffers', true], // TODO - name makes no sense in GLSL 3.00\n  GLSL_FRAG_DEPTH: ['EXT_frag_depth', true],\n  GLSL_DERIVATIVES: ['OES_standard_derivatives', true],\n  GLSL_TEXTURE_LOD: ['EXT_shader_texture_lod', true]\n};\n\n// Create a key-mirrored FEATURES array\nconst FEATURES = {};\nObject.keys(WEBGL_FEATURES).forEach(key => {\n  FEATURES[key] = key;\n});\n\nexport {FEATURES};\n\nfunction isWebGL2(gl) {\n  return Boolean(gl && gl._version === 2);\n}\n\nexport function getContextInfo(gl) {\n  const info = gl.getExtension('WEBGL_debug_renderer_info');\n  const vendor = gl.getParameter((info && info.UNMASKED_VENDOR_WEBGL) || GL_VENDOR);\n  const renderer = gl.getParameter((info && info.UNMASKED_RENDERER_WEBGL) || GL_RENDERER);\n  const gpuVendor = identifyGPUVendor(vendor, renderer);\n  const gpuInfo = {\n    gpuVendor,\n    vendor,\n    renderer,\n    version: gl.getParameter(GL_VERSION),\n    shadingLanguageVersion: gl.getParameter(GL_SHADING_LANGUAGE_VERSION)\n  };\n  return gpuInfo;\n}\n\nfunction identifyGPUVendor(vendor, renderer) {\n  if (vendor.match(/NVIDIA/i) || renderer.match(/NVIDIA/i)) {\n    return 'NVIDIA';\n  }\n  if (vendor.match(/INTEL/i) || renderer.match(/INTEL/i)) {\n    return 'INTEL';\n  }\n  if (\n    vendor.match(/AMD/i) ||\n    renderer.match(/AMD/i) ||\n    vendor.match(/ATI/i) ||\n    renderer.match(/ATI/i)\n  ) {\n    return 'AMD';\n  }\n  return 'UNKNOWN GPU';\n}\n\nconst compiledGlslExtensions = {};\n\n// Enables feature detection in IE11 due to a bug where gl.getExtension may return true\n// but fail to compile when the extension is enabled in the shader. Specifically,\n// the OES_standard_derivatives and WEBGL_draw_buffers extensions fails to compile in IE11 even though its included\n// in the list of supported extensions.\n// opts allows user agent to be overridden for testing\n/*\n* Inputs :\n*  gl : WebGL context\n*  cap : Key of WEBGL_FEATURES object identifying the extension\n*  opts :\n*   behavior : behavor of extension to be tested, by defualt `enable` is used\n* Returns : true, if shader is compiled successfully, false otherwise\n*/\nexport function canCompileGLGSExtension(gl, cap, opts = {}) {\n  const feature = WEBGL_FEATURES[cap];\n  assert(feature, cap);\n\n  if (!isOldIE(opts)) {\n    return true;\n  }\n\n  if (cap in compiledGlslExtensions) {\n    return compiledGlslExtensions[cap];\n  }\n\n  const extensionName = feature[0];\n  const behavior = opts.behavior || 'enable';\n  const source = `#extension GL_${extensionName} : ${behavior}\\nvoid main(void) {}`;\n\n  const shader = gl.createShader(gl.VERTEX_SHADER);\n  gl.shaderSource(shader, source);\n  gl.compileShader(shader);\n  const canCompile = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\n  gl.deleteShader(shader);\n  compiledGlslExtensions[cap] = canCompile;\n  return canCompile;\n}\n\n// TODO - cache the value\nfunction getFeature(gl, cap) {\n  const feature = WEBGL_FEATURES[cap];\n  assert(feature, cap);\n\n  // Get extension name from table\n  const extensionName = isWebGL2(gl) ? feature[1] || feature[0] : feature[0];\n\n  // Check if the value is dependent on checking an extension\n  const value =\n    typeof extensionName === 'string' ? Boolean(gl.getExtension(extensionName)) : extensionName;\n\n  assert(value === false || value === true);\n\n  return value;\n}\n\nexport function hasFeatures(gl, features) {\n  features = Array.isArray(features) ? features : [features];\n  return features.every(feature => getFeature(gl, feature));\n}\n","/* global window */\n// opts allows user agent to be overridden for testing\nexport default function isOldIE(opts = {}) {\n  const navigator = typeof window !== 'undefined' ? window.navigator || {} : {};\n  const userAgent = opts.userAgent || navigator.userAgent || '';\n  // We only care about older versions of IE (IE 11 and below). Newer versions of IE (Edge)\n  // have much better web standards support.\n  const isMSIE = userAgent.indexOf('MSIE ') !== -1;\n  const isTrident = userAgent.indexOf('Trident/') !== -1;\n  return isMSIE || isTrident;\n}\n","import {getContextInfo, hasFeatures, canCompileGLGSExtension, FEATURES} from '../utils/webgl-info';\n\nexport function getPlatformShaderDefines(gl) {\n  const debugInfo = getContextInfo(gl);\n\n  switch (debugInfo.gpuVendor.toLowerCase()) {\n    case 'nvidia':\n      return `\\\n#define NVIDIA_GPU\n// Nvidia optimizes away the calculation necessary for emulated fp64\n#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1\n`;\n\n    case 'intel':\n      return `\\\n#define INTEL_GPU\n// Intel optimizes away the calculation necessary for emulated fp64\n#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1\n// Intel's built-in 'tan' function doesn't have acceptable precision\n#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1\n// Intel GPU doesn't have full 32 bits precision in same cases, causes overflow\n#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1\n`;\n\n    case 'amd':\n      // AMD Does not eliminate fp64 code\n      return `\\\n#define AMD_GPU\n`;\n\n    default:\n      // We don't know what GPU it is, could be that the GPU driver or\n      // browser is not implementing UNMASKED_RENDERER constant and not\n      // reporting a correct name\n      return `\\\n#define DEFAULT_GPU\n// Prevent driver from optimizing away the calculation necessary for emulated fp64\n#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1\n// Intel's built-in 'tan' function doesn't have acceptable precision\n#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1\n// Intel GPU doesn't have full 32 bits precision in same cases, causes overflow\n#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1\n`;\n  }\n}\n\nexport function getVersionDefines(gl, glslVersion, isFragment) {\n  // Add shadertools defines to let shaders portably v1/v3 check for features\n  let versionDefines = `\\\n#if (__VERSION__ > 120)\n\n# define FRAG_DEPTH\n# define DERIVATIVES\n# define DRAW_BUFFERS\n# define TEXTURE_LOD\n\n#endif // __VERSION\n`;\n\n  if (hasFeatures(gl, FEATURES.GLSL_FRAG_DEPTH)) {\n    versionDefines += `\\\n// FRAG_DEPTH => gl_FragDepth is available\n#ifdef GL_EXT_frag_depth\n#extension GL_EXT_frag_depth : enable\n# define FRAG_DEPTH\n# define gl_FragDepth gl_FragDepthEXT\n#endif\n`;\n  }\n  if (\n    hasFeatures(gl, FEATURES.GLSL_DERIVATIVES) &&\n    canCompileGLGSExtension(gl, FEATURES.GLSL_DERIVATIVES)\n  ) {\n    versionDefines += `\\\n// DERIVATIVES => dxdF, dxdY and fwidth are available\n#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives : enable\n# define DERIVATIVES\n#endif\n`;\n  }\n  if (\n    hasFeatures(gl, FEATURES.GLSL_FRAG_DATA) &&\n    canCompileGLGSExtension(gl, FEATURES.GLSL_FRAG_DATA, {behavior: 'require'})\n  ) {\n    versionDefines += `\\\n// DRAW_BUFFERS => gl_FragData[] is available\n#ifdef GL_EXT_draw_buffers\n#extension GL_EXT_draw_buffers : require\n#define DRAW_BUFFERS\n#endif\n`;\n  }\n  if (hasFeatures(gl, FEATURES.GLSL_TEXTURE_LOD)) {\n    versionDefines += `\\\n// TEXTURE_LOD => texture2DLod etc are available\n#ifdef GL_EXT_shader_texture_lod\n#extension GL_EXT_shader_texture_lod : enable\n# define TEXTURE_LOD\n#define texture2DLod texture2DLodEXT\n#define texture2DProjLod texture2DProjLodEXT\n#define texture2DProjLod texture2DProjLodEXT\n#define textureCubeLod textureCubeLodEXT\n#define texture2DGrad texture2DGradEXT\n#define texture2DProjGrad texture2DProjGradEXT\n#define texture2DProjGrad texture2DProjGradEXT\n#define textureCubeGrad textureCubeGradEXT\n#endif\n`;\n  }\n  return versionDefines;\n}\n","import {VERTEX_SHADER, FRAGMENT_SHADER} from './constants';\nimport {resolveModules, getShaderModule} from './resolve-modules';\nimport {getPlatformShaderDefines, getVersionDefines} from './platform-defines';\nimport injectShader, {DECLARATION_INJECT_MARKER} from './inject-shader';\nimport {assert} from '../utils';\n/* eslint-disable max-depth, complexity */\n\nconst INJECT_SHADER_DECLARATIONS = `\\n\\n${DECLARATION_INJECT_MARKER}\\n\\n`;\n\nconst SHADER_TYPE = {\n  [VERTEX_SHADER]: 'vertex',\n  [FRAGMENT_SHADER]: 'fragment'\n};\n\nconst HOOK_FUNCTIONS = {\n  [VERTEX_SHADER]: {},\n  [FRAGMENT_SHADER]: {}\n};\n\nconst MODULE_INJECTIONS = {};\n\n// Precision prologue to inject before functions are injected in shader\n// TODO - extract any existing prologue in the fragment source and move it up...\nconst FRAGMENT_SHADER_PROLOGUE = `\\\nprecision highp float;\n\n`;\n\nexport function createShaderHook(hook, opts = {}) {\n  hook = hook.trim();\n  const [stage, signature] = hook.split(':');\n  const name = hook.replace(/\\(.+/, '');\n  HOOK_FUNCTIONS[stage][name] = Object.assign(opts, {signature});\n}\n\nexport function createModuleInjection(moduleName, opts) {\n  const {hook, injection, order = 0} = opts;\n  const shaderStage = hook.slice(0, 2);\n\n  MODULE_INJECTIONS[moduleName] = MODULE_INJECTIONS[moduleName] || {};\n  MODULE_INJECTIONS[moduleName][shaderStage] = MODULE_INJECTIONS[moduleName][shaderStage] || {};\n\n  assert(!MODULE_INJECTIONS[moduleName][shaderStage][hook], 'Module injection already created');\n\n  MODULE_INJECTIONS[moduleName][shaderStage][hook] = {\n    injection,\n    order\n  };\n}\n\n// Inject a list of modules\nexport function assembleShaders(gl, opts) {\n  const {vs, fs} = opts;\n  const modules = resolveModules(opts.modules || []);\n  return {\n    gl,\n    vs: assembleShader(gl, Object.assign({}, opts, {source: vs, type: VERTEX_SHADER, modules})),\n    fs: assembleShader(gl, Object.assign({}, opts, {source: fs, type: FRAGMENT_SHADER, modules})),\n    getUniforms: assembleGetUniforms(modules),\n    modules: assembleModuleMap(modules)\n  };\n}\n\n// Pulls together complete source code for either a vertex or a fragment shader\n// adding prologues, requested module chunks, and any final injections.\nfunction assembleShader(\n  gl,\n  {id, source, type, modules, defines = {}, inject = {}, prologue = true, log}\n) {\n  assert(typeof source === 'string', 'shader source must be a string');\n\n  const isVertex = type === VERTEX_SHADER;\n\n  const sourceLines = source.split('\\n');\n  let glslVersion = 100;\n  let versionLine = '';\n  let coreSource = source;\n  // Extract any version directive string from source.\n  // TODO : keep all pre-processor statements at the begining of the shader.\n  if (sourceLines[0].indexOf('#version ') === 0) {\n    glslVersion = 300; // TODO - regexp that matches atual version number\n    versionLine = sourceLines[0];\n    coreSource = sourceLines.slice(1).join('\\n');\n  }\n\n  // Combine Module and Application Defines\n  const allDefines = {};\n  modules.forEach(module => {\n    Object.assign(allDefines, module.getDefines());\n  });\n  Object.assign(allDefines, defines);\n\n  // Add platform defines (use these to work around platform-specific bugs and limitations)\n  // Add common defines (GLSL version compatibility, feature detection)\n  // Add precision declaration for fragment shaders\n  let assembledSource = prologue\n    ? `\\\n${versionLine}\n${getShaderName({id, source, type})}\n${getShaderType({type})}\n${getPlatformShaderDefines(gl)}\n${getVersionDefines(gl, glslVersion, !isVertex)}\n${getApplicationDefines(allDefines)}\n${isVertex ? '' : FRAGMENT_SHADER_PROLOGUE}\n`\n    : `${versionLine}\n`;\n\n  // Add source of dependent modules in resolved order\n  let injectStandardStubs = false;\n  const hookInjections = {};\n  const mainInjections = {};\n\n  for (const key in inject) {\n    const injection =\n      typeof inject[key] === 'string' ? {injection: inject[key], order: 0} : inject[key];\n    if (key.match(/^(v|f)s:/)) {\n      if (key[3] === '#') {\n        mainInjections[key] = [injection];\n      } else {\n        hookInjections[key] = [injection];\n      }\n    } else {\n      // Regex injection\n      mainInjections[key] = [injection];\n    }\n  }\n\n  for (const module of modules) {\n    switch (module.name) {\n      case 'inject':\n        injectStandardStubs = true;\n        break;\n\n      default:\n        if (log) {\n          module.checkDeprecations(coreSource, log);\n        }\n        const moduleSource = module.getModuleSource(type, glslVersion);\n        // Add the module source, and a #define that declares it presence\n        assembledSource += moduleSource;\n\n        if (MODULE_INJECTIONS[module.name]) {\n          const injections = MODULE_INJECTIONS[module.name][type];\n          for (const key in injections) {\n            if (key.match(/^(v|f)s:#/)) {\n              mainInjections[key] = mainInjections[key] || [];\n              mainInjections[key].push(injections[key]);\n            } else {\n              hookInjections[key] = hookInjections[key] || [];\n              hookInjections[key].push(injections[key]);\n            }\n          }\n        }\n    }\n  }\n\n  // For injectShader\n  assembledSource += INJECT_SHADER_DECLARATIONS;\n\n  assembledSource += getHookFunctions(type, hookInjections);\n\n  // Add the version directive and actual source of this shader\n  assembledSource += coreSource;\n\n  // Apply any requested shader injections\n  assembledSource = injectShader(assembledSource, type, mainInjections, injectStandardStubs);\n\n  return assembledSource;\n}\n\n// Returns a combined `getUniforms` covering the options for all the modules,\n// the created function will pass on options to the inidividual `getUniforms`\n// function of each shader module and combine the results into one object that\n// can be passed to setUniforms.\nfunction assembleGetUniforms(modules) {\n  return function getUniforms(opts) {\n    const uniforms = {};\n    for (const module of modules) {\n      // `modules` is already sorted by dependency level. This guarantees that\n      // modules have access to the uniforms that are generated by their dependencies.\n      const moduleUniforms = module.getUniforms(opts, uniforms);\n      Object.assign(uniforms, moduleUniforms);\n    }\n    return uniforms;\n  };\n}\n\n// Returns a map with module names as keys, resolving to their module definitions\n// The presence of a key indicates that the module is available in this program,\n// whether directly included, or through a dependency of some other module\nfunction assembleModuleMap(modules) {\n  const result = {};\n  for (const moduleName of modules) {\n    const shaderModule = getShaderModule(moduleName);\n    result[moduleName] = shaderModule;\n  }\n  return result;\n}\n\nfunction getShaderType({type}) {\n  return `\n#define SHADER_TYPE_${SHADER_TYPE[type].toUpperCase()}\n`;\n}\n\n// Generate \"glslify-compatible\" SHADER_NAME defines\n// These are understood by the GLSL error parsing function\n// If id is provided and no SHADER_NAME constant is present in source, create one\nfunction getShaderName({id, source, type}) {\n  const injectShaderName = id && typeof id === 'string' && source.indexOf('SHADER_NAME') === -1;\n  return injectShaderName\n    ? `\n#define SHADER_NAME ${id}_${SHADER_TYPE[type]}\n\n`\n    : '';\n}\n\n// Generates application defines from an object\nfunction getApplicationDefines(defines = {}) {\n  let count = 0;\n  let sourceText = '';\n  for (const define in defines) {\n    if (count === 0) {\n      sourceText += '\\n// APPLICATION DEFINES\\n';\n    }\n    count++;\n\n    const value = defines[define];\n    if (value || Number.isFinite(value)) {\n      sourceText += `#define ${define.toUpperCase()} ${defines[define]}\\n`;\n    }\n  }\n  if (count === 0) {\n    sourceText += '\\n';\n  }\n  return sourceText;\n}\n\nfunction getHookFunctions(shaderStage, hookInjections) {\n  let result = '';\n  const hookFunctions = HOOK_FUNCTIONS[shaderStage];\n  for (const hookName in hookFunctions) {\n    const hookFunction = hookFunctions[hookName];\n    result += `void ${hookFunction.signature} {\\n`;\n    if (hookFunction.header) {\n      result += `  ${hookFunction.header}`;\n    }\n    if (hookInjections[hookName]) {\n      const injections = hookInjections[hookName];\n      injections.sort((a, b) => a.order - b.order);\n      for (const injection of injections) {\n        result += `  ${injection.injection}\\n`;\n      }\n    }\n    if (hookFunction.footer) {\n      result += `  ${hookFunction.footer}`;\n    }\n    result += '}\\n';\n  }\n\n  return result;\n}\n","import GL from '@luma.gl/constants';\nimport {Buffer} from '@luma.gl/webgl';\nimport {assert} from '../utils';\n\n// Support for mapping new geometries with glTF attribute names to \"classic\" luma.gl shader names\nconst GLTF_TO_LUMA_ATTRIBUTE_MAP = {\n  POSITION: 'positions',\n  NORMAL: 'normals',\n  COLOR_0: 'colors',\n  TEXCOORD_0: 'texCoords',\n  TEXCOORD_1: 'texCoords1',\n  TEXCOORD_2: 'texCoords2'\n};\n\nexport function getBuffersFromGeometry(gl, geometry, options) {\n  const buffers = {};\n  let indices = geometry.indices;\n\n  for (const name in geometry.attributes) {\n    const attribute = geometry.attributes[name];\n    const remappedName = mapAttributeName(name, options);\n\n    if (name === 'indices') {\n      indices = attribute;\n    } else if (attribute.constant) {\n      buffers[remappedName] = attribute.value;\n    } else {\n      const typedArray = attribute.value;\n      // Create accessor by copying the attribute and removing `value``\n      const accessor = {...attribute};\n      delete accessor.value;\n      buffers[remappedName] = [new Buffer(gl, typedArray), accessor];\n\n      inferAttributeAccessor(name, accessor);\n    }\n  }\n\n  if (indices) {\n    const data = indices.value || indices;\n    assert(\n      data instanceof Uint16Array || data instanceof Uint32Array,\n      'attribute array for \"indices\" must be of integer type'\n    );\n    const accessor = {\n      size: 1,\n      isIndexed: indices.isIndexed === undefined ? true : indices.isIndexed\n    };\n    buffers.indices = [\n      new Buffer(gl, {\n        data,\n        target: GL.ELEMENT_ARRAY_BUFFER\n      }),\n      accessor\n    ];\n  }\n\n  return buffers;\n}\n\nfunction mapAttributeName(name, options) {\n  const {attributeMap = GLTF_TO_LUMA_ATTRIBUTE_MAP} = options || {};\n  return (attributeMap && attributeMap[name]) || name;\n}\n\n// Check for well known attribute names\n// eslint-disable-next-line complexity\nexport function inferAttributeAccessor(attributeName, attribute) {\n  let category;\n  switch (attributeName) {\n    case 'texCoords':\n    case 'texCoord1':\n    case 'texCoord2':\n    case 'texCoord3':\n      category = 'uvs';\n      break;\n    case 'vertices':\n    case 'positions':\n    case 'normals':\n    case 'pickingColors':\n      category = 'vectors';\n      break;\n    default:\n  }\n\n  // Check for categorys\n  switch (category) {\n    case 'vectors':\n      attribute.size = attribute.size || 3;\n      break;\n    case 'uvs':\n      attribute.size = attribute.size || 2;\n      break;\n    default:\n  }\n\n  assert(Number.isFinite(attribute.size), `attribute ${attributeName} needs size`);\n}\n","// TODO / DEPRECATED - delete when confident that probe.gl logging implements all opts\n/* eslint-disable no-console */\nfunction formatArrayValue(v, opts) {\n  const {maxElts = 16, size = 1} = opts;\n  let string = '[';\n  for (let i = 0; i < v.length && i < maxElts; ++i) {\n    if (i > 0) {\n      string += `,${i % size === 0 ? ' ' : ''}`;\n    }\n    string += formatValue(v[i], opts);\n  }\n  const terminator = v.length > maxElts ? '...' : ']';\n  return `${string}${terminator}`;\n}\n\nexport function formatValue(v, opts = {}) {\n  const EPSILON = 1e-16;\n  const {isInteger = false} = opts;\n  if (Array.isArray(v) || ArrayBuffer.isView(v)) {\n    return formatArrayValue(v, opts);\n  }\n  if (!Number.isFinite(v)) {\n    return String(v);\n  }\n  if (Math.abs(v) < EPSILON) {\n    return isInteger ? '0' : '0.';\n  }\n  if (isInteger) {\n    return v.toFixed(0);\n  }\n  if (Math.abs(v) > 100 && Math.abs(v) < 10000) {\n    return v.toFixed(0);\n  }\n  const string = v.toPrecision(2);\n  const decimal = string.indexOf('.0');\n  return decimal === string.length - 2 ? string.slice(0, -1) : string;\n}\n","import Buffer from '../classes/buffer';\nimport {getKey} from '../webgl-utils';\nimport {getCompositeGLType} from '../webgl-utils/attribute-utils';\nimport {formatValue} from '../utils';\n\n// Creates object suitable as input for console.table\nexport function getDebugTableForVertexArray({vertexArray, header = 'Attributes'} = {}) {\n  if (!vertexArray.configuration) {\n    return {};\n  }\n\n  const table = {}; // {[header]: {}};\n\n  // Add index (elements) if available\n  if (vertexArray.elements) {\n    // const elements = Object.assign({size: 1}, vertexArray.elements);\n    table.ELEMENT_ARRAY_BUFFER = getDebugTableRow(vertexArray, vertexArray.elements, null, header);\n  }\n\n  // Add used attributes\n  const attributes = vertexArray.values;\n\n  for (const attributeLocation in attributes) {\n    const info = vertexArray._getAttributeInfo(attributeLocation);\n    if (info) {\n      let rowHeader = `${attributeLocation}: ${info.name}`;\n      const accessor = vertexArray.accessors[info.location];\n      if (accessor) {\n        rowHeader = `${attributeLocation}: ${getGLSLDeclaration(info.name, accessor)}`;\n      }\n      table[rowHeader] = getDebugTableRow(\n        vertexArray,\n        attributes[attributeLocation],\n        accessor,\n        header\n      );\n    }\n  }\n\n  return table;\n}\n\n/* eslint-disable max-statements */\nfunction getDebugTableRow(vertexArray, attribute, accessor, header) {\n  // const round = xnum => Math.round(num * 10) / 10;\n  const {gl} = vertexArray;\n\n  let type = 'NOT PROVIDED';\n  let size = 'N/A';\n  let verts = 'N/A';\n  let bytes = 'N/A';\n\n  let isInteger;\n  let marker;\n  let value;\n\n  if (accessor) {\n    type = accessor.type;\n    size = accessor.size;\n\n    // Generate a type name by dropping Array from Float32Array etc.\n    type = String(type).replace('Array', '');\n\n    // Look for 'nt' to detect integer types, e.g. Int32Array, Uint32Array\n    isInteger = type.indexOf('nt') !== -1;\n  }\n\n  if (attribute instanceof Buffer) {\n    const buffer = attribute;\n\n    const {data, modified} = buffer.getDebugData();\n    marker = modified ? '*' : '';\n\n    value = data;\n    bytes = buffer.byteLength;\n    verts = bytes / data.BYTES_PER_ELEMENT / size;\n\n    let format;\n\n    if (accessor) {\n      const instanced = accessor.divisor > 0;\n      format = `${instanced ? 'I ' : 'P '} ${verts} (x${size}=${bytes} bytes ${getKey(gl, type)})`;\n    } else {\n      // element buffer\n      isInteger = true;\n      format = `${bytes} bytes`;\n    }\n\n    return {\n      [header]: `${marker}${formatValue(value, {size, isInteger})}`,\n      'Format ': format\n    };\n  }\n\n  // CONSTANT VALUE\n  value = attribute;\n  size = attribute.length;\n  // Generate a type name by dropping Array from Float32Array etc.\n  type = String(attribute.constructor.name).replace('Array', '');\n  // Look for 'nt' to detect integer types, e.g. Int32Array, Uint32Array\n  isInteger = type.indexOf('nt') !== -1;\n\n  return {\n    [header]: `${formatValue(value, {size, isInteger})} (constant)`,\n    'Format ': `${size}x${type} (constant)`\n  };\n}\n/* eslint-ensable max-statements */\n\nfunction getGLSLDeclaration(name, accessor) {\n  const {type, size} = accessor;\n  const typeAndName = getCompositeGLType(type, size);\n  if (typeAndName) {\n    return `${name} (${typeAndName.name})`;\n  }\n  return name;\n}\n","import {formatValue, assert} from '../utils';\n\n// Prepares a table suitable for console.table\n/* eslint-disable max-statements, complexity */\nexport function getDebugTableForUniforms({\n  header = 'Uniforms',\n  program,\n  uniforms,\n  undefinedOnly = false\n} = {}) {\n  assert(program);\n\n  const SHADER_MODULE_UNIFORM_REGEXP = '.*_.*';\n  const PROJECT_MODULE_UNIFORM_REGEXP = '.*Matrix'; // TODO - Use explicit list\n\n  const uniformLocations = program._uniformSetters;\n  const table = {}; // {[header]: {}};\n\n  // Add program's provided uniforms (in alphabetical order)\n  const uniformNames = Object.keys(uniformLocations).sort();\n\n  let count = 0;\n\n  // First add non-underscored uniforms (assumed not coming from shader modules)\n  for (const uniformName of uniformNames) {\n    if (\n      !uniformName.match(SHADER_MODULE_UNIFORM_REGEXP) &&\n      !uniformName.match(PROJECT_MODULE_UNIFORM_REGEXP)\n    ) {\n      if (addUniformToTable({table, header, uniforms, uniformName, undefinedOnly})) {\n        count++;\n      }\n    }\n  }\n\n  // add underscored uniforms (assumed from shader modules)\n  for (const uniformName of uniformNames) {\n    if (uniformName.match(PROJECT_MODULE_UNIFORM_REGEXP)) {\n      if (addUniformToTable({table, header, uniforms, uniformName, undefinedOnly})) {\n        count++;\n      }\n    }\n  }\n\n  for (const uniformName of uniformNames) {\n    if (!table[uniformName]) {\n      if (addUniformToTable({table, header, uniforms, uniformName, undefinedOnly})) {\n        count++;\n      }\n    }\n  }\n\n  // Create a table of unused uniforms\n  let unusedCount = 0;\n  const unusedTable = {};\n  if (!undefinedOnly) {\n    for (const uniformName in uniforms) {\n      const uniform = uniforms[uniformName];\n      if (!table[uniformName]) {\n        unusedCount++;\n        unusedTable[uniformName] = {\n          Type: `NOT USED: ${uniform}`,\n          [header]: formatValue(uniform)\n        };\n      }\n    }\n  }\n\n  return {table, count, unusedTable, unusedCount};\n}\n\n// Helper\nfunction addUniformToTable({table, header, uniforms, uniformName, undefinedOnly}) {\n  const value = uniforms[uniformName];\n  const isDefined = isUniformDefined(value);\n  if (!undefinedOnly || !isDefined) {\n    table[uniformName] = {\n      // Add program's unprovided uniforms\n      [header]: isDefined ? formatValue(value) : 'N/A',\n      'Uniform Type': isDefined ? value : 'NOT PROVIDED'\n    };\n    return true;\n  }\n  return false;\n}\n\nfunction isUniformDefined(value) {\n  return value !== undefined && value !== null;\n}\n","import {getCompositeGLType} from '../webgl-utils/attribute-utils';\n\nexport function getDebugTableForProgramConfiguration(config) {\n  const table = {};\n\n  const header = `Accessors for ${config.id}`;\n\n  for (const attributeInfo of config.attributeInfos) {\n    if (attributeInfo) {\n      const glslDeclaration = getGLSLDeclaration(attributeInfo);\n      table[`in ${glslDeclaration}`] = {[header]: JSON.stringify(attributeInfo.accessor)};\n    }\n  }\n\n  for (const varyingInfo of config.varyingInfos) {\n    if (varyingInfo) {\n      const glslDeclaration = getGLSLDeclaration(varyingInfo);\n      table[`out ${glslDeclaration}`] = {[header]: JSON.stringify(varyingInfo.accessor)};\n    }\n  }\n\n  return table;\n}\n\nfunction getGLSLDeclaration(attributeInfo) {\n  const {type, size} = attributeInfo.accessor;\n  const typeAndName = getCompositeGLType(type, size);\n  if (typeAndName) {\n    return `${typeAndName.name} ${attributeInfo.name}`;\n  }\n  return attributeInfo.name;\n}\n","import seer from 'seer';\n\nimport {window} from '../utils';\n\nconst models = {};\n\n/**\n * Add a model to our cache indexed by id\n */\nexport const addModel = model => {\n  if (models[model.id]) {\n    return;\n  }\n  models[model.id] = model;\n\n  seer.listItem('luma.gl', model.id);\n};\n\n/**\n * Log a model uniforms and attributes.\n */\nexport const logModel = (model, uniforms) => {\n  if (!seer.isReady() || seer.throttle(`luma.gl:${model.id}`, 1e3)) {\n    return;\n  }\n\n  const attributesObject = model.geometry\n    ? Object.assign({}, model.geometry.attributes, model.attributes)\n    : model.attributes;\n  const uniformsObject = Object.assign({}, model.uniforms, uniforms);\n\n  seer.multiUpdate('luma.gl', model.id, [\n    {path: 'objects.uniforms', data: uniformsObject},\n    {path: 'objects.attributes', data: attributesObject}\n  ]);\n};\n\n/**\n * Remove a previously set model from the cache\n */\nexport const removeModel = id => {\n  delete models[id];\n  seer.deleteItem('luma.gl', id);\n};\n\n/**\n * Recursively traverse an object given a path of properties and set the given value\n */\nconst recursiveSet = (obj, path, value) => {\n  if (!obj) {\n    return;\n  }\n\n  if (path.length > 1) {\n    recursiveSet(obj[path[0]], path.slice(1), value);\n  } else {\n    obj[path[0]] = value;\n  }\n};\n\nconst overrides = new Map();\n\n/**\n * Create an override on the specify layer, indexed by a valuePath array.\n * Do nothing in case Seer as not been initialized to prevent any preformance drawback.\n */\nexport const setOverride = (id, valuePath, value) => {\n  if (!window.__SEER_INITIALIZED__) {\n    return;\n  }\n\n  if (!overrides.has(id)) {\n    overrides.set(id, new Map());\n  }\n\n  const uniforms = overrides.get(id);\n  uniforms.set(valuePath, value);\n};\n\n/**\n * Apply overrides to a specific model's uniforms\n */\nexport const getOverrides = (id, uniforms) => {\n  if (!window.__SEER_INITIALIZED__ || !id) {\n    return;\n  }\n\n  const overs = overrides.get(id);\n  if (!overs) {\n    return;\n  }\n\n  overs.forEach((value, valuePath) => {\n    recursiveSet(uniforms, valuePath, value);\n  });\n};\n\n/**\n * Listen for luma.gl edit events\n */\nseer.listenFor('luma.gl', payload => {\n  const model = models[payload.itemKey];\n  if (!model || payload.type !== 'edit' || payload.valuePath[0] !== 'uniforms') {\n    return;\n  }\n\n  const valuePath = payload.valuePath.slice(1);\n  setOverride(payload.itemKey, valuePath, payload.value);\n\n  const uniforms = model.getUniforms();\n  recursiveSet(uniforms, valuePath, payload.value);\n  model.setUniforms(uniforms);\n});\n","// Shared code between Model and MeshModel\n\nimport GL from '@luma.gl/constants';\nimport {isWebGL, Query, Program, VertexArray} from '@luma.gl/webgl';\nimport {MODULAR_SHADERS, assembleShaders} from '@luma.gl/shadertools';\nimport {\n  getDebugTableForUniforms,\n  getDebugTableForVertexArray,\n  getDebugTableForProgramConfiguration\n} from '@luma.gl/webgl';\nimport {addModel, removeModel, logModel, getOverrides} from '../debug/seer-integration';\nimport {log, isObjectEmpty, uid, assert} from '../utils';\n\nconst LOG_DRAW_PRIORITY = 2;\nconst LOG_DRAW_TIMEOUT = 10000;\n\n// Model abstract O3D Class\nexport default class BaseModel {\n  constructor(gl, props = {}) {\n    assert(isWebGL(gl));\n    const {id = uid('base-model')} = props;\n    this.id = id;\n    this.gl = gl;\n    this.id = props.id || uid('Model');\n    this.lastLogTime = 0; // TODO - move to probe.gl\n    this.initialize(props);\n    this._setBaseModelProps(props);\n  }\n\n  initialize(props) {\n    this.props = {};\n    this.program = this._createProgram(props);\n\n    // Create a vertex array configured after this program\n    this.vertexArray = new VertexArray(this.gl, {program: this.program});\n\n    // Initialize state\n    this.userData = {};\n    this.needsRedraw = true;\n\n    // Attributes and buffers\n    // Model manages auto Buffer creation from typed arrays\n    this._attributes = {}; // All attributes\n    this.attributes = {}; // User defined attributes\n\n    // Model manages uniform animation\n    this.animatedUniforms = {};\n    this.animated = false;\n    this.animationLoop = null; // if set, used as source for animationProps\n\n    this.timerQueryEnabled = false;\n    this.timeElapsedQuery = undefined;\n    this.lastQueryReturned = true;\n\n    this.stats = {\n      accumulatedFrameTime: 0,\n      averageFrameTime: 0,\n      profileFrameCount: 0\n    };\n\n    // picking options\n    this.pickable = true;\n\n    this._setBaseModelProps(props);\n\n    // Make sure we have some reasonable default uniforms in place\n    this.setUniforms(\n      Object.assign(\n        {},\n        this.getModuleUniforms(), // Get all default uniforms\n        this.getModuleUniforms(props.moduleSettings) // Get unforms for supplied parameters\n      )\n    );\n  }\n\n  setProps(props) {\n    this._setBaseModelProps(props);\n  }\n\n  delete() {\n    // delete all attributes created by this model\n    // TODO - should buffer deletes be handled by vertex array?\n    for (const key in this._attributes) {\n      if (this._attributes[key] !== this.attributes[key]) {\n        this._attributes[key].delete();\n      }\n    }\n\n    this.program.delete();\n    this.vertexArray.delete();\n\n    removeModel(this.id);\n  }\n\n  // GETTERS\n\n  isAnimated() {\n    return this.animated;\n  }\n\n  getProgram() {\n    return this.program;\n  }\n\n  getUniforms() {\n    return this.program.uniforms;\n  }\n\n  // SETTERS\n\n  // TODO - should actually set the uniforms\n  setUniforms(uniforms = {}) {\n    // Let Seer override edited uniforms\n    uniforms = Object.assign({}, uniforms);\n    getOverrides(this.id, uniforms);\n\n    // Resolve any animated uniforms so that we have an initial value\n    uniforms = this._extractAnimatedUniforms(uniforms);\n\n    this.program.setUniforms(uniforms);\n\n    return this;\n  }\n\n  updateModuleSettings(opts) {\n    const uniforms = this.getModuleUniforms(opts || {});\n    return this.setUniforms(uniforms);\n  }\n\n  // DRAW CALLS\n\n  /* eslint-disable max-statements  */\n  drawGeometry(opts = {}) {\n    const {\n      moduleSettings = null,\n      framebuffer,\n      uniforms = {},\n      attributes = {},\n      transformFeedback = this.transformFeedback,\n      parameters = {},\n      vertexArray = this.vertexArray,\n      animationProps\n    } = opts;\n\n    // Update module settings\n\n    addModel(this);\n\n    // Update model with any just provided attributes, settings or uniforms\n    this.setAttributes(attributes);\n    this.updateModuleSettings(moduleSettings);\n    this.setUniforms(uniforms);\n\n    // Animate any function valued uniforms\n    this._refreshAnimationProps(animationProps);\n\n    const logPriority = this._logDrawCallStart(2);\n\n    const drawParams = this.vertexArray.getDrawParams(this.props);\n    if (drawParams.isInstanced && !this.isInstanced) {\n      log.warn('Found instanced attributes on non-instanced model', this.id)();\n    }\n\n    const {isIndexed, indexType, indexOffset} = drawParams;\n    const {isInstanced, instanceCount} = this;\n\n    const noop = () => {};\n    const {onBeforeRender = noop, onAfterRender = noop} = this.props;\n\n    onBeforeRender();\n\n    this._timerQueryStart();\n\n    const didDraw = this.program.draw(\n      Object.assign({}, opts, {\n        logPriority,\n        uniforms: null, // Already set (may contain \"function values\" not understood by Program)\n        framebuffer,\n        parameters,\n        drawMode: this.getDrawMode(),\n        vertexCount: this.getVertexCount(),\n        vertexArray,\n        transformFeedback,\n        isIndexed,\n        indexType,\n        isInstanced,\n        instanceCount,\n        offset: isIndexed ? indexOffset : 0\n      })\n    );\n\n    this._timerQueryEnd();\n\n    onAfterRender();\n\n    this._logDrawCallEnd(logPriority, vertexArray, framebuffer);\n\n    return didDraw;\n  }\n  /* eslint-enable max-statements  */\n\n  // PRIVATE METHODS\n\n  // eslint-disable-next-line max-statements, complexity\n  _setBaseModelProps(props) {\n    Object.assign(this.props, props);\n\n    if ('uniforms' in props) {\n      this.setUniforms(props.uniforms);\n    }\n\n    if ('pickable' in props) {\n      this.pickable = props.pickable;\n    }\n\n    // if ('onBeforeRender' in props) {}\n    // if ('onAfterRender' in props) {}\n\n    // Experimental props\n    if ('timerQueryEnabled' in props) {\n      this.timerQueryEnabled = props.timerQueryEnabled && Query.isSupported(this.gl, ['timers']);\n      if (props.timerQueryEnabled && !this.timerQueryEnabled) {\n        log.warn('GPU timer not supported')();\n      }\n    }\n\n    if ('_animationProps' in props) {\n      this._setAnimationProps(props._animationProps);\n    }\n\n    if ('_animationLoop' in props) {\n      this.animationLoop = props._animationLoop;\n    }\n  }\n\n  _createProgram({\n    vs = null,\n    fs = null,\n    // 1: Modular shaders\n    modules = null,\n    defines = {},\n    inject = {},\n    shaderCache = null,\n    // TransformFeedback\n    varyings = null,\n    bufferMode = GL.SEPARATE_ATTRIBS,\n    program = null\n  }) {\n    this.getModuleUniforms = x => {};\n\n    const id = this.id;\n\n    if (!program) {\n      // Assign default shaders if none are provided\n      vs = vs || MODULAR_SHADERS.vs;\n      fs = fs || MODULAR_SHADERS.fs;\n\n      const assembleResult = assembleShaders(this.gl, {vs, fs, modules, inject, defines, log});\n      ({vs, fs} = assembleResult);\n\n      if (shaderCache) {\n        program = shaderCache.getProgram(this.gl, {id, vs, fs});\n      } else {\n        program = new Program(this.gl, {id, vs, fs, varyings, bufferMode});\n      }\n\n      this.getModuleUniforms = assembleResult.getUniforms || (x => {});\n    }\n\n    assert(program instanceof Program, 'Model needs a program');\n    return program;\n  }\n\n  // Refreshes animated uniforms, attempting to get animated props from animationLoop if registered\n  _refreshAnimationProps(animationProps) {\n    // Try to read animationProps\n    animationProps = animationProps || (this.animationLoop && this.animationLoop.animationProps);\n    if (animationProps) {\n      this._setAnimationProps(animationProps);\n    }\n  }\n\n  // Calculate new values for any function uniforms based on supplied animationProps\n  _evaluateAnimateUniforms(animationProps) {\n    if (!this.animated) {\n      return {};\n    }\n    const animatedUniforms = {};\n    for (const uniformName in this.animatedUniforms) {\n      const valueFunction = this.animatedUniforms[uniformName];\n      animatedUniforms[uniformName] = valueFunction(animationProps);\n    }\n    return animatedUniforms;\n  }\n\n  // Extracts a list of function valued uniforms, so we can update them before each draw call\n  // Also removes such uniforms from the returned list\n  _extractAnimatedUniforms(uniforms) {\n    let foundAnimated = false;\n\n    // Keep our animatedUniforms map up-to-date\n    for (const uniformName in uniforms) {\n      const newValue = uniforms[uniformName];\n      if (typeof newValue === 'function') {\n        this.animatedUniforms[uniformName] = newValue;\n        foundAnimated = true;\n      } else {\n        delete this.animatedUniforms[uniformName];\n      }\n    }\n\n    // Update animated flag: `Model` is animated if any uniforms are animated (i.e. functions)\n    this.animated = !isObjectEmpty(this.animatedUniforms);\n\n    if (!foundAnimated) {\n      return uniforms;\n    }\n\n    // If animated uniforms were found, remove them from ordinary uniform list\n    // `Program` class can't (and shouldn't) handle function valued uniforms\n    const staticUniforms = {};\n    for (const uniformName in uniforms) {\n      if (!this.animatedUniforms[uniformName]) {\n        staticUniforms[uniformName] = uniforms[uniformName];\n      }\n    }\n    return staticUniforms;\n  }\n\n  // Timer Queries\n\n  _timerQueryStart() {\n    if (this.timerQueryEnabled === true) {\n      if (!this.timeElapsedQuery) {\n        this.timeElapsedQuery = new Query(this.gl);\n      }\n      if (this.lastQueryReturned) {\n        this.lastQueryReturned = false;\n        this.timeElapsedQuery.beginTimeElapsedQuery();\n      }\n    }\n  }\n\n  _timerQueryEnd() {\n    if (this.timerQueryEnabled === true) {\n      this.timeElapsedQuery.end();\n      // TODO: Skip results if 'gl.getParameter(this.ext.GPU_DISJOINT_EXT)' returns false\n      // should this be incorporated into Query object?\n      if (this.timeElapsedQuery.isResultAvailable()) {\n        this.lastQueryReturned = true;\n        const elapsedTime = this.timeElapsedQuery.getTimerMilliseconds();\n\n        // Update stats (e.g. for seer)\n        this.stats.lastFrameTime = elapsedTime;\n        this.stats.accumulatedFrameTime += elapsedTime;\n        this.stats.profileFrameCount++;\n        this.stats.averageFrameTime =\n          this.stats.accumulatedFrameTime / this.stats.profileFrameCount;\n\n        // Log stats\n        log.log(\n          LOG_DRAW_PRIORITY,\n          `\\\nGPU time ${this.program.id}: ${this.stats.lastFrameTime}ms \\\naverage ${this.stats.averageFrameTime}ms \\\naccumulated: ${this.stats.accumulatedFrameTime}ms \\\ncount: ${this.stats.profileFrameCount}`\n        )();\n      }\n    }\n  }\n\n  _logDrawCallStart(priority) {\n    const logDrawTimeout = priority > 3 ? 0 : LOG_DRAW_TIMEOUT;\n    if (log.priority < priority || Date.now() - this.lastLogTime < logDrawTimeout) {\n      return undefined;\n    }\n\n    this.lastLogTime = Date.now();\n\n    log.group(LOG_DRAW_PRIORITY, `>>> DRAWING MODEL ${this.id}`, {collapsed: log.priority <= 2})();\n\n    return priority;\n  }\n\n  _logDrawCallEnd(priority, vertexArray, uniforms, framebuffer) {\n    // HACK: priority === undefined means logDrawCallStart didn't run\n    if (priority === undefined) {\n      return;\n    }\n\n    const attributeTable = getDebugTableForVertexArray({\n      vertexArray,\n      header: `${this.id} attributes`,\n      attributes: this._attributes\n    });\n\n    const {table: uniformTable, unusedTable, unusedCount} = getDebugTableForUniforms({\n      header: `${this.id} uniforms`,\n      program: this.program,\n      uniforms: Object.assign({}, this.program.uniforms, uniforms)\n    });\n\n    // log missing uniforms\n    const {table: missingTable, count: missingCount} = getDebugTableForUniforms({\n      header: `${this.id} uniforms`,\n      program: this.program,\n      uniforms: Object.assign({}, this.program.uniforms, uniforms),\n      undefinedOnly: true\n    });\n\n    if (missingCount > 0) {\n      log.log('MISSING UNIFORMS', Object.keys(missingTable))();\n      // log.table(priority, missingTable)();\n    }\n    if (unusedCount > 0) {\n      log.log('UNUSED UNIFORMS', Object.keys(unusedTable))();\n      // log.log(priority, 'Unused uniforms ', unusedTable)();\n    }\n\n    const configTable = getDebugTableForProgramConfiguration(this.vertexArray.configuration);\n\n    log.table(priority, attributeTable)();\n\n    log.table(priority, uniformTable)();\n\n    log.table(priority + 1, configTable)();\n\n    logModel(this, uniforms);\n\n    if (framebuffer) {\n      framebuffer.log({priority: LOG_DRAW_PRIORITY, message: `Rendered to ${framebuffer.id}`});\n    }\n\n    log.groupEnd(LOG_DRAW_PRIORITY, `>>> DRAWING MODEL ${this.id}`)();\n  }\n}\n","import GL from '@luma.gl/constants';\nimport {TransformFeedback, Buffer} from '@luma.gl/webgl';\nimport {getBuffersFromGeometry} from './model-utils';\nimport BaseModel from './base-model';\nimport {log, isObjectEmpty, uid, assert} from '../utils';\n\nconst ERR_MODEL_PARAMS = 'Model needs drawMode and vertexCount';\n\nexport default class Model extends BaseModel {\n  constructor(gl, props = {}) {\n    // Deduce a helpful id\n    const {id = uid('model')} = props;\n    super(gl, {...props, id});\n  }\n\n  initialize(props) {\n    super.initialize(props);\n\n    this.drawMode = props.drawMode !== undefined ? props.drawMode : GL.TRIANGLES;\n    this.vertexCount = props.vertexCount || 0;\n\n    // Track buffers created by setGeometry\n    this.geometryBuffers = {};\n\n    // geometry might have set drawMode and vertexCount\n    this.isInstanced = props.isInstanced || props.instanced;\n\n    this._setModelProps(props);\n\n    // TODO - just to unbreak deck.gl 7.0-beta, remove as soon as updated\n    this.geometry = {};\n\n    // assert(program || program instanceof Program);\n    assert(this.drawMode !== undefined && Number.isFinite(this.vertexCount), ERR_MODEL_PARAMS);\n  }\n\n  setProps(props) {\n    super.setProps(props);\n    this._setModelProps(props);\n  }\n\n  delete() {\n    super.delete();\n\n    this._deleteGeometryBuffers();\n  }\n\n  // GETTERS\n\n  getDrawMode() {\n    return this.drawMode;\n  }\n\n  getVertexCount() {\n    return this.vertexCount;\n  }\n\n  getInstanceCount() {\n    return this.instanceCount;\n  }\n\n  getAttributes() {\n    return this.attributes;\n  }\n\n  // SETTERS\n\n  setDrawMode(drawMode) {\n    this.drawMode = drawMode;\n    return this;\n  }\n\n  setVertexCount(vertexCount) {\n    assert(Number.isFinite(vertexCount));\n    this.vertexCount = vertexCount;\n    return this;\n  }\n\n  setInstanceCount(instanceCount) {\n    assert(Number.isFinite(instanceCount));\n    this.instanceCount = instanceCount;\n    return this;\n  }\n\n  setGeometry(geometry) {\n    this.drawMode = geometry.drawMode;\n    this.vertexCount = geometry.getVertexCount();\n\n    this._deleteGeometryBuffers();\n\n    this.geometryBuffers = getBuffersFromGeometry(this.gl, geometry);\n    this.vertexArray.setAttributes(this.geometryBuffers);\n    return this;\n  }\n\n  setAttributes(attributes = {}) {\n    // Avoid setting needsRedraw if no attributes\n    if (isObjectEmpty(attributes)) {\n      return this;\n    }\n\n    const normalizedAttributes = {};\n    for (const name in attributes) {\n      const attribute = attributes[name];\n      // The `getValue` call provides support for deck.gl `Attribute` class\n      // TODO - remove once deck refactoring completes\n      normalizedAttributes[name] = attribute.getValue ? attribute.getValue() : attribute;\n    }\n\n    this.vertexArray.setAttributes(normalizedAttributes);\n    return this;\n  }\n\n  // DRAW CALLS\n\n  draw(options = {}) {\n    return this.drawGeometry(options);\n  }\n\n  // Draw call for transform feedback\n  transform(opts = {}) {\n    const {discard = true, feedbackBuffers, unbindModels = []} = opts;\n\n    let {parameters} = opts;\n\n    if (feedbackBuffers) {\n      this._setFeedbackBuffers(feedbackBuffers);\n    }\n\n    if (discard) {\n      parameters = Object.assign({}, parameters, {[GL.RASTERIZER_DISCARD]: discard});\n    }\n\n    unbindModels.forEach(model => model.vertexArray.unbindBuffers());\n    try {\n      this.draw(Object.assign({}, opts, {parameters}));\n    } finally {\n      unbindModels.forEach(model => model.vertexArray.bindBuffers());\n    }\n\n    return this;\n  }\n\n  // DEPRECATED METHODS\n\n  render(uniforms = {}) {\n    log.warn('Model.render() is deprecated. Use Model.setUniforms() and Model.draw()')();\n    return this.setUniforms(uniforms).draw();\n  }\n\n  // PRIVATE METHODS\n\n  _setModelProps(props) {\n    // params\n    // if ('drawMode' in props) {\n    //   this.drawMode = getDrawMode(props.drawMode);\n    // }\n    // if ('vertexCount' in props) {\n    //   this.vertexCount = props.vertexCount;\n    // }\n    if ('instanceCount' in props) {\n      this.instanceCount = props.instanceCount;\n    }\n    if ('geometry' in props) {\n      this.setGeometry(props.geometry);\n    }\n\n    // webgl settings\n    if ('attributes' in props) {\n      this.setAttributes(props.attributes);\n    }\n    if ('_feedbackBuffers' in props) {\n      this._setFeedbackBuffers(props._feedbackBuffers);\n    }\n  }\n\n  _deleteGeometryBuffers() {\n    for (const name in this.geometryBuffers) {\n      // Buffer is raw value (for indices) or first element of [buffer, accessor] pair\n      const buffer = this.geometryBuffers[name][0] || this.geometryBuffers[name];\n      if (buffer instanceof Buffer) {\n        buffer.delete();\n      }\n    }\n  }\n\n  // Updates (evaluates) all function valued uniforms based on a new set of animationProps\n  // experimental\n  _setAnimationProps(animationProps) {\n    if (this.animated) {\n      assert(animationProps, 'Model.draw(): animated uniforms but no animationProps');\n      const animatedUniforms = this._evaluateAnimateUniforms(animationProps);\n      this.program.setUniforms(animatedUniforms);\n    }\n  }\n\n  // Transform Feedback\n\n  _setFeedbackBuffers(feedbackBuffers = {}) {\n    // Avoid setting needsRedraw if no feedbackBuffers\n    if (isObjectEmpty(feedbackBuffers)) {\n      return this;\n    }\n\n    const {gl} = this.program;\n    this.transformFeedback =\n      this.transformFeedback ||\n      new TransformFeedback(gl, {\n        program: this.program\n      });\n\n    this.transformFeedback.setBuffers(feedbackBuffers);\n    return this;\n  }\n}\n","// Transpiles shader source code to target GLSL version\n// Note: We always run transpiler even if same version e.g. 3.00 => 3.00\n// RFC: https://github.com/uber/luma.gl/blob/7.0-release/dev-docs/RFCs/v6.0/portable-glsl-300-rfc.md\nexport default function transpileShader(source, targetGLSLVersion, isVertex) {\n  switch (targetGLSLVersion) {\n    case 300:\n      return isVertex ? convertVertexShaderTo300(source) : convertFragmentShaderTo300(source);\n    case 100:\n      return isVertex ? convertVertexShaderTo100(source) : convertFragmentShaderTo100(source);\n    default:\n      throw new Error(`unknown GLSL version ${targetGLSLVersion}`);\n  }\n}\n\nfunction convertVertexShaderTo300(source) {\n  return source\n    .replace(/attribute\\s+/g, 'in ')\n    .replace(/varying\\s+/g, 'out ')\n    .replace(/texture2D\\(/g, 'texture(')\n    .replace(/textureCube\\(+/g, 'texture(')\n    .replace(/texture2DLodEXT\\(/g, 'textureLod(')\n    .replace(/textureCubeLodEXT\\(/g, 'textureLod(');\n}\n\nfunction convertFragmentShaderTo300(source) {\n  return source\n    .replace(/varying\\s+/g, 'in ')\n    .replace(/texture2D\\(/g, 'texture(')\n    .replace(/textureCube\\(/g, 'texture(')\n    .replace(/texture2DLodEXT\\(/g, 'textureLod(')\n    .replace(/textureCubeLodEXT\\(/g, 'textureLod(');\n\n  // Deal with fragColor\n  // .replace(/gl_fragColor/g, 'fragColor ');\n}\n\nfunction convertVertexShaderTo100(source) {\n  // /gm - treats each line as a string, so that ^ matches after newlines\n  return source\n    .replace(/^in\\s+/gm, 'attribute ')\n    .replace(/^out\\s+/gm, 'varying ')\n    .replace(/texture\\(/g, 'texture2D(');\n}\n\nfunction convertFragmentShaderTo100(source) {\n  // /gm - treats each line as a string, so that ^ matches after newlines\n  return source.replace(/^in\\s+/gm, 'varying ').replace(/texture\\(/g, 'texture2D(');\n\n  // Deal with fragColor\n  // .replace(/^out\\s+/g, 'varying ')\n}\n","const TYPE_DEFINITIONS = {\n  number: {\n    validate(value, propType) {\n      return (\n        Number.isFinite(value) &&\n        (!('max' in propType) || value <= propType.max) &&\n        (!('min' in propType) || value >= propType.min)\n      );\n    }\n  },\n  array: {\n    validate(value, propType) {\n      return Array.isArray(value) || ArrayBuffer.isView(value);\n    }\n  }\n};\n\nexport function parsePropTypes(propDefs) {\n  const propTypes = {};\n  for (const propName in propDefs) {\n    const propDef = propDefs[propName];\n    const propType = parsePropType(propDef);\n    propTypes[propName] = propType;\n  }\n  return propTypes;\n}\n\n// Parses one property definition entry. Either contains:\n// * a valid prop type object ({type, ...})\n// * or just a default value, in which case type and name inference is used\nfunction parsePropType(propDef) {\n  let type = getTypeOf(propDef);\n  if (type === 'object') {\n    if (!propDef) {\n      return {type: 'object', value: null};\n    }\n    if ('type' in propDef) {\n      return Object.assign({}, propDef, TYPE_DEFINITIONS[propDef.type]);\n    }\n    if (!('value' in propDef)) {\n      // If no type and value this object is likely the value\n      return {type: 'object', value: propDef};\n    }\n    type = getTypeOf(propDef.value);\n    return Object.assign({type}, propDef, TYPE_DEFINITIONS[type]);\n  }\n  return Object.assign({type, value: propDef}, TYPE_DEFINITIONS[type]);\n}\n\n// improved version of javascript typeof that can distinguish arrays and null values\nfunction getTypeOf(value) {\n  if (Array.isArray(value) || ArrayBuffer.isView(value)) {\n    return 'array';\n  }\n  return typeof value;\n}\n","import transpileShader from './transpile-shader';\nimport {assert} from '../utils';\nimport {parsePropTypes} from './filters/prop-types';\n\nconst VERTEX_SHADER = 'vs';\nconst FRAGMENT_SHADER = 'fs';\n\nexport default class ShaderModule {\n  constructor({\n    name,\n    vs,\n    fs,\n    dependencies = [],\n    uniforms,\n    getUniforms,\n    deprecations = [],\n    defines = {},\n    // DEPRECATED\n    vertexShader,\n    fragmentShader\n  }) {\n    assert(typeof name === 'string');\n    this.name = name;\n    this.vs = vs || vertexShader;\n    this.fs = fs || fragmentShader;\n    this.getModuleUniforms = getUniforms;\n    this.dependencies = dependencies;\n    this.deprecations = this._parseDeprecationDefinitions(deprecations);\n    this.defines = defines;\n\n    if (uniforms) {\n      this.uniforms = parsePropTypes(uniforms);\n    }\n  }\n\n  // Extracts the source code chunk for the specified shader type from the named shader module\n  getModuleSource(type, targetGLSLVersion) {\n    let moduleSource;\n    switch (type) {\n      case VERTEX_SHADER:\n        moduleSource = transpileShader(this.vs || '', targetGLSLVersion, true);\n        break;\n      case FRAGMENT_SHADER:\n        moduleSource = transpileShader(this.fs || '', targetGLSLVersion, false);\n        break;\n      default:\n        assert(false);\n    }\n\n    return `\\\n#define MODULE_${this.name.toUpperCase()}\n${moduleSource}\\\n// END MODULE_${this.name}\n\n`;\n  }\n\n  getUniforms(opts, uniforms) {\n    if (this.getModuleUniforms) {\n      return this.getModuleUniforms(opts, uniforms);\n    }\n    // Build uniforms from the uniforms array\n    if (this.uniforms) {\n      return this._defaultGetUniforms(opts);\n    }\n    return {};\n  }\n\n  getDefines() {\n    return this.defines;\n  }\n\n  // Warn about deprecated uniforms or functions\n  checkDeprecations(shaderSource, log) {\n    this.deprecations.forEach(def => {\n      if (def.regex.test(shaderSource)) {\n        if (def.deprecated) {\n          log.deprecated(def.old, def.new)();\n        } else {\n          log.removed(def.old, def.new)();\n        }\n      }\n    });\n  }\n\n  _parseDeprecationDefinitions(deprecations) {\n    deprecations.forEach(def => {\n      switch (def.type) {\n        case 'function':\n          def.regex = new RegExp(`\\\\b${def.old}\\\\(`);\n          break;\n        default:\n          def.regex = new RegExp(`${def.type} ${def.old};`);\n      }\n    });\n\n    return deprecations;\n  }\n\n  _defaultGetUniforms(opts = {}) {\n    const uniforms = {};\n    const propTypes = this.uniforms;\n\n    for (const key in propTypes) {\n      const propDef = propTypes[key];\n      if (key in opts && !propDef.private) {\n        if (propDef.validate) {\n          assert(propDef.validate(opts[key], propDef), `${this.name}: invalid ${key}`);\n        }\n        uniforms[key] = opts[key];\n      } else {\n        uniforms[key] = propDef.value;\n      }\n    }\n\n    return uniforms;\n  }\n}\n\n// This utility mutates the original module\n// Keeping for backward compatibility\n// TODO - remove in v8\nexport function normalizeShaderModule(module) {\n  if (!module.normalized) {\n    module.normalized = true;\n    if (module.uniforms && !module.getUniforms) {\n      const shaderModule = new ShaderModule(module);\n      module.getUniforms = shaderModule.getUniforms.bind(shaderModule);\n    }\n  }\n  return module;\n}\n","import {MODULE_INJECTORS_VS, MODULE_INJECTORS_FS} from '../modules/module-injectors';\nimport {VERTEX_SHADER, FRAGMENT_SHADER} from './constants';\nimport {assert} from '../utils';\n\n// TODO - experimental\nconst MODULE_INJECTORS = {\n  [VERTEX_SHADER]: MODULE_INJECTORS_VS,\n  [FRAGMENT_SHADER]: MODULE_INJECTORS_FS\n};\n\nexport const DECLARATION_INJECT_MARKER = '__LUMA_INJECT_DECLARATIONS__'; // Uniform/attribute declarations\n\nconst REGEX_START_OF_MAIN = /void main\\s*\\([^)]*\\)\\s*\\{\\n?/; // Beginning of main\nconst REGEX_END_OF_MAIN = /}\\n?[^{}]*$/; // End of main, assumes main is last function\nconst fragments = [];\n\n// A minimal shader injection/templating system.\n// RFC: https://github.com/uber/luma.gl/blob/7.0-release/dev-docs/RFCs/v6.0/shader-injection-rfc.md\n/* eslint-disable complexity */\nexport default function injectShader(source, type, inject, injectStandardStubs) {\n  const isVertex = type === VERTEX_SHADER;\n\n  for (const key in inject) {\n    const fragmentData = inject[key];\n    fragmentData.sort((a, b) => a.order - b.order);\n    fragments.length = fragmentData.length;\n    for (let i = 0, len = fragmentData.length; i < len; ++i) {\n      fragments[i] = fragmentData[i].injection;\n    }\n    const fragmentString = `${fragments.join('\\n')}\\n`;\n    switch (key) {\n      // declarations are injected before the main function\n      case 'vs:#decl':\n        if (isVertex) {\n          source = source.replace(DECLARATION_INJECT_MARKER, fragmentString);\n        }\n        break;\n      // main code is injected at the end of main function\n      case 'vs:#main-start':\n        if (isVertex) {\n          source = source.replace(REGEX_START_OF_MAIN, match => match + fragmentString);\n        }\n        break;\n      case 'vs:#main-end':\n        if (isVertex) {\n          source = source.replace(REGEX_END_OF_MAIN, match => fragmentString + match);\n        }\n        break;\n      case 'fs:#decl':\n        if (!isVertex) {\n          source = source.replace(DECLARATION_INJECT_MARKER, fragmentString);\n        }\n        break;\n      case 'fs:#main-start':\n        if (!isVertex) {\n          source = source.replace(REGEX_START_OF_MAIN, match => match + fragmentString);\n        }\n        break;\n      case 'fs:#main-end':\n        if (!isVertex) {\n          source = source.replace(REGEX_END_OF_MAIN, match => fragmentString + match);\n        }\n        break;\n\n      default:\n        // TODO(Tarek): I think this usage should be deprecated.\n\n        // inject code after key, leaving key in place\n        source = source.replace(key, match => match + fragmentString);\n    }\n  }\n\n  // Remove if it hasn't already been replaced\n  source = source.replace(DECLARATION_INJECT_MARKER, '');\n\n  // Finally, if requested, insert an automatic module injector chunk\n  if (injectStandardStubs) {\n    source = source.replace(/\\}\\s*$/, match => match + MODULE_INJECTORS[type]);\n  }\n\n  return source;\n}\n\n/* eslint-enable complexity */\n\n// Takes an array of inject objects and combines them into one\nexport function combineInjects(injects) {\n  const result = {};\n  assert(Array.isArray(injects) && injects.length > 1);\n  injects.forEach(inject => {\n    for (const key in inject) {\n      result[key] = result[key] ? `${result[key]}\\n${inject[key]}` : inject[key];\n    }\n  });\n  return result;\n}\n","export const MODULE_INJECTORS_VS = `\\\n#ifdef MODULE_LOGDEPTH\n  logdepth_adjustPosition(gl_Position);\n#endif\n`;\n\nexport const MODULE_INJECTORS_FS = `\\\n#ifdef MODULE_MATERIAL\n  gl_FragColor = material_filterColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_LIGHTING\n  gl_FragColor = lighting_filterColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_FOG\n  gl_FragColor = fog_filterColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_PICKING\n  gl_FragColor = picking_filterHighlightColor(gl_FragColor);\n  gl_FragColor = picking_filterPickingColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_LOGDEPTH\n  logdepth_setFragDepth();\n#endif\n`;\n","export const VERTEX_SHADER = 'vs';\nexport const FRAGMENT_SHADER = 'fs';\n","// shadertools exports\n\n// DEFAULT SHADERS\n// A set of base shaders that leverage the shader module system,\n// dynamically enabling features depending on which modules are included\nimport MODULAR_VS from './shaders/modular-vertex.glsl';\nimport MODULAR_FS from './shaders/modular-fragment.glsl';\n\n// DOCUMENTED APIS\nexport {\n  registerShaderModules,\n  setDefaultShaderModules,\n  getDefaultShaderModules\n} from './lib/resolve-modules';\nexport {assembleShaders, createShaderHook, createModuleInjection} from './lib/assemble-shaders';\n\n// HELPERS\nexport {combineInjects} from './lib/inject-shader';\nexport {normalizeShaderModule} from './lib/shader-module';\n\n// UTILS\nexport {\n  getQualifierDetails,\n  getPassthroughFS,\n  typeToChannelSuffix,\n  typeToChannelCount,\n  convertToVec4\n} from './utils/shader-utils';\n\n// SHADER MODULES\nexport * from './modules';\n\nexport const MODULAR_SHADERS = {\n  vs: MODULAR_VS,\n  fs: MODULAR_FS,\n  uniforms: {}\n};\n","export default `\\\n#define SHADER_NAME luma_modular_vertex\n\n// object attributes\nattribute vec3 positions;\nattribute vec3 normals;\nattribute vec4 colors;\nattribute vec2 texCoords;\nattribute vec3 pickingColors;\n\nvoid main(void) {\n\n  // Set up position\n#ifdef MODULE_GEOMETRY\n  geometry_setPosition(positions);\n  geometry_setNormal(normals);\n#endif\n\n#ifdef MODULE_PROJECT\n  project_setPositionAndNormal_Model(positions, normals);\n  gl_Position = project_model_to_clipspace(positions);\n#endif\n\n  // Set up depth\n#ifdef MODULE_LOGDEPTH\n  logdepth_adjustPosition(gl_Position);\n#endif\n\n#ifdef MODULE_DIFFUSE\n  diffuse_setTextureCoordinate(texCoords);\n#endif\n\n  // Set up color calculations\n#ifdef MODULE_MATERIAL\n  material_setDiffuseColor(colors);\n  material_setDiffuseTextureCoordinates(texCoords);\n#endif\n\n#ifdef MODULE_LIGHTING\n  lighting_setPositionAndNormal(positions, normals);\n  lighting_apply_light(positions);\n  lighting_apply_reflection(positions);\n#endif\n\n#ifdef MODULE_PICKING\n  picking_setPickingColor(pickingColors);\n#endif\n\n}\n`;\n","export default `\\\n#define SHADER_NAME luma-modular-fragment\n\nprecision highp float;\n\n// varyings\nvarying vec4 vColor;\n\nvoid main(){\n  gl_FragColor = vec4(1., 0., 1., 1.);\n\n#ifdef MODULE_DIFFUSE\n  gl_FragColor = diffuse_filterColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_MATERIAL\n  gl_FragColor = material_filterColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_LIGHTING\n  gl_FragColor = lighting_filterColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_FOG\n  gl_FragColor = fog_filterColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_PICKING\n  gl_FragColor = picking_filterHighlightColor(gl_FragColor);\n  gl_FragColor = picking_filterPickingColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_LOGDEPTH\n  logdepth_setFragDepth(gl_Position);\n#endif\n}\n`;\n","import {Vector3, Matrix4} from 'math.gl';\nimport {assert, uid} from '../../utils';\n\nexport default class ScenegraphNode {\n  constructor(props = {}) {\n    const {id} = props;\n\n    this.id = id || uid(this.constructor.name);\n\n    this.display = true; // whether to display the object at all\n    this.position = new Vector3();\n    this.rotation = new Vector3();\n    this.scale = new Vector3(1, 1, 1);\n    this.matrix = new Matrix4();\n    this.userData = {};\n\n    this.props = {};\n    this._setScenegraphNodeProps(props);\n  }\n\n  delete() {}\n\n  setProps(props) {\n    this._setScenegraphNodeProps(props);\n    return this;\n  }\n\n  toString() {\n    return `{type: ScenegraphNode, id: ${this.id})}`;\n  }\n\n  setPosition(position) {\n    assert(position.length === 3, 'setPosition requires vector argument');\n    this.position = position;\n    return this;\n  }\n\n  setRotation(rotation) {\n    assert(rotation.length === 3, 'setRotation requires vector argument');\n    this.rotation = rotation;\n    return this;\n  }\n\n  setScale(scale) {\n    assert(scale.length === 3, 'setScale requires vector argument');\n    this.scale = scale;\n    return this;\n  }\n\n  setMatrix(matrix, copyMatrix = true) {\n    if (copyMatrix) {\n      this.matrix.copy(matrix);\n    } else {\n      this.matrix = matrix;\n    }\n  }\n\n  setMatrixComponents({position, rotation, scale, update = true}) {\n    if (position) {\n      this.setPosition(position);\n    }\n    if (rotation) {\n      this.setRotation(rotation);\n    }\n    if (scale) {\n      this.setScale(scale);\n    }\n    if (update) {\n      this.updateMatrix();\n    }\n    return this;\n  }\n\n  updateMatrix() {\n    const pos = this.position;\n    const rot = this.rotation;\n    const scale = this.scale;\n\n    this.matrix.identity();\n    this.matrix.translate(pos);\n    this.matrix.rotateXYZ(rot);\n    this.matrix.scale(scale);\n    return this;\n  }\n\n  update({position, rotation, scale} = {}) {\n    if (position) {\n      this.setPosition(position);\n    }\n    if (rotation) {\n      this.setRotation(rotation);\n    }\n    if (scale) {\n      this.setScale(scale);\n    }\n    this.updateMatrix();\n    return this;\n  }\n\n  getCoordinateUniforms(viewMatrix, modelMatrix) {\n    // TODO - solve multiple class problem\n    // assert(viewMatrix instanceof Matrix4);\n    assert(viewMatrix);\n    modelMatrix = modelMatrix || this.matrix;\n    const worldMatrix = new Matrix4(viewMatrix).multiplyRight(modelMatrix);\n    const worldInverse = worldMatrix.invert();\n    const worldInverseTranspose = worldInverse.transpose();\n\n    return {\n      viewMatrix,\n      modelMatrix,\n      objectMatrix: modelMatrix,\n      worldMatrix,\n      worldInverseMatrix: worldInverse,\n      worldInverseTransposeMatrix: worldInverseTranspose\n    };\n  }\n\n  // TODO - copied code, not yet vetted\n  /*\n  transform() {\n    if (!this.parent) {\n      this.endPosition.set(this.position);\n      this.endRotation.set(this.rotation);\n      this.endScale.set(this.scale);\n    } else {\n      const parent = this.parent;\n      this.endPosition.set(this.position.add(parent.endPosition));\n      this.endRotation.set(this.rotation.add(parent.endRotation));\n      this.endScale.set(this.scale.add(parent.endScale));\n    }\n\n    const ch = this.children;\n    for (let i = 0; i < ch.length; ++i) {\n      ch[i].transform();\n    }\n\n    return this;\n  }\n  */\n\n  _setScenegraphNodeProps(props) {\n    if ('display' in props) {\n      this.display = props.display;\n    }\n\n    if ('position' in props) {\n      this.setPosition(props.position);\n    }\n    if ('rotation' in props) {\n      this.setRotation(props.rotation);\n    }\n    if ('scale' in props) {\n      this.setScale(props.scale);\n    }\n\n    // Matrix overwrites other props\n    if ('matrix' in props) {\n      this.setMatrix(props.matrix);\n    }\n\n    Object.assign(this.props, props);\n  }\n}\n","import Model from '../../lib/model';\nimport ScenegraphNode from './scenegraph-node';\n\nexport default class ModelNode extends ScenegraphNode {\n  constructor(gl, props = {}) {\n    super(props);\n\n    // pverride callbacks to make sure we call them with this\n    this.onBeforeRender = null;\n    this.AfterRender = null;\n\n    // Create new Model or used supplied Model\n    if (gl instanceof Model) {\n      this.model = gl;\n      this._setModelNodeProps(props);\n    } else {\n      this.model = new Model(gl, props);\n    }\n\n    this.managedResources = props.managedResources || [];\n  }\n\n  setProps(props) {\n    super.setProps(props);\n    this._setModelNodeProps(props);\n    return this;\n  }\n\n  delete() {\n    if (this.model) {\n      this.model.delete();\n      this.model = null;\n    }\n\n    this.managedResources.forEach(resource => resource.delete());\n    this.managedResources = [];\n  }\n\n  // Forward node methods\n  draw(...args) {\n    // Return value indicates if something was actually drawn\n    return this.model.draw(...args);\n  }\n\n  setUniforms(...args) {\n    this.model.setUniforms(...args);\n    return this;\n  }\n\n  setAttributes(...args) {\n    this.model.setAttributes(...args);\n    return this;\n  }\n\n  updateModuleSettings(...args) {\n    this.model.updateModuleSettings(...args);\n    return this;\n  }\n\n  // PRIVATE\n\n  _setModelNodeProps(props) {\n    this.model.setProps(props);\n  }\n}\n","// Recommendation is to ignore message but current test suite checks agains the\n// message so keep it for now.\nexport default function assert(condition, message) {\n  if (!condition) {\n    throw new Error(message || 'shadertools: assertion failed.');\n  }\n}\n","import GL from '@luma.gl/constants';\nimport Resource from './resource';\nimport Buffer from './buffer';\nimport {isWebGL2, assertWebGL2Context} from '../webgl-utils';\nimport {log, isObjectEmpty} from '../utils';\n\n// NOTE: The `bindOnUse` flag is a major workaround:\n// See https://github.com/KhronosGroup/WebGL/issues/2346\n\nexport default class TransformFeedback extends Resource {\n  static isSupported(gl) {\n    return isWebGL2(gl);\n  }\n\n  constructor(gl, props = {}) {\n    assertWebGL2Context(gl);\n    super(gl, props);\n\n    this.initialize(props);\n    this.stubRemovedMethods('TransformFeedback', 'v6.0', ['pause', 'resume']);\n    Object.seal(this);\n  }\n\n  initialize(props = {}) {\n    this.buffers = {};\n    this.unused = {};\n    this.configuration = null;\n    this.bindOnUse = true;\n\n    // Unbind any currently bound buffers\n    if (!isObjectEmpty(this.buffers)) {\n      this.bind(() => this._unbindBuffers());\n    }\n\n    this.setProps(props);\n    return this;\n  }\n\n  setProps(props) {\n    if ('program' in props) {\n      this.configuration = props.program && props.program.configuration;\n    }\n    if ('configuration' in props) {\n      this.configuration = props.configuration;\n    }\n    if ('bindOnUse' in props) {\n      props = props.bindOnUse;\n    }\n    if ('buffers' in props) {\n      this.setBuffers(props.buffers);\n    }\n  }\n\n  setBuffers(buffers = {}) {\n    this.bind(() => {\n      for (const bufferName in buffers) {\n        this.setBuffer(bufferName, buffers[bufferName]);\n      }\n    });\n    return this;\n  }\n\n  setBuffer(locationOrName, bufferOrParams) {\n    const location = this._getVaryingIndex(locationOrName);\n    const {buffer, byteSize, byteOffset} = this._getBufferParams(bufferOrParams);\n\n    if (location < 0) {\n      this.unused[locationOrName] = buffer;\n      log.warn(() => `${this.id} unused varying buffer ${locationOrName}`)();\n      return this;\n    }\n\n    this.buffers[location] = bufferOrParams;\n\n    // Need to avoid chrome bug where buffer that is already bound to a different target\n    // cannot be bound to 'TRANSFORM_FEEDBACK_BUFFER' target.\n    if (!this.bindOnUse) {\n      this._bindBuffer(location, buffer, byteOffset, byteSize);\n    }\n\n    return this;\n  }\n\n  begin(primitiveMode = GL.POINTS) {\n    this.gl.bindTransformFeedback(GL.TRANSFORM_FEEDBACK, this.handle);\n    this._bindBuffers();\n    this.gl.beginTransformFeedback(primitiveMode);\n    return this;\n  }\n\n  end() {\n    this.gl.endTransformFeedback();\n    this._unbindBuffers();\n    this.gl.bindTransformFeedback(GL.TRANSFORM_FEEDBACK, null);\n    return this;\n  }\n\n  // PRIVATE METHODS\n\n  _getBufferParams(bufferOrParams) {\n    let byteOffset;\n    let byteSize;\n    let buffer;\n    if (bufferOrParams instanceof Buffer === false) {\n      buffer = bufferOrParams.buffer;\n      byteSize = bufferOrParams.byteSize;\n      byteOffset = bufferOrParams.byteOffset;\n    } else {\n      buffer = bufferOrParams;\n    }\n    // to use bindBufferRange, either offset or size must be specified, use default value for the other.\n    if (byteOffset !== undefined || byteSize !== undefined) {\n      byteOffset = byteOffset || 0;\n      byteSize = byteSize || buffer.byteLength - byteOffset;\n    }\n    return {buffer, byteOffset, byteSize};\n  }\n\n  _getVaryingInfo(locationOrName) {\n    return this.configuration && this.configuration.getVaryingInfo(locationOrName);\n  }\n\n  _getVaryingIndex(locationOrName) {\n    if (this.configuration) {\n      return this.configuration.getVaryingInfo(locationOrName).location;\n    }\n    const location = Number(locationOrName);\n    return Number.isFinite(location) ? location : -1;\n  }\n\n  // Need to avoid chrome bug where buffer that is already bound to a different target\n  // cannot be bound to 'TRANSFORM_FEEDBACK_BUFFER' target.\n  _bindBuffers() {\n    if (this.bindOnUse) {\n      for (const bufferIndex in this.buffers) {\n        const {buffer, byteSize, byteOffset} = this._getBufferParams(this.buffers[bufferIndex]);\n        this._bindBuffer(bufferIndex, buffer, byteOffset, byteSize);\n      }\n    }\n  }\n\n  _unbindBuffers() {\n    if (this.bindOnUse) {\n      for (const bufferIndex in this.buffers) {\n        this._bindBuffer(bufferIndex, null);\n      }\n    }\n  }\n\n  _bindBuffer(index, buffer, byteOffset = 0, byteSize) {\n    const handle = buffer && buffer.handle;\n    if (!handle || byteSize === undefined) {\n      this.gl.bindBufferBase(GL.TRANSFORM_FEEDBACK_BUFFER, index, handle);\n    } else {\n      this.gl.bindBufferRange(GL.TRANSFORM_FEEDBACK_BUFFER, index, handle, byteOffset, byteSize);\n    }\n    return this;\n  }\n\n  // RESOURCE METHODS\n\n  _createHandle() {\n    return this.gl.createTransformFeedback();\n  }\n\n  _deleteHandle() {\n    this.gl.deleteTransformFeedback(this.handle);\n  }\n\n  _bindHandle(handle) {\n    this.gl.bindTransformFeedback(GL.TRANSFORM_FEEDBACK, this.handle);\n  }\n}\n"],"sourceRoot":""}