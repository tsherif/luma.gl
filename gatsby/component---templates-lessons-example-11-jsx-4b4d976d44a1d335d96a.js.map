{"version":3,"sources":["webpack:///../examples/lessons/11/app.js","webpack:///./templates/lessons/example-11.jsx","webpack:///../modules/core/src/geometry/geometry.js","webpack:///../modules/shadertools/src/lib/shader-module-registry.js","webpack:///../modules/shadertools/src/lib/resolve-modules.js","webpack:///../modules/shadertools/src/utils/webgl-info.js","webpack:///../modules/shadertools/src/utils/is-old-ie.js","webpack:///../modules/shadertools/src/lib/platform-defines.js","webpack:///../modules/shadertools/src/lib/assemble-shaders.js","webpack:///../modules/core/src/lib/model-utils.js","webpack:///../modules/webgl/src/utils/format-value.js","webpack:///../modules/webgl/src/debug/debug-vertex-array.js","webpack:///../modules/webgl/src/debug/debug-uniforms.js","webpack:///../modules/webgl/src/debug/debug-program-configuration.js","webpack:///../modules/core/src/debug/seer-integration.js","webpack:///../modules/core/src/lib/base-model.js","webpack:///../modules/core/src/lib/model.js","webpack:///../modules/shadertools/src/lib/transpile-shader.js","webpack:///../modules/shadertools/src/lib/filters/prop-types.js","webpack:///../modules/shadertools/src/lib/shader-module.js","webpack:///../modules/shadertools/src/lib/inject-shader.js","webpack:///../modules/shadertools/src/modules/module-injectors.js","webpack:///../modules/shadertools/src/lib/constants.js","webpack:///../modules/shadertools/src/index.js","webpack:///../modules/shadertools/src/shaders/modular-vertex.glsl.js","webpack:///../modules/shadertools/src/shaders/modular-fragment.glsl.js","webpack:///../modules/shadertools/src/utils/assert.js","webpack:///../modules/core/src/geometries/sphere-geometry.js","webpack:///../modules/webgl/src/classes/transform-feedback.js"],"names":["appState","mouseDown","lastMouseX","lastMouseY","moonRotationMatrix","matrix4","AppAnimationLoop","getInfo","onInitialize","canvas","_ref","gl","this","eventManager","esm","addMouseHandler","panstart","event","panmove","undefined","radiansX","radiansY","newMatrix","rotateX","rotateY","panend","e","setParameters","clearColor","clearDepth","depthTest","moon","model","fs","vs","geometry","sphere_geometry","nlat","nlong","radius","uniforms","uSampler","texture_2d","onRender","_ref2","aspect","tick","GL","uMMatrix","multiplyRight","uVMatrix","lookAt","eye","center","up","_getControlValues","getElementValue","id","defaultValue","element","document","parseFloat","value","lighting","checked","ambientColor","vector3","lightingDirection","directionalColor","getControlValues","uUseLighting","uAmbientColor","uLightingDirection","uDirectionalColor","setUniforms","uPMatrix","perspective","fov","Math","PI","near","far","draw","onFinalize","destroy","AnimationLoop","window","website","app_AppAnimationLoop","animationLoop","Example","render","react_default","a","createElement","animation_loop_example_page","exampleConfig","props","pageContext","React","Component","DRAW_MODE","POINTS","LINES","LINE_LOOP","LINE_STRIP","TRIANGLES","TRIANGLE_STRIP","TRIANGLE_FAN","Geometry","_props","_props$id","uid","_props$drawMode","drawMode","_props$attributes","attributes","_props$indices","indices","_props$vertexCount","vertexCount","userData","_setAttributes","_calculateVertexCount","getVertexCount","getAttributes","Object","assign","_print","attributeName","ArrayBuffer","isView","size","attribute","assert","isIndexed","length","Infinity","constant","Number","ShaderModuleRegistry","shaderModules","defaultShaderModules","setDefaultShaderModules","resolveModules","modules","getDefaultShaderModules","registerShaderModules","_ref$ignoreMultipleRe","_temp","ignoreMultipleRegistrations","_iterator","shaderModuleList","_isArray","Array","isArray","_i","Symbol","iterator","next","done","shaderModule","_registerShaderModule","getShaderModule","moduleOrName","shader_module","module","_this","map","name","Error","shaderModuleRegistry","shader_module_registry_ShaderModuleRegistry","getShaderDependencies","resolve_modules_getShaderModule","moduleMap","moduleDepth","getDependencyGraph","level","keys","sort","b","_ref3","_iterator2","_isArray2","_i2","_ref4","dependencies","GL_VENDOR","GL_RENDERER","GL_VERSION","GL_SHADING_LANGUAGE_VERSION","WEBGL_FEATURES","GLSL_FRAG_DATA","GLSL_FRAG_DEPTH","GLSL_DERIVATIVES","GLSL_TEXTURE_LOD","FEATURES","key","compiledGlslExtensions","canCompileGLGSExtension","cap","opts","feature","navigator","userAgent","isMSIE","isTrident","isOldIE","source","shader","VERTEX_SHADER","canCompile","COMPILE_STATUS","getFeature","extensionName","Boolean","isWebGL2","hasFeatures","features","every","getPlatformShaderDefines","info","vendor","UNMASKED_VENDOR_WEBGL","renderer","UNMASKED_RENDERER_WEBGL","gpuVendor","identifyGPUVendor","version","shadingLanguageVersion","getContextInfo","debugInfo","toLowerCase","INJECT_SHADER_DECLARATIONS","inject_shader","SHADER_TYPE","_SHADER_TYPE","constants","HOOK_FUNCTIONS","_HOOK_FUNCTIONS","MODULE_INJECTIONS","FRAGMENT_SHADER_PROLOGUE","createShaderHook","hook","_hook$split","stage","signature","createModuleInjection","moduleName","injection","_opts$order","order","shaderStage","assembleShaders","assembleShader","type","getUniforms","assembleGetUniforms","assembleModuleMap","_ref$defines","defines","_ref$inject","inject","_ref$prologue","prologue","log","isVertex","sourceLines","glslVersion","versionLine","coreSource","allDefines","assembledSource","_ref6","getShaderName","_ref5","toUpperCase","getShaderType","isFragment","versionDefines","behavior","getVersionDefines","count","sourceText","define","getApplicationDefines","injectStandardStubs","hookInjections","mainInjections","injections","_key","result","hookFunctions","hookName","hookFunction","header","_iterator4","_isArray4","_i4","_ref7","footer","getHookFunctions","injectShader","moduleUniforms","_iterator3","_isArray3","_i3","GLTF_TO_LUMA_ATTRIBUTE_MAP","POSITION","NORMAL","COLOR_0","TEXCOORD_0","TEXCOORD_1","TEXCOORD_2","mapAttributeName","options","_ref$attributeMap","attributeMap","inferAttributeAccessor","category","formatValue","v","_opts$isInteger","isInteger","_opts$maxElts","maxElts","_opts$size","string","i","formatArrayValue","String","decimal","getDebugTableRow","vertexArray","accessor","marker","verts","bytes","classes_buffer","format","buffer","_buffer$getDebugData","getDebugData","data","modified","getKey","getGLSLDeclaration","typeAndName","getCompositeGLType","getDebugTableForUniforms","_ref$header","program","_ref$undefinedOnly","undefinedOnly","uniformLocations","_uniformSetters","table","uniformNames","uniformName","addUniformToTable","_uniformName","_uniformName2","unusedCount","unusedTable","_unusedTable$uniformN","uniform","Type","_table$uniformName","isDefined","isUniformDefined","debug_program_configuration_getGLSLDeclaration","attributeInfo","_attributeInfo$access","models","recursiveSet","obj","path","overrides","Map","seer","payload","itemKey","valuePath","__SEER_INITIALIZED__","setOverride","BaseModel","isWebGL","lastLogTime","initialize","_setBaseModelProps","_createProgram","vertex_array","needsRedraw","_attributes","animatedUniforms","animated","timerQueryEnabled","timeElapsedQuery","lastQueryReturned","stats","accumulatedFrameTime","averageFrameTime","profileFrameCount","pickable","getModuleUniforms","moduleSettings","setProps","delete","removeModel","isAnimated","getProgram","overs","getOverrides","_extractAnimatedUniforms","updateModuleSettings","drawGeometry","_opts","_opts$moduleSettings","framebuffer","_opts$uniforms","_opts$attributes","_opts$transformFeedba","transformFeedback","_opts$parameters","parameters","_opts$vertexArray","animationProps","setAttributes","_refreshAnimationProps","logPriority","_logDrawCallStart","drawParams","getDrawParams","isInstanced","indexType","indexOffset","instanceCount","noop","_this$props","_this$props$onBeforeR","onBeforeRender","_this$props$onAfterRe","onAfterRender","_timerQueryStart","didDraw","getDrawMode","offset","_timerQueryEnd","_logDrawCallEnd","Query","_setAnimationProps","_animationProps","_animationLoop","_ref$vs","_ref$fs","_ref$modules","_ref$shaderCache","shaderCache","_ref$varyings","varyings","_ref$bufferMode","bufferMode","SEPARATE_ATTRIBS","_ref$program","x","MODULAR_SHADERS","assembleResult","classes_program","_evaluateAnimateUniforms","valueFunction","foundAnimated","newValue","isObjectEmpty","staticUniforms","query","beginTimeElapsedQuery","end","isResultAvailable","elapsedTime","getTimerMilliseconds","lastFrameTime","logDrawTimeout","priority","Date","now","collapsed","attributeTable","configuration","elements","values","attributeLocation","rowHeader","location","getDebugTableForVertexArray","_getDebugTableForUnif","uniformTable","_getDebugTableForUnif2","missingTable","configTable","config","attributeInfos","_table","JSON","varyingInfos","_table2","varyingInfo","getDebugTableForProgramConfiguration","isReady","attributesObject","uniformsObject","logModel","message","Model","_BaseModel","call","prototype","geometryBuffers","instanced","_setModelProps","_deleteGeometryBuffers","getInstanceCount","setDrawMode","setVertexCount","setInstanceCount","setGeometry","buffers","remappedName","typedArray","Uint32Array","target","ELEMENT_ARRAY_BUFFER","getBuffersFromGeometry","normalizedAttributes","transform","_Object$assign","_opts$discard","discard","feedbackBuffers","_opts$unbindModels","unbindModels","_setFeedbackBuffers","unbindBuffers","bindBuffers","_feedbackBuffers","transform_feedback","setBuffers","transpileShader","targetGLSLVersion","convertVertexShaderTo300","convertFragmentShaderTo300","convertVertexShaderTo100","convertFragmentShaderTo100","TYPE_DEFINITIONS","number","validate","propType","min","array","parsePropType","propDef","getTypeOf","ShaderModule","_ref$dependencies","_ref$deprecations","deprecations","vertexShader","fragmentShader","_parseDeprecationDefinitions","propDefs","propTypes","propName","parsePropTypes","getModuleSource","moduleSource","_defaultGetUniforms","getDefines","checkDeprecations","forEach","def","shaderSource","deprecated","RegExp","old","private","MODULE_INJECTORS","_MODULE_INJECTORS","DECLARATION_INJECT_MARKER","REGEX_START_OF_MAIN","REGEX_END_OF_MAIN","fragments","_loop","fragmentData","len","fragmentString","replace","match","combineInjects","injects","__webpack_require__","d","__webpack_exports__","FRAGMENT_SHADER","condition","SphereGeometry","_tesselateSphere","_props$nlat","_props$nlong","_props$radius","latRange","longRange","numVertices","n1","n2","n3","u","positions","Float32Array","normals","texCoords","Uint16Array","y","index","i2","i3","theta","phi","sinTheta","cosTheta","sinPhi","cosPhi","ux","uy","uz","r","numVertsAround","_y","_x","tesselateSphere","_Geometry","TransformFeedback","assertWebGL2Context","_Resource","stubRemovedMethods","isSupported","_this2","unused","bindOnUse","bind","_unbindBuffers","_this3","bufferName","setBuffer","_this4","_getVaryingIndex","locationOrName","_this$_getBufferParam","_getBufferParams","bufferOrParams","byteSize","byteOffset","_bindBuffer","begin","primitiveMode","bindTransformFeedback","TRANSFORM_FEEDBACK","handle","_bindBuffers","beginTransformFeedback","endTransformFeedback","_getVaryingInfo","getVaryingInfo","bufferIndex","_this$_getBufferParam2","bindBufferRange","TRANSFORM_FEEDBACK_BUFFER","bindBufferBase","_createHandle","createTransformFeedback","_deleteHandle","deleteTransformFeedback","_bindHandle","Resource"],"mappings":"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","file":"component---templates-lessons-example-11-jsx-4b4d976d44a1d335d96a.js","sourcesContent":["import GL from '@luma.gl/constants';\nimport {AnimationLoop, setParameters, Texture2D, Model, SphereGeometry} from '@luma.gl/core';\nimport {Vector3, Matrix4} from 'math.gl';\nimport {EventManager} from 'mjolnir.js';\n/* eslint-disable complexity */\n\nconst INFO_HTML = `\n<p>\n  <a href=\"http://learningwebgl.com/blog/?p=1253\" target=\"_blank\">\n  Models, rotation matrices, and mouse events\n  </a>\n<br/>\n<br/>\n  (Rotate the moon with the mouse)\n<p>\n  The classic WebGL Lessons in luma.gl\n`;\n\nconst VERTEX_SHADER = `\\\nattribute vec3 positions;\nattribute vec3 normals;\nattribute vec2 texCoords;\n\nuniform mat4 uMMatrix;\nuniform mat4 uVMatrix;\nuniform mat4 uPMatrix;\n\nuniform vec3 uAmbientColor;\n\nuniform vec3 uLightingDirection;\nuniform vec3 uDirectionalColor;\n\nuniform bool uUseLighting;\n\nvarying vec2 vTextureCoord;\nvarying vec3 vLightWeighting;\n\nvoid main(void) {\n    gl_Position = uPMatrix * uVMatrix * uMMatrix * vec4(positions, 1.0);\n    vTextureCoord = texCoords;\n\n    if (!uUseLighting) {\n        vLightWeighting = vec3(1.0, 1.0, 1.0);\n    } else {\n        vec4 transformedNormal = uMMatrix * vec4(normals, 1.0);\n        vec3 newNormal = transformedNormal.xyz / transformedNormal.w;\n        float directionalLightWeighting = max(dot(newNormal, uLightingDirection), 0.0);\n        vLightWeighting = uAmbientColor + uDirectionalColor * directionalLightWeighting;\n    }\n}\n`;\n\nconst FRAGMENT_SHADER = `\\\nprecision highp float;\n\nvarying vec2 vTextureCoord;\nvarying vec3 vLightWeighting;\n\nuniform sampler2D uSampler;\n\nvoid main(void) {\n  vec4 textureColor = texture2D(uSampler, vec2(1.0 - vTextureCoord.s, 1.0 - vTextureCoord.t));\n  gl_FragColor = vec4(textureColor.rgb * vLightWeighting, textureColor.a);\n}\n`;\n\nconst appState = {\n  mouseDown: false,\n  lastMouseX: null,\n  lastMouseY: null,\n  moonRotationMatrix: new Matrix4()\n};\n\nexport default class AppAnimationLoop extends AnimationLoop {\n  static getInfo() {\n    return INFO_HTML;\n  }\n\n  onInitialize({canvas, gl}) {\n    // Use mjolnir.js (hammer.js)'s EventManager to handle gestures on both\n    // desktop and mobile\n    this.eventManager = new EventManager(canvas);\n    addMouseHandler(this.eventManager);\n\n    setParameters(gl, {\n      clearColor: [0, 0, 0, 1],\n      clearDepth: 1,\n      depthTest: true\n    });\n\n    return {\n      moon: new Model(gl, {\n        fs: FRAGMENT_SHADER,\n        vs: VERTEX_SHADER,\n        geometry: new SphereGeometry({\n          nlat: 30,\n          nlong: 30,\n          radius: 2\n        }),\n        uniforms: {\n          uSampler: new Texture2D(gl, 'moon.gif')\n        }\n      })\n    };\n  }\n\n  // eslint-disable-next-line complexity\n  onRender({gl, tick, aspect, moon}) {\n    // Update Camera Position\n    const eyePos = [0, 0, 6];\n\n    gl.clear(GL.COLOR_BUFFER_BIT | GL.DEPTH_BUFFER_BIT);\n\n    const uMMatrix = new Matrix4().multiplyRight(appState.moonRotationMatrix);\n    const uVMatrix = new Matrix4().lookAt({eye: eyePos, center: [0, 0, 0], up: [0, 1, 0]});\n\n    // Read controls\n    const {lighting, ambientColor, lightingDirection, directionalColor} = getControlValues();\n\n    moon.setUniforms({uUseLighting: lighting});\n\n    if (lighting) {\n      lightingDirection.normalize();\n      lightingDirection.scale(-1);\n\n      moon.setUniforms({\n        uAmbientColor: ambientColor,\n        uLightingDirection: lightingDirection,\n        uDirectionalColor: directionalColor\n      });\n    }\n\n    return moon\n      .setUniforms({\n        uMMatrix,\n        uVMatrix,\n        uPMatrix: new Matrix4().perspective({\n          fov: (45 * Math.PI) / 180,\n          aspect,\n          near: 0.1,\n          far: 100\n        })\n      })\n      .draw();\n  }\n\n  onFinalize() {\n    this.eventManager.destroy();\n  }\n}\n\nfunction addMouseHandler(eventManager) {\n  eventManager.on({\n    panstart(event) {\n      appState.mouseDown = true;\n      appState.lastMouseX = event.offsetCenter.x;\n      appState.lastMouseY = event.offsetCenter.y;\n    },\n    panmove(event) {\n      if (!appState.mouseDown) {\n        return;\n      }\n\n      if (appState.lastMouseX !== undefined) {\n        const radiansX = (event.offsetCenter.x - appState.lastMouseX) / 300;\n        const radiansY = (event.offsetCenter.y - appState.lastMouseY) / 300;\n\n        const newMatrix = new Matrix4().rotateX(radiansY).rotateY(radiansX);\n\n        appState.moonRotationMatrix.multiplyLeft(newMatrix);\n      }\n\n      appState.lastMouseX = event.offsetCenter.x;\n      appState.lastMouseY = event.offsetCenter.y;\n    },\n\n    panend(e) {\n      appState.mouseDown = false;\n    }\n  });\n}\n\nfunction getControlValues() {\n  /* global document */\n  function getElementValue(id, defaultValue) {\n    const element = document.getElementById(id);\n    return element ? parseFloat(element.value) : defaultValue;\n  }\n\n  const element = document.getElementById('lighting');\n  const lighting = element ? element.checked : true;\n\n  const ambientColor =\n    lighting &&\n    new Vector3(\n      getElementValue('ambientR', 0.2),\n      getElementValue('ambientG', 0.2),\n      getElementValue('ambientB', 0.2)\n    );\n\n  const lightingDirection =\n    lighting &&\n    new Vector3(\n      getElementValue('lightDirectionX', -1),\n      getElementValue('lightDirectionY', -1),\n      getElementValue('lightDirectionZ', -1)\n    );\n\n  const directionalColor =\n    lighting &&\n    new Vector3(\n      getElementValue('directionalR', 0.8),\n      getElementValue('directionalG', 0.8),\n      getElementValue('directionalB', 0.8)\n    );\n\n  return {lighting, ambientColor, lightingDirection, directionalColor};\n}\n\n/* global window */\nif (typeof window !== 'undefined' && !window.website) {\n  const animationLoop = new AppAnimationLoop();\n  animationLoop.start();\n}\n","import React from 'react';\nimport AnimationLoopExamplePage from '../../src/components/animation-loop-example-page';\nimport AnimationLoop from '../../../examples/lessons/11/app';\n\nexport default class Example extends React.Component {\n  render() {\n    return (\n      <AnimationLoopExamplePage AnimationLoop={AnimationLoop} exampleConfig={this.props.pageContext.exampleConfig} />\n    );\n  }\n}\n","import {uid, assert} from '../utils';\n\n// Rendering primitives - specify how to extract primitives from vertices.\n// NOTE: These are numerically identical to the corresponding WebGL/OpenGL constants\nexport const DRAW_MODE = {\n  POINTS: 0x0000, // draw single points.\n  LINES: 0x0001, // draw lines. Each vertex connects to the one after it.\n  LINE_LOOP: 0x0002, // draw lines. Each set of two vertices is treated as a separate line segment.\n  LINE_STRIP: 0x0003, // draw a connected group of line segments from the first vertex to the last\n  TRIANGLES: 0x0004, // draw triangles. Each set of three vertices creates a separate triangle.\n  TRIANGLE_STRIP: 0x0005, // draw a connected group of triangles.\n  TRIANGLE_FAN: 0x0006 // draw a connected group of triangles.\n  // Each vertex connects to the previous and the first vertex in the fan.\n};\n\nexport default class Geometry {\n  static get DRAW_MODE() {\n    return DRAW_MODE;\n  }\n\n  constructor(props = {}) {\n    const {\n      id = uid('geometry'),\n      drawMode = DRAW_MODE.TRIANGLES,\n      attributes = {},\n      indices = null,\n      vertexCount = null\n    } = props;\n\n    this.id = id;\n    this.drawMode = drawMode | 0;\n    this.attributes = {};\n    this.userData = {};\n\n    this._setAttributes(attributes, indices);\n\n    this.vertexCount = vertexCount || this._calculateVertexCount(this.attributes, this.indices);\n\n    // stubRemovedMethods(this, [\n    //   'setNeedsRedraw', 'needsRedraw', 'setAttributes'\n    // ], 'Immutable');\n\n    // stubRemovedMethods(this, [\n    //   'hasAttribute', 'getAttribute', 'getArray'\n    // ], 'Use geometry.attributes and geometry.indices');\n\n    // deprecateMethods(this, ['getAttributes'])\n  }\n\n  get mode() {\n    return this.drawMode;\n  }\n\n  getVertexCount() {\n    return this.vertexCount;\n  }\n\n  // Return an object with all attributes plus indices added as a field.\n  getAttributes() {\n    return this.indices ? {indices: this.indices, ...this.attributes} : this.attributes;\n  }\n\n  // PRIVATE\n\n  _print(attributeName) {\n    return `Geometry ${this.id} attribute ${attributeName}`;\n  }\n\n  // Attribute\n  // value: typed array\n  // type: indices, vertices, uvs\n  // size: elements per vertex\n  // target: WebGL buffer type (string or constant)\n  _setAttributes(attributes, indices) {\n    if (indices) {\n      this.indices = ArrayBuffer.isView(indices) ? {value: indices, size: 1} : indices;\n    }\n\n    for (const attributeName in attributes) {\n      let attribute = attributes[attributeName];\n\n      // Wrap \"unwrapped\" arrays and try to autodetect their type\n      attribute = ArrayBuffer.isView(attribute) ? {value: attribute} : attribute;\n\n      assert(\n        ArrayBuffer.isView(attribute.value),\n        `${this._print(attributeName)}: must be typed array or object with value as typed array`\n      );\n\n      if ((attributeName === 'POSITION' || attributeName === 'positions') && !attribute.size) {\n        attribute.size = 3;\n      }\n\n      // Move indices to separate field\n      if (attributeName === 'indices') {\n        assert(!this.indices);\n        this.indices = attribute;\n      } else {\n        this.attributes[attributeName] = attribute;\n      }\n    }\n\n    if (this.indices && this.indices.isIndexed !== undefined) {\n      this.indices = Object.assign({}, this.indices);\n      delete this.indices.isIndexed;\n    }\n\n    return this;\n  }\n\n  _calculateVertexCount(attributes, indices) {\n    if (indices) {\n      return indices.value.length;\n    }\n    let vertexCount = Infinity;\n    for (const attributeName in attributes) {\n      const attribute = attributes[attributeName];\n      const {value, size, constant} = attribute;\n      if (!constant && value && size >= 1) {\n        vertexCount = Math.min(vertexCount, value.length / size);\n      }\n    }\n\n    assert(Number.isFinite(vertexCount));\n    return vertexCount;\n  }\n}\n","import ShaderModule from './shader-module';\nimport {assert} from '../utils';\n\nexport default class ShaderModuleRegistry {\n  constructor() {\n    this.shaderModules = {};\n    this.defaultShaderModules = [];\n  }\n\n  setDefaultShaderModules(modules) {\n    this.defaultShaderModules = this.resolveModules(modules);\n  }\n\n  getDefaultShaderModules() {\n    return this.defaultShaderModules;\n  }\n\n  registerShaderModules(shaderModuleList, {ignoreMultipleRegistrations = false} = {}) {\n    for (const shaderModule of shaderModuleList) {\n      this._registerShaderModule(shaderModule, ignoreMultipleRegistrations);\n    }\n  }\n\n  getShaderModule(moduleOrName) {\n    // Check if \"inline\" module, return it\n    if (moduleOrName instanceof ShaderModule) {\n      return moduleOrName;\n    }\n\n    // Check if module descriptor\n    if (typeof moduleOrName !== 'string') {\n      return this._registerShaderModule(moduleOrName, true);\n    }\n\n    // Module name - Look up module\n    const module = this.shaderModules[moduleOrName];\n    if (!module) {\n      assert(false, `Unknown shader module ${moduleOrName}`);\n    }\n    return module;\n  }\n\n  // registers any supplied modules, resolves any names into modules\n  // returns a list of modules\n  resolveModules(modules) {\n    return modules.map(moduleOrName => this.getShaderModule(moduleOrName));\n  }\n\n  // PRIVATE API\n\n  _registerShaderModule(module, ignoreMultipleRegistrations = false) {\n    // Check if \"inline\" module, return it\n    if (module instanceof ShaderModule) {\n      return module;\n    }\n\n    assert(module.name, 'shader module has no name');\n\n    if (!this.shaderModules[module.name] || ignoreMultipleRegistrations) {\n      // if ignoreMultipleRegistrations = true, we allow module to be re-registered\n      module = new ShaderModule(module);\n      module.dependencies = this.resolveModules(module.dependencies);\n      this.shaderModules[module.name] = module;\n    } else {\n      // TODO - instead verify that definition is not changing...\n      throw new Error(`shader module ${module.name} already registered`);\n    }\n\n    return this.shaderModules[module.name];\n  }\n}\n","import ShaderModuleRegistry from './shader-module-registry';\n\nconst shaderModuleRegistry = new ShaderModuleRegistry();\n\n/**\n * Registers an array of default shader modules. These will be concatenated\n * automatically at the end of any shader module list passed to\n * `assembleShaders` (plus `resolveModules` and `getShaderDependencies`)\n * @param {Object[]} modules - Array of shader modules\n */\nexport function setDefaultShaderModules(modules) {\n  shaderModuleRegistry.setDefaultShaderModules(modules);\n}\n\nexport function getDefaultShaderModules() {\n  return shaderModuleRegistry.getDefaultShaderModules();\n}\n\n/**\n * Registers an array of shader modules\n * @param {Object[]} shaderModuleList - Array of shader modules\n */\nexport function registerShaderModules(\n  shaderModuleList,\n  {ignoreMultipleRegistrations = false} = {}\n) {\n  shaderModuleRegistry.registerShaderModules(shaderModuleList, {ignoreMultipleRegistrations});\n}\n\n// registers any supplied modules and returns a list of module names\nexport function resolveModules(modules) {\n  modules = modules.concat(shaderModuleRegistry.defaultShaderModules);\n  modules = shaderModuleRegistry.resolveModules(modules);\n  return getShaderDependencies(modules);\n}\n\n// Looks up a moduleName among registered modules and returns definition.\n// If \"inline\" module, returns it directly\nexport function getShaderModule(moduleOrName) {\n  return shaderModuleRegistry.getShaderModule(moduleOrName);\n}\n\n/**\n * Takes a list of shader module names and returns a new list of\n * shader module names that includes all dependencies, sorted so\n * that modules that are dependencies of other modules come first.\n *\n * If the shader glsl code from the returned modules is concatenated\n * in the reverse order, it is guaranteed that all functions be resolved and\n * that all function and variable definitions come before use.\n *\n * @param {String[]} modules - Array of modules (inline modules or module names)\n * @return {String[]} - Array of modules\n */\nfunction getShaderDependencies(modules) {\n  const moduleMap = {};\n  const moduleDepth = {};\n  getDependencyGraph({modules, level: 0, moduleMap, moduleDepth});\n\n  // Return a reverse sort so that dependencies come before the modules that use them\n  return Object.keys(moduleDepth)\n    .sort((a, b) => moduleDepth[b] - moduleDepth[a])\n    .map(name => moduleMap[name]);\n}\n\n/**\n * Recursively checks module dpendencies to calculate dependency\n * level of each module.\n *\n * @param {String[]} modules - Array of modules\n * @param {Number} level - Current level\n * @return {result} - Map of module name to its level\n */\n// Adds another level of dependencies to the result map\nfunction getDependencyGraph({modules, level, moduleMap, moduleDepth}) {\n  if (level >= 5) {\n    throw new Error('Possible loop in shader dependency graph');\n  }\n\n  // Update level on all current modules\n  for (const module of modules) {\n    moduleMap[module.name] = module;\n    if (moduleDepth[module.name] === undefined || moduleDepth[module.name] < level) {\n      moduleDepth[module.name] = level;\n    }\n  }\n\n  // Recurse\n  for (const module of modules) {\n    if (module.dependencies) {\n      getDependencyGraph({modules: module.dependencies, level: level + 1, moduleMap, moduleDepth});\n    }\n  }\n}\n\nexport const TEST_EXPORTS = {\n  getShaderDependencies,\n  getDependencyGraph\n};\n","// Feature detection for WebGL\n//\n// Provides a function that enables simple checking of which WebGL features are\n// available in an WebGL1 or WebGL2 environment.\n\n/* eslint-disable no-inline-comments, max-len */\nimport isOldIE from './is-old-ie';\nimport assert from './assert';\n\nconst GL_VENDOR = 0x1f00;\nconst GL_RENDERER = 0x1f01;\nconst GL_VERSION = 0x1f02;\nconst GL_SHADING_LANGUAGE_VERSION = 0x8b8c;\n\n// Defines luma.gl \"feature\" names and semantics\nconst WEBGL_FEATURES = {\n  // GLSL extensions\n  GLSL_FRAG_DATA: ['WEBGL_draw_buffers', true], // TODO - name makes no sense in GLSL 3.00\n  GLSL_FRAG_DEPTH: ['EXT_frag_depth', true],\n  GLSL_DERIVATIVES: ['OES_standard_derivatives', true],\n  GLSL_TEXTURE_LOD: ['EXT_shader_texture_lod', true]\n};\n\n// Create a key-mirrored FEATURES array\nconst FEATURES = {};\nObject.keys(WEBGL_FEATURES).forEach(key => {\n  FEATURES[key] = key;\n});\n\nexport {FEATURES};\n\nfunction isWebGL2(gl) {\n  return Boolean(gl && gl._version === 2);\n}\n\nexport function getContextInfo(gl) {\n  const info = gl.getExtension('WEBGL_debug_renderer_info');\n  const vendor = gl.getParameter((info && info.UNMASKED_VENDOR_WEBGL) || GL_VENDOR);\n  const renderer = gl.getParameter((info && info.UNMASKED_RENDERER_WEBGL) || GL_RENDERER);\n  const gpuVendor = identifyGPUVendor(vendor, renderer);\n  const gpuInfo = {\n    gpuVendor,\n    vendor,\n    renderer,\n    version: gl.getParameter(GL_VERSION),\n    shadingLanguageVersion: gl.getParameter(GL_SHADING_LANGUAGE_VERSION)\n  };\n  return gpuInfo;\n}\n\nfunction identifyGPUVendor(vendor, renderer) {\n  if (vendor.match(/NVIDIA/i) || renderer.match(/NVIDIA/i)) {\n    return 'NVIDIA';\n  }\n  if (vendor.match(/INTEL/i) || renderer.match(/INTEL/i)) {\n    return 'INTEL';\n  }\n  if (\n    vendor.match(/AMD/i) ||\n    renderer.match(/AMD/i) ||\n    vendor.match(/ATI/i) ||\n    renderer.match(/ATI/i)\n  ) {\n    return 'AMD';\n  }\n  return 'UNKNOWN GPU';\n}\n\nconst compiledGlslExtensions = {};\n\n// Enables feature detection in IE11 due to a bug where gl.getExtension may return true\n// but fail to compile when the extension is enabled in the shader. Specifically,\n// the OES_standard_derivatives and WEBGL_draw_buffers extensions fails to compile in IE11 even though its included\n// in the list of supported extensions.\n// opts allows user agent to be overridden for testing\n/*\n* Inputs :\n*  gl : WebGL context\n*  cap : Key of WEBGL_FEATURES object identifying the extension\n*  opts :\n*   behavior : behavor of extension to be tested, by defualt `enable` is used\n* Returns : true, if shader is compiled successfully, false otherwise\n*/\nexport function canCompileGLGSExtension(gl, cap, opts = {}) {\n  const feature = WEBGL_FEATURES[cap];\n  assert(feature, cap);\n\n  if (!isOldIE(opts)) {\n    return true;\n  }\n\n  if (cap in compiledGlslExtensions) {\n    return compiledGlslExtensions[cap];\n  }\n\n  const extensionName = feature[0];\n  const behavior = opts.behavior || 'enable';\n  const source = `#extension GL_${extensionName} : ${behavior}\\nvoid main(void) {}`;\n\n  const shader = gl.createShader(gl.VERTEX_SHADER);\n  gl.shaderSource(shader, source);\n  gl.compileShader(shader);\n  const canCompile = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\n  gl.deleteShader(shader);\n  compiledGlslExtensions[cap] = canCompile;\n  return canCompile;\n}\n\n// TODO - cache the value\nfunction getFeature(gl, cap) {\n  const feature = WEBGL_FEATURES[cap];\n  assert(feature, cap);\n\n  // Get extension name from table\n  const extensionName = isWebGL2(gl) ? feature[1] || feature[0] : feature[0];\n\n  // Check if the value is dependent on checking an extension\n  const value =\n    typeof extensionName === 'string' ? Boolean(gl.getExtension(extensionName)) : extensionName;\n\n  assert(value === false || value === true);\n\n  return value;\n}\n\nexport function hasFeatures(gl, features) {\n  features = Array.isArray(features) ? features : [features];\n  return features.every(feature => getFeature(gl, feature));\n}\n","/* global window */\n// opts allows user agent to be overridden for testing\nexport default function isOldIE(opts = {}) {\n  const navigator = typeof window !== 'undefined' ? window.navigator || {} : {};\n  const userAgent = opts.userAgent || navigator.userAgent || '';\n  // We only care about older versions of IE (IE 11 and below). Newer versions of IE (Edge)\n  // have much better web standards support.\n  const isMSIE = userAgent.indexOf('MSIE ') !== -1;\n  const isTrident = userAgent.indexOf('Trident/') !== -1;\n  return isMSIE || isTrident;\n}\n","import {getContextInfo, hasFeatures, canCompileGLGSExtension, FEATURES} from '../utils/webgl-info';\n\nexport function getPlatformShaderDefines(gl) {\n  const debugInfo = getContextInfo(gl);\n\n  switch (debugInfo.gpuVendor.toLowerCase()) {\n    case 'nvidia':\n      return `\\\n#define NVIDIA_GPU\n// Nvidia optimizes away the calculation necessary for emulated fp64\n#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1\n`;\n\n    case 'intel':\n      return `\\\n#define INTEL_GPU\n// Intel optimizes away the calculation necessary for emulated fp64\n#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1\n// Intel's built-in 'tan' function doesn't have acceptable precision\n#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1\n// Intel GPU doesn't have full 32 bits precision in same cases, causes overflow\n#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1\n`;\n\n    case 'amd':\n      // AMD Does not eliminate fp64 code\n      return `\\\n#define AMD_GPU\n`;\n\n    default:\n      // We don't know what GPU it is, could be that the GPU driver or\n      // browser is not implementing UNMASKED_RENDERER constant and not\n      // reporting a correct name\n      return `\\\n#define DEFAULT_GPU\n// Prevent driver from optimizing away the calculation necessary for emulated fp64\n#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1\n// Intel's built-in 'tan' function doesn't have acceptable precision\n#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1\n// Intel GPU doesn't have full 32 bits precision in same cases, causes overflow\n#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1\n`;\n  }\n}\n\nexport function getVersionDefines(gl, glslVersion, isFragment) {\n  // Add shadertools defines to let shaders portably v1/v3 check for features\n  let versionDefines = `\\\n#if (__VERSION__ > 120)\n\n# define FRAG_DEPTH\n# define DERIVATIVES\n# define DRAW_BUFFERS\n# define TEXTURE_LOD\n\n#endif // __VERSION\n`;\n\n  if (hasFeatures(gl, FEATURES.GLSL_FRAG_DEPTH)) {\n    versionDefines += `\\\n// FRAG_DEPTH => gl_FragDepth is available\n#ifdef GL_EXT_frag_depth\n#extension GL_EXT_frag_depth : enable\n# define FRAG_DEPTH\n# define gl_FragDepth gl_FragDepthEXT\n#endif\n`;\n  }\n  if (\n    hasFeatures(gl, FEATURES.GLSL_DERIVATIVES) &&\n    canCompileGLGSExtension(gl, FEATURES.GLSL_DERIVATIVES)\n  ) {\n    versionDefines += `\\\n// DERIVATIVES => dxdF, dxdY and fwidth are available\n#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives : enable\n# define DERIVATIVES\n#endif\n`;\n  }\n  if (\n    hasFeatures(gl, FEATURES.GLSL_FRAG_DATA) &&\n    canCompileGLGSExtension(gl, FEATURES.GLSL_FRAG_DATA, {behavior: 'require'})\n  ) {\n    versionDefines += `\\\n// DRAW_BUFFERS => gl_FragData[] is available\n#ifdef GL_EXT_draw_buffers\n#extension GL_EXT_draw_buffers : require\n#define DRAW_BUFFERS\n#endif\n`;\n  }\n  if (hasFeatures(gl, FEATURES.GLSL_TEXTURE_LOD)) {\n    versionDefines += `\\\n// TEXTURE_LOD => texture2DLod etc are available\n#ifdef GL_EXT_shader_texture_lod\n#extension GL_EXT_shader_texture_lod : enable\n# define TEXTURE_LOD\n#define texture2DLod texture2DLodEXT\n#define texture2DProjLod texture2DProjLodEXT\n#define texture2DProjLod texture2DProjLodEXT\n#define textureCubeLod textureCubeLodEXT\n#define texture2DGrad texture2DGradEXT\n#define texture2DProjGrad texture2DProjGradEXT\n#define texture2DProjGrad texture2DProjGradEXT\n#define textureCubeGrad textureCubeGradEXT\n#endif\n`;\n  }\n  return versionDefines;\n}\n","import {VERTEX_SHADER, FRAGMENT_SHADER} from './constants';\nimport {resolveModules, getShaderModule} from './resolve-modules';\nimport {getPlatformShaderDefines, getVersionDefines} from './platform-defines';\nimport injectShader, {DECLARATION_INJECT_MARKER} from './inject-shader';\nimport {assert} from '../utils';\n/* eslint-disable max-depth, complexity */\n\nconst INJECT_SHADER_DECLARATIONS = `\\n\\n${DECLARATION_INJECT_MARKER}\\n\\n`;\n\nconst SHADER_TYPE = {\n  [VERTEX_SHADER]: 'vertex',\n  [FRAGMENT_SHADER]: 'fragment'\n};\n\nconst HOOK_FUNCTIONS = {\n  [VERTEX_SHADER]: {},\n  [FRAGMENT_SHADER]: {}\n};\n\nconst MODULE_INJECTIONS = {};\n\n// Precision prologue to inject before functions are injected in shader\n// TODO - extract any existing prologue in the fragment source and move it up...\nconst FRAGMENT_SHADER_PROLOGUE = `\\\nprecision highp float;\n\n`;\n\nexport function createShaderHook(hook, opts = {}) {\n  hook = hook.trim();\n  const [stage, signature] = hook.split(':');\n  const name = hook.replace(/\\(.+/, '');\n  HOOK_FUNCTIONS[stage][name] = Object.assign(opts, {signature});\n}\n\nexport function createModuleInjection(moduleName, opts) {\n  const {hook, injection, order = 0} = opts;\n  const shaderStage = hook.slice(0, 2);\n\n  MODULE_INJECTIONS[moduleName] = MODULE_INJECTIONS[moduleName] || {};\n  MODULE_INJECTIONS[moduleName][shaderStage] = MODULE_INJECTIONS[moduleName][shaderStage] || {};\n\n  assert(!MODULE_INJECTIONS[moduleName][shaderStage][hook], 'Module injection already created');\n\n  MODULE_INJECTIONS[moduleName][shaderStage][hook] = {\n    injection,\n    order\n  };\n}\n\n// Inject a list of modules\nexport function assembleShaders(gl, opts) {\n  const {vs, fs} = opts;\n  const modules = resolveModules(opts.modules || []);\n  return {\n    gl,\n    vs: assembleShader(gl, Object.assign({}, opts, {source: vs, type: VERTEX_SHADER, modules})),\n    fs: assembleShader(gl, Object.assign({}, opts, {source: fs, type: FRAGMENT_SHADER, modules})),\n    getUniforms: assembleGetUniforms(modules),\n    modules: assembleModuleMap(modules)\n  };\n}\n\n// Pulls together complete source code for either a vertex or a fragment shader\n// adding prologues, requested module chunks, and any final injections.\nfunction assembleShader(\n  gl,\n  {id, source, type, modules, defines = {}, inject = {}, prologue = true, log}\n) {\n  assert(typeof source === 'string', 'shader source must be a string');\n\n  const isVertex = type === VERTEX_SHADER;\n\n  const sourceLines = source.split('\\n');\n  let glslVersion = 100;\n  let versionLine = '';\n  let coreSource = source;\n  // Extract any version directive string from source.\n  // TODO : keep all pre-processor statements at the begining of the shader.\n  if (sourceLines[0].indexOf('#version ') === 0) {\n    glslVersion = 300; // TODO - regexp that matches atual version number\n    versionLine = sourceLines[0];\n    coreSource = sourceLines.slice(1).join('\\n');\n  }\n\n  // Combine Module and Application Defines\n  const allDefines = {};\n  modules.forEach(module => {\n    Object.assign(allDefines, module.getDefines());\n  });\n  Object.assign(allDefines, defines);\n\n  // Add platform defines (use these to work around platform-specific bugs and limitations)\n  // Add common defines (GLSL version compatibility, feature detection)\n  // Add precision declaration for fragment shaders\n  let assembledSource = prologue\n    ? `\\\n${versionLine}\n${getShaderName({id, source, type})}\n${getShaderType({type})}\n${getPlatformShaderDefines(gl)}\n${getVersionDefines(gl, glslVersion, !isVertex)}\n${getApplicationDefines(allDefines)}\n${isVertex ? '' : FRAGMENT_SHADER_PROLOGUE}\n`\n    : `${versionLine}\n`;\n\n  // Add source of dependent modules in resolved order\n  let injectStandardStubs = false;\n  const hookInjections = {};\n  const mainInjections = {};\n\n  for (const key in inject) {\n    const injection =\n      typeof inject[key] === 'string' ? {injection: inject[key], order: 0} : inject[key];\n    if (key.match(/^(v|f)s:/)) {\n      if (key[3] === '#') {\n        mainInjections[key] = [injection];\n      } else {\n        hookInjections[key] = [injection];\n      }\n    } else {\n      // Regex injection\n      mainInjections[key] = [injection];\n    }\n  }\n\n  for (const module of modules) {\n    switch (module.name) {\n      case 'inject':\n        injectStandardStubs = true;\n        break;\n\n      default:\n        if (log) {\n          module.checkDeprecations(coreSource, log);\n        }\n        const moduleSource = module.getModuleSource(type, glslVersion);\n        // Add the module source, and a #define that declares it presence\n        assembledSource += moduleSource;\n\n        if (MODULE_INJECTIONS[module.name]) {\n          const injections = MODULE_INJECTIONS[module.name][type];\n          for (const key in injections) {\n            if (key.match(/^(v|f)s:#/)) {\n              mainInjections[key] = mainInjections[key] || [];\n              mainInjections[key].push(injections[key]);\n            } else {\n              hookInjections[key] = hookInjections[key] || [];\n              hookInjections[key].push(injections[key]);\n            }\n          }\n        }\n    }\n  }\n\n  // For injectShader\n  assembledSource += INJECT_SHADER_DECLARATIONS;\n\n  assembledSource += getHookFunctions(type, hookInjections);\n\n  // Add the version directive and actual source of this shader\n  assembledSource += coreSource;\n\n  // Apply any requested shader injections\n  assembledSource = injectShader(assembledSource, type, mainInjections, injectStandardStubs);\n\n  return assembledSource;\n}\n\n// Returns a combined `getUniforms` covering the options for all the modules,\n// the created function will pass on options to the inidividual `getUniforms`\n// function of each shader module and combine the results into one object that\n// can be passed to setUniforms.\nfunction assembleGetUniforms(modules) {\n  return function getUniforms(opts) {\n    const uniforms = {};\n    for (const module of modules) {\n      // `modules` is already sorted by dependency level. This guarantees that\n      // modules have access to the uniforms that are generated by their dependencies.\n      const moduleUniforms = module.getUniforms(opts, uniforms);\n      Object.assign(uniforms, moduleUniforms);\n    }\n    return uniforms;\n  };\n}\n\n// Returns a map with module names as keys, resolving to their module definitions\n// The presence of a key indicates that the module is available in this program,\n// whether directly included, or through a dependency of some other module\nfunction assembleModuleMap(modules) {\n  const result = {};\n  for (const moduleName of modules) {\n    const shaderModule = getShaderModule(moduleName);\n    result[moduleName] = shaderModule;\n  }\n  return result;\n}\n\nfunction getShaderType({type}) {\n  return `\n#define SHADER_TYPE_${SHADER_TYPE[type].toUpperCase()}\n`;\n}\n\n// Generate \"glslify-compatible\" SHADER_NAME defines\n// These are understood by the GLSL error parsing function\n// If id is provided and no SHADER_NAME constant is present in source, create one\nfunction getShaderName({id, source, type}) {\n  const injectShaderName = id && typeof id === 'string' && source.indexOf('SHADER_NAME') === -1;\n  return injectShaderName\n    ? `\n#define SHADER_NAME ${id}_${SHADER_TYPE[type]}\n\n`\n    : '';\n}\n\n// Generates application defines from an object\nfunction getApplicationDefines(defines = {}) {\n  let count = 0;\n  let sourceText = '';\n  for (const define in defines) {\n    if (count === 0) {\n      sourceText += '\\n// APPLICATION DEFINES\\n';\n    }\n    count++;\n\n    const value = defines[define];\n    if (value || Number.isFinite(value)) {\n      sourceText += `#define ${define.toUpperCase()} ${defines[define]}\\n`;\n    }\n  }\n  if (count === 0) {\n    sourceText += '\\n';\n  }\n  return sourceText;\n}\n\nfunction getHookFunctions(shaderStage, hookInjections) {\n  let result = '';\n  const hookFunctions = HOOK_FUNCTIONS[shaderStage];\n  for (const hookName in hookFunctions) {\n    const hookFunction = hookFunctions[hookName];\n    result += `void ${hookFunction.signature} {\\n`;\n    if (hookFunction.header) {\n      result += `  ${hookFunction.header}`;\n    }\n    if (hookInjections[hookName]) {\n      const injections = hookInjections[hookName];\n      injections.sort((a, b) => a.order - b.order);\n      for (const injection of injections) {\n        result += `  ${injection.injection}\\n`;\n      }\n    }\n    if (hookFunction.footer) {\n      result += `  ${hookFunction.footer}`;\n    }\n    result += '}\\n';\n  }\n\n  return result;\n}\n","import GL from '@luma.gl/constants';\nimport {Buffer} from '@luma.gl/webgl';\nimport {assert} from '../utils';\n\n// Support for mapping new geometries with glTF attribute names to \"classic\" luma.gl shader names\nconst GLTF_TO_LUMA_ATTRIBUTE_MAP = {\n  POSITION: 'positions',\n  NORMAL: 'normals',\n  COLOR_0: 'colors',\n  TEXCOORD_0: 'texCoords',\n  TEXCOORD_1: 'texCoords1',\n  TEXCOORD_2: 'texCoords2'\n};\n\nexport function getBuffersFromGeometry(gl, geometry, options) {\n  const buffers = {};\n  let indices = geometry.indices;\n\n  for (const name in geometry.attributes) {\n    const attribute = geometry.attributes[name];\n    const remappedName = mapAttributeName(name, options);\n\n    if (name === 'indices') {\n      indices = attribute;\n    } else if (attribute.constant) {\n      buffers[remappedName] = attribute.value;\n    } else {\n      const typedArray = attribute.value;\n      // Create accessor by copying the attribute and removing `value``\n      const accessor = {...attribute};\n      delete accessor.value;\n      buffers[remappedName] = [new Buffer(gl, typedArray), accessor];\n\n      inferAttributeAccessor(name, accessor);\n    }\n  }\n\n  if (indices) {\n    const data = indices.value || indices;\n    assert(\n      data instanceof Uint16Array || data instanceof Uint32Array,\n      'attribute array for \"indices\" must be of integer type'\n    );\n    const accessor = {\n      size: 1,\n      isIndexed: indices.isIndexed === undefined ? true : indices.isIndexed\n    };\n    buffers.indices = [\n      new Buffer(gl, {\n        data,\n        target: GL.ELEMENT_ARRAY_BUFFER\n      }),\n      accessor\n    ];\n  }\n\n  return buffers;\n}\n\nfunction mapAttributeName(name, options) {\n  const {attributeMap = GLTF_TO_LUMA_ATTRIBUTE_MAP} = options || {};\n  return (attributeMap && attributeMap[name]) || name;\n}\n\n// Check for well known attribute names\n// eslint-disable-next-line complexity\nexport function inferAttributeAccessor(attributeName, attribute) {\n  let category;\n  switch (attributeName) {\n    case 'texCoords':\n    case 'texCoord1':\n    case 'texCoord2':\n    case 'texCoord3':\n      category = 'uvs';\n      break;\n    case 'vertices':\n    case 'positions':\n    case 'normals':\n    case 'pickingColors':\n      category = 'vectors';\n      break;\n    default:\n  }\n\n  // Check for categorys\n  switch (category) {\n    case 'vectors':\n      attribute.size = attribute.size || 3;\n      break;\n    case 'uvs':\n      attribute.size = attribute.size || 2;\n      break;\n    default:\n  }\n\n  assert(Number.isFinite(attribute.size), `attribute ${attributeName} needs size`);\n}\n","// TODO / DEPRECATED - delete when confident that probe.gl logging implements all opts\n/* eslint-disable no-console */\nfunction formatArrayValue(v, opts) {\n  const {maxElts = 16, size = 1} = opts;\n  let string = '[';\n  for (let i = 0; i < v.length && i < maxElts; ++i) {\n    if (i > 0) {\n      string += `,${i % size === 0 ? ' ' : ''}`;\n    }\n    string += formatValue(v[i], opts);\n  }\n  const terminator = v.length > maxElts ? '...' : ']';\n  return `${string}${terminator}`;\n}\n\nexport function formatValue(v, opts = {}) {\n  const EPSILON = 1e-16;\n  const {isInteger = false} = opts;\n  if (Array.isArray(v) || ArrayBuffer.isView(v)) {\n    return formatArrayValue(v, opts);\n  }\n  if (!Number.isFinite(v)) {\n    return String(v);\n  }\n  if (Math.abs(v) < EPSILON) {\n    return isInteger ? '0' : '0.';\n  }\n  if (isInteger) {\n    return v.toFixed(0);\n  }\n  if (Math.abs(v) > 100 && Math.abs(v) < 10000) {\n    return v.toFixed(0);\n  }\n  const string = v.toPrecision(2);\n  const decimal = string.indexOf('.0');\n  return decimal === string.length - 2 ? string.slice(0, -1) : string;\n}\n","import Buffer from '../classes/buffer';\nimport {getKey} from '../webgl-utils';\nimport {getCompositeGLType} from '../webgl-utils/attribute-utils';\nimport {formatValue} from '../utils';\n\n// Creates object suitable as input for console.table\nexport function getDebugTableForVertexArray({vertexArray, header = 'Attributes'} = {}) {\n  if (!vertexArray.configuration) {\n    return {};\n  }\n\n  const table = {}; // {[header]: {}};\n\n  // Add index (elements) if available\n  if (vertexArray.elements) {\n    // const elements = Object.assign({size: 1}, vertexArray.elements);\n    table.ELEMENT_ARRAY_BUFFER = getDebugTableRow(vertexArray, vertexArray.elements, null, header);\n  }\n\n  // Add used attributes\n  const attributes = vertexArray.values;\n\n  for (const attributeLocation in attributes) {\n    const info = vertexArray._getAttributeInfo(attributeLocation);\n    if (info) {\n      let rowHeader = `${attributeLocation}: ${info.name}`;\n      const accessor = vertexArray.accessors[info.location];\n      if (accessor) {\n        rowHeader = `${attributeLocation}: ${getGLSLDeclaration(info.name, accessor)}`;\n      }\n      table[rowHeader] = getDebugTableRow(\n        vertexArray,\n        attributes[attributeLocation],\n        accessor,\n        header\n      );\n    }\n  }\n\n  return table;\n}\n\n/* eslint-disable max-statements */\nfunction getDebugTableRow(vertexArray, attribute, accessor, header) {\n  // const round = xnum => Math.round(num * 10) / 10;\n  const {gl} = vertexArray;\n\n  let type = 'NOT PROVIDED';\n  let size = 'N/A';\n  let verts = 'N/A';\n  let bytes = 'N/A';\n\n  let isInteger;\n  let marker;\n  let value;\n\n  if (accessor) {\n    type = accessor.type;\n    size = accessor.size;\n\n    // Generate a type name by dropping Array from Float32Array etc.\n    type = String(type).replace('Array', '');\n\n    // Look for 'nt' to detect integer types, e.g. Int32Array, Uint32Array\n    isInteger = type.indexOf('nt') !== -1;\n  }\n\n  if (attribute instanceof Buffer) {\n    const buffer = attribute;\n\n    const {data, modified} = buffer.getDebugData();\n    marker = modified ? '*' : '';\n\n    value = data;\n    bytes = buffer.byteLength;\n    verts = bytes / data.BYTES_PER_ELEMENT / size;\n\n    let format;\n\n    if (accessor) {\n      const instanced = accessor.divisor > 0;\n      format = `${instanced ? 'I ' : 'P '} ${verts} (x${size}=${bytes} bytes ${getKey(gl, type)})`;\n    } else {\n      // element buffer\n      isInteger = true;\n      format = `${bytes} bytes`;\n    }\n\n    return {\n      [header]: `${marker}${formatValue(value, {size, isInteger})}`,\n      'Format ': format\n    };\n  }\n\n  // CONSTANT VALUE\n  value = attribute;\n  size = attribute.length;\n  // Generate a type name by dropping Array from Float32Array etc.\n  type = String(attribute.constructor.name).replace('Array', '');\n  // Look for 'nt' to detect integer types, e.g. Int32Array, Uint32Array\n  isInteger = type.indexOf('nt') !== -1;\n\n  return {\n    [header]: `${formatValue(value, {size, isInteger})} (constant)`,\n    'Format ': `${size}x${type} (constant)`\n  };\n}\n/* eslint-ensable max-statements */\n\nfunction getGLSLDeclaration(name, accessor) {\n  const {type, size} = accessor;\n  const typeAndName = getCompositeGLType(type, size);\n  if (typeAndName) {\n    return `${name} (${typeAndName.name})`;\n  }\n  return name;\n}\n","import {formatValue, assert} from '../utils';\n\n// Prepares a table suitable for console.table\n/* eslint-disable max-statements, complexity */\nexport function getDebugTableForUniforms({\n  header = 'Uniforms',\n  program,\n  uniforms,\n  undefinedOnly = false\n} = {}) {\n  assert(program);\n\n  const SHADER_MODULE_UNIFORM_REGEXP = '.*_.*';\n  const PROJECT_MODULE_UNIFORM_REGEXP = '.*Matrix'; // TODO - Use explicit list\n\n  const uniformLocations = program._uniformSetters;\n  const table = {}; // {[header]: {}};\n\n  // Add program's provided uniforms (in alphabetical order)\n  const uniformNames = Object.keys(uniformLocations).sort();\n\n  let count = 0;\n\n  // First add non-underscored uniforms (assumed not coming from shader modules)\n  for (const uniformName of uniformNames) {\n    if (\n      !uniformName.match(SHADER_MODULE_UNIFORM_REGEXP) &&\n      !uniformName.match(PROJECT_MODULE_UNIFORM_REGEXP)\n    ) {\n      if (addUniformToTable({table, header, uniforms, uniformName, undefinedOnly})) {\n        count++;\n      }\n    }\n  }\n\n  // add underscored uniforms (assumed from shader modules)\n  for (const uniformName of uniformNames) {\n    if (uniformName.match(PROJECT_MODULE_UNIFORM_REGEXP)) {\n      if (addUniformToTable({table, header, uniforms, uniformName, undefinedOnly})) {\n        count++;\n      }\n    }\n  }\n\n  for (const uniformName of uniformNames) {\n    if (!table[uniformName]) {\n      if (addUniformToTable({table, header, uniforms, uniformName, undefinedOnly})) {\n        count++;\n      }\n    }\n  }\n\n  // Create a table of unused uniforms\n  let unusedCount = 0;\n  const unusedTable = {};\n  if (!undefinedOnly) {\n    for (const uniformName in uniforms) {\n      const uniform = uniforms[uniformName];\n      if (!table[uniformName]) {\n        unusedCount++;\n        unusedTable[uniformName] = {\n          Type: `NOT USED: ${uniform}`,\n          [header]: formatValue(uniform)\n        };\n      }\n    }\n  }\n\n  return {table, count, unusedTable, unusedCount};\n}\n\n// Helper\nfunction addUniformToTable({table, header, uniforms, uniformName, undefinedOnly}) {\n  const value = uniforms[uniformName];\n  const isDefined = isUniformDefined(value);\n  if (!undefinedOnly || !isDefined) {\n    table[uniformName] = {\n      // Add program's unprovided uniforms\n      [header]: isDefined ? formatValue(value) : 'N/A',\n      'Uniform Type': isDefined ? value : 'NOT PROVIDED'\n    };\n    return true;\n  }\n  return false;\n}\n\nfunction isUniformDefined(value) {\n  return value !== undefined && value !== null;\n}\n","import {getCompositeGLType} from '../webgl-utils/attribute-utils';\n\nexport function getDebugTableForProgramConfiguration(config) {\n  const table = {};\n\n  const header = `Accessors for ${config.id}`;\n\n  for (const attributeInfo of config.attributeInfos) {\n    if (attributeInfo) {\n      const glslDeclaration = getGLSLDeclaration(attributeInfo);\n      table[`in ${glslDeclaration}`] = {[header]: JSON.stringify(attributeInfo.accessor)};\n    }\n  }\n\n  for (const varyingInfo of config.varyingInfos) {\n    if (varyingInfo) {\n      const glslDeclaration = getGLSLDeclaration(varyingInfo);\n      table[`out ${glslDeclaration}`] = {[header]: JSON.stringify(varyingInfo.accessor)};\n    }\n  }\n\n  return table;\n}\n\nfunction getGLSLDeclaration(attributeInfo) {\n  const {type, size} = attributeInfo.accessor;\n  const typeAndName = getCompositeGLType(type, size);\n  if (typeAndName) {\n    return `${typeAndName.name} ${attributeInfo.name}`;\n  }\n  return attributeInfo.name;\n}\n","import seer from 'seer';\n\nimport {window} from '../utils';\n\nconst models = {};\n\n/**\n * Add a model to our cache indexed by id\n */\nexport const addModel = model => {\n  if (models[model.id]) {\n    return;\n  }\n  models[model.id] = model;\n\n  seer.listItem('luma.gl', model.id);\n};\n\n/**\n * Log a model uniforms and attributes.\n */\nexport const logModel = (model, uniforms) => {\n  if (!seer.isReady() || seer.throttle(`luma.gl:${model.id}`, 1e3)) {\n    return;\n  }\n\n  const attributesObject = model.geometry\n    ? Object.assign({}, model.geometry.attributes, model.attributes)\n    : model.attributes;\n  const uniformsObject = Object.assign({}, model.uniforms, uniforms);\n\n  seer.multiUpdate('luma.gl', model.id, [\n    {path: 'objects.uniforms', data: uniformsObject},\n    {path: 'objects.attributes', data: attributesObject}\n  ]);\n};\n\n/**\n * Remove a previously set model from the cache\n */\nexport const removeModel = id => {\n  delete models[id];\n  seer.deleteItem('luma.gl', id);\n};\n\n/**\n * Recursively traverse an object given a path of properties and set the given value\n */\nconst recursiveSet = (obj, path, value) => {\n  if (!obj) {\n    return;\n  }\n\n  if (path.length > 1) {\n    recursiveSet(obj[path[0]], path.slice(1), value);\n  } else {\n    obj[path[0]] = value;\n  }\n};\n\nconst overrides = new Map();\n\n/**\n * Create an override on the specify layer, indexed by a valuePath array.\n * Do nothing in case Seer as not been initialized to prevent any preformance drawback.\n */\nexport const setOverride = (id, valuePath, value) => {\n  if (!window.__SEER_INITIALIZED__) {\n    return;\n  }\n\n  if (!overrides.has(id)) {\n    overrides.set(id, new Map());\n  }\n\n  const uniforms = overrides.get(id);\n  uniforms.set(valuePath, value);\n};\n\n/**\n * Apply overrides to a specific model's uniforms\n */\nexport const getOverrides = (id, uniforms) => {\n  if (!window.__SEER_INITIALIZED__ || !id) {\n    return;\n  }\n\n  const overs = overrides.get(id);\n  if (!overs) {\n    return;\n  }\n\n  overs.forEach((value, valuePath) => {\n    recursiveSet(uniforms, valuePath, value);\n  });\n};\n\n/**\n * Listen for luma.gl edit events\n */\nseer.listenFor('luma.gl', payload => {\n  const model = models[payload.itemKey];\n  if (!model || payload.type !== 'edit' || payload.valuePath[0] !== 'uniforms') {\n    return;\n  }\n\n  const valuePath = payload.valuePath.slice(1);\n  setOverride(payload.itemKey, valuePath, payload.value);\n\n  const uniforms = model.getUniforms();\n  recursiveSet(uniforms, valuePath, payload.value);\n  model.setUniforms(uniforms);\n});\n","// Shared code between Model and MeshModel\n\nimport GL from '@luma.gl/constants';\nimport {isWebGL, Query, Program, VertexArray} from '@luma.gl/webgl';\nimport {MODULAR_SHADERS, assembleShaders} from '@luma.gl/shadertools';\nimport {\n  getDebugTableForUniforms,\n  getDebugTableForVertexArray,\n  getDebugTableForProgramConfiguration\n} from '@luma.gl/webgl';\nimport {addModel, removeModel, logModel, getOverrides} from '../debug/seer-integration';\nimport {log, isObjectEmpty, uid, assert} from '../utils';\n\nconst LOG_DRAW_PRIORITY = 2;\nconst LOG_DRAW_TIMEOUT = 10000;\n\n// Model abstract O3D Class\nexport default class BaseModel {\n  constructor(gl, props = {}) {\n    assert(isWebGL(gl));\n    const {id = uid('base-model')} = props;\n    this.id = id;\n    this.gl = gl;\n    this.id = props.id || uid('Model');\n    this.lastLogTime = 0; // TODO - move to probe.gl\n    this.initialize(props);\n    this._setBaseModelProps(props);\n  }\n\n  initialize(props) {\n    this.props = {};\n    this.program = this._createProgram(props);\n\n    // Create a vertex array configured after this program\n    this.vertexArray = new VertexArray(this.gl, {program: this.program});\n\n    // Initialize state\n    this.userData = {};\n    this.needsRedraw = true;\n\n    // Attributes and buffers\n    // Model manages auto Buffer creation from typed arrays\n    this._attributes = {}; // All attributes\n    this.attributes = {}; // User defined attributes\n\n    // Model manages uniform animation\n    this.animatedUniforms = {};\n    this.animated = false;\n    this.animationLoop = null; // if set, used as source for animationProps\n\n    this.timerQueryEnabled = false;\n    this.timeElapsedQuery = undefined;\n    this.lastQueryReturned = true;\n\n    this.stats = {\n      accumulatedFrameTime: 0,\n      averageFrameTime: 0,\n      profileFrameCount: 0\n    };\n\n    // picking options\n    this.pickable = true;\n\n    this._setBaseModelProps(props);\n\n    // Make sure we have some reasonable default uniforms in place\n    this.setUniforms(\n      Object.assign(\n        {},\n        this.getModuleUniforms(), // Get all default uniforms\n        this.getModuleUniforms(props.moduleSettings) // Get unforms for supplied parameters\n      )\n    );\n  }\n\n  setProps(props) {\n    this._setBaseModelProps(props);\n  }\n\n  delete() {\n    // delete all attributes created by this model\n    // TODO - should buffer deletes be handled by vertex array?\n    for (const key in this._attributes) {\n      if (this._attributes[key] !== this.attributes[key]) {\n        this._attributes[key].delete();\n      }\n    }\n\n    this.program.delete();\n    this.vertexArray.delete();\n\n    removeModel(this.id);\n  }\n\n  // GETTERS\n\n  isAnimated() {\n    return this.animated;\n  }\n\n  getProgram() {\n    return this.program;\n  }\n\n  getUniforms() {\n    return this.program.uniforms;\n  }\n\n  // SETTERS\n\n  // TODO - should actually set the uniforms\n  setUniforms(uniforms = {}) {\n    // Let Seer override edited uniforms\n    uniforms = Object.assign({}, uniforms);\n    getOverrides(this.id, uniforms);\n\n    // Resolve any animated uniforms so that we have an initial value\n    uniforms = this._extractAnimatedUniforms(uniforms);\n\n    this.program.setUniforms(uniforms);\n\n    return this;\n  }\n\n  updateModuleSettings(opts) {\n    const uniforms = this.getModuleUniforms(opts || {});\n    return this.setUniforms(uniforms);\n  }\n\n  // DRAW CALLS\n\n  /* eslint-disable max-statements  */\n  drawGeometry(opts = {}) {\n    const {\n      moduleSettings = null,\n      framebuffer,\n      uniforms = {},\n      attributes = {},\n      transformFeedback = this.transformFeedback,\n      parameters = {},\n      vertexArray = this.vertexArray,\n      animationProps\n    } = opts;\n\n    // Update module settings\n\n    addModel(this);\n\n    // Update model with any just provided attributes, settings or uniforms\n    this.setAttributes(attributes);\n    this.updateModuleSettings(moduleSettings);\n    this.setUniforms(uniforms);\n\n    // Animate any function valued uniforms\n    this._refreshAnimationProps(animationProps);\n\n    const logPriority = this._logDrawCallStart(2);\n\n    const drawParams = this.vertexArray.getDrawParams(this.props);\n    if (drawParams.isInstanced && !this.isInstanced) {\n      log.warn('Found instanced attributes on non-instanced model', this.id)();\n    }\n\n    const {isIndexed, indexType, indexOffset} = drawParams;\n    const {isInstanced, instanceCount} = this;\n\n    const noop = () => {};\n    const {onBeforeRender = noop, onAfterRender = noop} = this.props;\n\n    onBeforeRender();\n\n    this._timerQueryStart();\n\n    const didDraw = this.program.draw(\n      Object.assign({}, opts, {\n        logPriority,\n        uniforms: null, // Already set (may contain \"function values\" not understood by Program)\n        framebuffer,\n        parameters,\n        drawMode: this.getDrawMode(),\n        vertexCount: this.getVertexCount(),\n        vertexArray,\n        transformFeedback,\n        isIndexed,\n        indexType,\n        isInstanced,\n        instanceCount,\n        offset: isIndexed ? indexOffset : 0\n      })\n    );\n\n    this._timerQueryEnd();\n\n    onAfterRender();\n\n    this._logDrawCallEnd(logPriority, vertexArray, framebuffer);\n\n    return didDraw;\n  }\n  /* eslint-enable max-statements  */\n\n  // PRIVATE METHODS\n\n  // eslint-disable-next-line max-statements, complexity\n  _setBaseModelProps(props) {\n    Object.assign(this.props, props);\n\n    if ('uniforms' in props) {\n      this.setUniforms(props.uniforms);\n    }\n\n    if ('pickable' in props) {\n      this.pickable = props.pickable;\n    }\n\n    // if ('onBeforeRender' in props) {}\n    // if ('onAfterRender' in props) {}\n\n    // Experimental props\n    if ('timerQueryEnabled' in props) {\n      this.timerQueryEnabled = props.timerQueryEnabled && Query.isSupported(this.gl, ['timers']);\n      if (props.timerQueryEnabled && !this.timerQueryEnabled) {\n        log.warn('GPU timer not supported')();\n      }\n    }\n\n    if ('_animationProps' in props) {\n      this._setAnimationProps(props._animationProps);\n    }\n\n    if ('_animationLoop' in props) {\n      this.animationLoop = props._animationLoop;\n    }\n  }\n\n  _createProgram({\n    vs = null,\n    fs = null,\n    // 1: Modular shaders\n    modules = null,\n    defines = {},\n    inject = {},\n    shaderCache = null,\n    // TransformFeedback\n    varyings = null,\n    bufferMode = GL.SEPARATE_ATTRIBS,\n    program = null\n  }) {\n    this.getModuleUniforms = x => {};\n\n    const id = this.id;\n\n    if (!program) {\n      // Assign default shaders if none are provided\n      vs = vs || MODULAR_SHADERS.vs;\n      fs = fs || MODULAR_SHADERS.fs;\n\n      const assembleResult = assembleShaders(this.gl, {vs, fs, modules, inject, defines, log});\n      ({vs, fs} = assembleResult);\n\n      if (shaderCache) {\n        program = shaderCache.getProgram(this.gl, {id, vs, fs});\n      } else {\n        program = new Program(this.gl, {id, vs, fs, varyings, bufferMode});\n      }\n\n      this.getModuleUniforms = assembleResult.getUniforms || (x => {});\n    }\n\n    assert(program instanceof Program, 'Model needs a program');\n    return program;\n  }\n\n  // Refreshes animated uniforms, attempting to get animated props from animationLoop if registered\n  _refreshAnimationProps(animationProps) {\n    // Try to read animationProps\n    animationProps = animationProps || (this.animationLoop && this.animationLoop.animationProps);\n    if (animationProps) {\n      this._setAnimationProps(animationProps);\n    }\n  }\n\n  // Calculate new values for any function uniforms based on supplied animationProps\n  _evaluateAnimateUniforms(animationProps) {\n    if (!this.animated) {\n      return {};\n    }\n    const animatedUniforms = {};\n    for (const uniformName in this.animatedUniforms) {\n      const valueFunction = this.animatedUniforms[uniformName];\n      animatedUniforms[uniformName] = valueFunction(animationProps);\n    }\n    return animatedUniforms;\n  }\n\n  // Extracts a list of function valued uniforms, so we can update them before each draw call\n  // Also removes such uniforms from the returned list\n  _extractAnimatedUniforms(uniforms) {\n    let foundAnimated = false;\n\n    // Keep our animatedUniforms map up-to-date\n    for (const uniformName in uniforms) {\n      const newValue = uniforms[uniformName];\n      if (typeof newValue === 'function') {\n        this.animatedUniforms[uniformName] = newValue;\n        foundAnimated = true;\n      } else {\n        delete this.animatedUniforms[uniformName];\n      }\n    }\n\n    // Update animated flag: `Model` is animated if any uniforms are animated (i.e. functions)\n    this.animated = !isObjectEmpty(this.animatedUniforms);\n\n    if (!foundAnimated) {\n      return uniforms;\n    }\n\n    // If animated uniforms were found, remove them from ordinary uniform list\n    // `Program` class can't (and shouldn't) handle function valued uniforms\n    const staticUniforms = {};\n    for (const uniformName in uniforms) {\n      if (!this.animatedUniforms[uniformName]) {\n        staticUniforms[uniformName] = uniforms[uniformName];\n      }\n    }\n    return staticUniforms;\n  }\n\n  // Timer Queries\n\n  _timerQueryStart() {\n    if (this.timerQueryEnabled === true) {\n      if (!this.timeElapsedQuery) {\n        this.timeElapsedQuery = new Query(this.gl);\n      }\n      if (this.lastQueryReturned) {\n        this.lastQueryReturned = false;\n        this.timeElapsedQuery.beginTimeElapsedQuery();\n      }\n    }\n  }\n\n  _timerQueryEnd() {\n    if (this.timerQueryEnabled === true) {\n      this.timeElapsedQuery.end();\n      // TODO: Skip results if 'gl.getParameter(this.ext.GPU_DISJOINT_EXT)' returns false\n      // should this be incorporated into Query object?\n      if (this.timeElapsedQuery.isResultAvailable()) {\n        this.lastQueryReturned = true;\n        const elapsedTime = this.timeElapsedQuery.getTimerMilliseconds();\n\n        // Update stats (e.g. for seer)\n        this.stats.lastFrameTime = elapsedTime;\n        this.stats.accumulatedFrameTime += elapsedTime;\n        this.stats.profileFrameCount++;\n        this.stats.averageFrameTime =\n          this.stats.accumulatedFrameTime / this.stats.profileFrameCount;\n\n        // Log stats\n        log.log(\n          LOG_DRAW_PRIORITY,\n          `\\\nGPU time ${this.program.id}: ${this.stats.lastFrameTime}ms \\\naverage ${this.stats.averageFrameTime}ms \\\naccumulated: ${this.stats.accumulatedFrameTime}ms \\\ncount: ${this.stats.profileFrameCount}`\n        )();\n      }\n    }\n  }\n\n  _logDrawCallStart(priority) {\n    const logDrawTimeout = priority > 3 ? 0 : LOG_DRAW_TIMEOUT;\n    if (log.priority < priority || Date.now() - this.lastLogTime < logDrawTimeout) {\n      return undefined;\n    }\n\n    this.lastLogTime = Date.now();\n\n    log.group(LOG_DRAW_PRIORITY, `>>> DRAWING MODEL ${this.id}`, {collapsed: log.priority <= 2})();\n\n    return priority;\n  }\n\n  _logDrawCallEnd(priority, vertexArray, uniforms, framebuffer) {\n    // HACK: priority === undefined means logDrawCallStart didn't run\n    if (priority === undefined) {\n      return;\n    }\n\n    const attributeTable = getDebugTableForVertexArray({\n      vertexArray,\n      header: `${this.id} attributes`,\n      attributes: this._attributes\n    });\n\n    const {table: uniformTable, unusedTable, unusedCount} = getDebugTableForUniforms({\n      header: `${this.id} uniforms`,\n      program: this.program,\n      uniforms: Object.assign({}, this.program.uniforms, uniforms)\n    });\n\n    // log missing uniforms\n    const {table: missingTable, count: missingCount} = getDebugTableForUniforms({\n      header: `${this.id} uniforms`,\n      program: this.program,\n      uniforms: Object.assign({}, this.program.uniforms, uniforms),\n      undefinedOnly: true\n    });\n\n    if (missingCount > 0) {\n      log.log('MISSING UNIFORMS', Object.keys(missingTable))();\n      // log.table(priority, missingTable)();\n    }\n    if (unusedCount > 0) {\n      log.log('UNUSED UNIFORMS', Object.keys(unusedTable))();\n      // log.log(priority, 'Unused uniforms ', unusedTable)();\n    }\n\n    const configTable = getDebugTableForProgramConfiguration(this.vertexArray.configuration);\n\n    log.table(priority, attributeTable)();\n\n    log.table(priority, uniformTable)();\n\n    log.table(priority + 1, configTable)();\n\n    logModel(this, uniforms);\n\n    if (framebuffer) {\n      framebuffer.log({priority: LOG_DRAW_PRIORITY, message: `Rendered to ${framebuffer.id}`});\n    }\n\n    log.groupEnd(LOG_DRAW_PRIORITY, `>>> DRAWING MODEL ${this.id}`)();\n  }\n}\n","import GL from '@luma.gl/constants';\nimport {TransformFeedback, Buffer} from '@luma.gl/webgl';\nimport {getBuffersFromGeometry} from './model-utils';\nimport BaseModel from './base-model';\nimport {log, isObjectEmpty, uid, assert} from '../utils';\n\nconst ERR_MODEL_PARAMS = 'Model needs drawMode and vertexCount';\n\nexport default class Model extends BaseModel {\n  constructor(gl, props = {}) {\n    // Deduce a helpful id\n    const {id = uid('model')} = props;\n    super(gl, {...props, id});\n  }\n\n  initialize(props) {\n    super.initialize(props);\n\n    this.drawMode = props.drawMode !== undefined ? props.drawMode : GL.TRIANGLES;\n    this.vertexCount = props.vertexCount || 0;\n\n    // Track buffers created by setGeometry\n    this.geometryBuffers = {};\n\n    // geometry might have set drawMode and vertexCount\n    this.isInstanced = props.isInstanced || props.instanced;\n\n    this._setModelProps(props);\n\n    // TODO - just to unbreak deck.gl 7.0-beta, remove as soon as updated\n    this.geometry = {};\n\n    // assert(program || program instanceof Program);\n    assert(this.drawMode !== undefined && Number.isFinite(this.vertexCount), ERR_MODEL_PARAMS);\n  }\n\n  setProps(props) {\n    super.setProps(props);\n    this._setModelProps(props);\n  }\n\n  delete() {\n    super.delete();\n\n    this._deleteGeometryBuffers();\n  }\n\n  // GETTERS\n\n  getDrawMode() {\n    return this.drawMode;\n  }\n\n  getVertexCount() {\n    return this.vertexCount;\n  }\n\n  getInstanceCount() {\n    return this.instanceCount;\n  }\n\n  getAttributes() {\n    return this.attributes;\n  }\n\n  // SETTERS\n\n  setDrawMode(drawMode) {\n    this.drawMode = drawMode;\n    return this;\n  }\n\n  setVertexCount(vertexCount) {\n    assert(Number.isFinite(vertexCount));\n    this.vertexCount = vertexCount;\n    return this;\n  }\n\n  setInstanceCount(instanceCount) {\n    assert(Number.isFinite(instanceCount));\n    this.instanceCount = instanceCount;\n    return this;\n  }\n\n  setGeometry(geometry) {\n    this.drawMode = geometry.drawMode;\n    this.vertexCount = geometry.getVertexCount();\n\n    this._deleteGeometryBuffers();\n\n    this.geometryBuffers = getBuffersFromGeometry(this.gl, geometry);\n    this.vertexArray.setAttributes(this.geometryBuffers);\n    return this;\n  }\n\n  setAttributes(attributes = {}) {\n    // Avoid setting needsRedraw if no attributes\n    if (isObjectEmpty(attributes)) {\n      return this;\n    }\n\n    const normalizedAttributes = {};\n    for (const name in attributes) {\n      const attribute = attributes[name];\n      // The `getValue` call provides support for deck.gl `Attribute` class\n      // TODO - remove once deck refactoring completes\n      normalizedAttributes[name] = attribute.getValue ? attribute.getValue() : attribute;\n    }\n\n    this.vertexArray.setAttributes(normalizedAttributes);\n    return this;\n  }\n\n  // DRAW CALLS\n\n  draw(options = {}) {\n    return this.drawGeometry(options);\n  }\n\n  // Draw call for transform feedback\n  transform(opts = {}) {\n    const {discard = true, feedbackBuffers, unbindModels = []} = opts;\n\n    let {parameters} = opts;\n\n    if (feedbackBuffers) {\n      this._setFeedbackBuffers(feedbackBuffers);\n    }\n\n    if (discard) {\n      parameters = Object.assign({}, parameters, {[GL.RASTERIZER_DISCARD]: discard});\n    }\n\n    unbindModels.forEach(model => model.vertexArray.unbindBuffers());\n    try {\n      this.draw(Object.assign({}, opts, {parameters}));\n    } finally {\n      unbindModels.forEach(model => model.vertexArray.bindBuffers());\n    }\n\n    return this;\n  }\n\n  // DEPRECATED METHODS\n\n  render(uniforms = {}) {\n    log.warn('Model.render() is deprecated. Use Model.setUniforms() and Model.draw()')();\n    return this.setUniforms(uniforms).draw();\n  }\n\n  // PRIVATE METHODS\n\n  _setModelProps(props) {\n    // params\n    // if ('drawMode' in props) {\n    //   this.drawMode = getDrawMode(props.drawMode);\n    // }\n    // if ('vertexCount' in props) {\n    //   this.vertexCount = props.vertexCount;\n    // }\n    if ('instanceCount' in props) {\n      this.instanceCount = props.instanceCount;\n    }\n    if ('geometry' in props) {\n      this.setGeometry(props.geometry);\n    }\n\n    // webgl settings\n    if ('attributes' in props) {\n      this.setAttributes(props.attributes);\n    }\n    if ('_feedbackBuffers' in props) {\n      this._setFeedbackBuffers(props._feedbackBuffers);\n    }\n  }\n\n  _deleteGeometryBuffers() {\n    for (const name in this.geometryBuffers) {\n      // Buffer is raw value (for indices) or first element of [buffer, accessor] pair\n      const buffer = this.geometryBuffers[name][0] || this.geometryBuffers[name];\n      if (buffer instanceof Buffer) {\n        buffer.delete();\n      }\n    }\n  }\n\n  // Updates (evaluates) all function valued uniforms based on a new set of animationProps\n  // experimental\n  _setAnimationProps(animationProps) {\n    if (this.animated) {\n      assert(animationProps, 'Model.draw(): animated uniforms but no animationProps');\n      const animatedUniforms = this._evaluateAnimateUniforms(animationProps);\n      this.program.setUniforms(animatedUniforms);\n    }\n  }\n\n  // Transform Feedback\n\n  _setFeedbackBuffers(feedbackBuffers = {}) {\n    // Avoid setting needsRedraw if no feedbackBuffers\n    if (isObjectEmpty(feedbackBuffers)) {\n      return this;\n    }\n\n    const {gl} = this.program;\n    this.transformFeedback =\n      this.transformFeedback ||\n      new TransformFeedback(gl, {\n        program: this.program\n      });\n\n    this.transformFeedback.setBuffers(feedbackBuffers);\n    return this;\n  }\n}\n","// Transpiles shader source code to target GLSL version\n// Note: We always run transpiler even if same version e.g. 3.00 => 3.00\n// RFC: https://github.com/uber/luma.gl/blob/7.0-release/dev-docs/RFCs/v6.0/portable-glsl-300-rfc.md\nexport default function transpileShader(source, targetGLSLVersion, isVertex) {\n  switch (targetGLSLVersion) {\n    case 300:\n      return isVertex ? convertVertexShaderTo300(source) : convertFragmentShaderTo300(source);\n    case 100:\n      return isVertex ? convertVertexShaderTo100(source) : convertFragmentShaderTo100(source);\n    default:\n      throw new Error(`unknown GLSL version ${targetGLSLVersion}`);\n  }\n}\n\nfunction convertVertexShaderTo300(source) {\n  return source\n    .replace(/attribute\\s+/g, 'in ')\n    .replace(/varying\\s+/g, 'out ')\n    .replace(/texture2D\\(/g, 'texture(')\n    .replace(/textureCube\\(+/g, 'texture(')\n    .replace(/texture2DLodEXT\\(/g, 'textureLod(')\n    .replace(/textureCubeLodEXT\\(/g, 'textureLod(');\n}\n\nfunction convertFragmentShaderTo300(source) {\n  return source\n    .replace(/varying\\s+/g, 'in ')\n    .replace(/texture2D\\(/g, 'texture(')\n    .replace(/textureCube\\(/g, 'texture(')\n    .replace(/texture2DLodEXT\\(/g, 'textureLod(')\n    .replace(/textureCubeLodEXT\\(/g, 'textureLod(');\n\n  // Deal with fragColor\n  // .replace(/gl_fragColor/g, 'fragColor ');\n}\n\nfunction convertVertexShaderTo100(source) {\n  // /gm - treats each line as a string, so that ^ matches after newlines\n  return source\n    .replace(/^in\\s+/gm, 'attribute ')\n    .replace(/^out\\s+/gm, 'varying ')\n    .replace(/texture\\(/g, 'texture2D(');\n}\n\nfunction convertFragmentShaderTo100(source) {\n  // /gm - treats each line as a string, so that ^ matches after newlines\n  return source.replace(/^in\\s+/gm, 'varying ').replace(/texture\\(/g, 'texture2D(');\n\n  // Deal with fragColor\n  // .replace(/^out\\s+/g, 'varying ')\n}\n","const TYPE_DEFINITIONS = {\n  number: {\n    validate(value, propType) {\n      return (\n        Number.isFinite(value) &&\n        (!('max' in propType) || value <= propType.max) &&\n        (!('min' in propType) || value >= propType.min)\n      );\n    }\n  },\n  array: {\n    validate(value, propType) {\n      return Array.isArray(value) || ArrayBuffer.isView(value);\n    }\n  }\n};\n\nexport function parsePropTypes(propDefs) {\n  const propTypes = {};\n  for (const propName in propDefs) {\n    const propDef = propDefs[propName];\n    const propType = parsePropType(propDef);\n    propTypes[propName] = propType;\n  }\n  return propTypes;\n}\n\n// Parses one property definition entry. Either contains:\n// * a valid prop type object ({type, ...})\n// * or just a default value, in which case type and name inference is used\nfunction parsePropType(propDef) {\n  let type = getTypeOf(propDef);\n  if (type === 'object') {\n    if (!propDef) {\n      return {type: 'object', value: null};\n    }\n    if ('type' in propDef) {\n      return Object.assign({}, propDef, TYPE_DEFINITIONS[propDef.type]);\n    }\n    if (!('value' in propDef)) {\n      // If no type and value this object is likely the value\n      return {type: 'object', value: propDef};\n    }\n    type = getTypeOf(propDef.value);\n    return Object.assign({type}, propDef, TYPE_DEFINITIONS[type]);\n  }\n  return Object.assign({type, value: propDef}, TYPE_DEFINITIONS[type]);\n}\n\n// improved version of javascript typeof that can distinguish arrays and null values\nfunction getTypeOf(value) {\n  if (Array.isArray(value) || ArrayBuffer.isView(value)) {\n    return 'array';\n  }\n  return typeof value;\n}\n","import transpileShader from './transpile-shader';\nimport {assert} from '../utils';\nimport {parsePropTypes} from './filters/prop-types';\n\nconst VERTEX_SHADER = 'vs';\nconst FRAGMENT_SHADER = 'fs';\n\nexport default class ShaderModule {\n  constructor({\n    name,\n    vs,\n    fs,\n    dependencies = [],\n    uniforms,\n    getUniforms,\n    deprecations = [],\n    defines = {},\n    // DEPRECATED\n    vertexShader,\n    fragmentShader\n  }) {\n    assert(typeof name === 'string');\n    this.name = name;\n    this.vs = vs || vertexShader;\n    this.fs = fs || fragmentShader;\n    this.getModuleUniforms = getUniforms;\n    this.dependencies = dependencies;\n    this.deprecations = this._parseDeprecationDefinitions(deprecations);\n    this.defines = defines;\n\n    if (uniforms) {\n      this.uniforms = parsePropTypes(uniforms);\n    }\n  }\n\n  // Extracts the source code chunk for the specified shader type from the named shader module\n  getModuleSource(type, targetGLSLVersion) {\n    let moduleSource;\n    switch (type) {\n      case VERTEX_SHADER:\n        moduleSource = transpileShader(this.vs || '', targetGLSLVersion, true);\n        break;\n      case FRAGMENT_SHADER:\n        moduleSource = transpileShader(this.fs || '', targetGLSLVersion, false);\n        break;\n      default:\n        assert(false);\n    }\n\n    return `\\\n#define MODULE_${this.name.toUpperCase()}\n${moduleSource}\\\n// END MODULE_${this.name}\n\n`;\n  }\n\n  getUniforms(opts, uniforms) {\n    if (this.getModuleUniforms) {\n      return this.getModuleUniforms(opts, uniforms);\n    }\n    // Build uniforms from the uniforms array\n    if (this.uniforms) {\n      return this._defaultGetUniforms(opts);\n    }\n    return {};\n  }\n\n  getDefines() {\n    return this.defines;\n  }\n\n  // Warn about deprecated uniforms or functions\n  checkDeprecations(shaderSource, log) {\n    this.deprecations.forEach(def => {\n      if (def.regex.test(shaderSource)) {\n        if (def.deprecated) {\n          log.deprecated(def.old, def.new)();\n        } else {\n          log.removed(def.old, def.new)();\n        }\n      }\n    });\n  }\n\n  _parseDeprecationDefinitions(deprecations) {\n    deprecations.forEach(def => {\n      switch (def.type) {\n        case 'function':\n          def.regex = new RegExp(`\\\\b${def.old}\\\\(`);\n          break;\n        default:\n          def.regex = new RegExp(`${def.type} ${def.old};`);\n      }\n    });\n\n    return deprecations;\n  }\n\n  _defaultGetUniforms(opts = {}) {\n    const uniforms = {};\n    const propTypes = this.uniforms;\n\n    for (const key in propTypes) {\n      const propDef = propTypes[key];\n      if (key in opts && !propDef.private) {\n        if (propDef.validate) {\n          assert(propDef.validate(opts[key], propDef), `${this.name}: invalid ${key}`);\n        }\n        uniforms[key] = opts[key];\n      } else {\n        uniforms[key] = propDef.value;\n      }\n    }\n\n    return uniforms;\n  }\n}\n\n// This utility mutates the original module\n// Keeping for backward compatibility\n// TODO - remove in v8\nexport function normalizeShaderModule(module) {\n  if (!module.normalized) {\n    module.normalized = true;\n    if (module.uniforms && !module.getUniforms) {\n      const shaderModule = new ShaderModule(module);\n      module.getUniforms = shaderModule.getUniforms.bind(shaderModule);\n    }\n  }\n  return module;\n}\n","import {MODULE_INJECTORS_VS, MODULE_INJECTORS_FS} from '../modules/module-injectors';\nimport {VERTEX_SHADER, FRAGMENT_SHADER} from './constants';\nimport {assert} from '../utils';\n\n// TODO - experimental\nconst MODULE_INJECTORS = {\n  [VERTEX_SHADER]: MODULE_INJECTORS_VS,\n  [FRAGMENT_SHADER]: MODULE_INJECTORS_FS\n};\n\nexport const DECLARATION_INJECT_MARKER = '__LUMA_INJECT_DECLARATIONS__'; // Uniform/attribute declarations\n\nconst REGEX_START_OF_MAIN = /void main\\s*\\([^)]*\\)\\s*\\{\\n?/; // Beginning of main\nconst REGEX_END_OF_MAIN = /}\\n?[^{}]*$/; // End of main, assumes main is last function\nconst fragments = [];\n\n// A minimal shader injection/templating system.\n// RFC: https://github.com/uber/luma.gl/blob/7.0-release/dev-docs/RFCs/v6.0/shader-injection-rfc.md\n/* eslint-disable complexity */\nexport default function injectShader(source, type, inject, injectStandardStubs) {\n  const isVertex = type === VERTEX_SHADER;\n\n  for (const key in inject) {\n    const fragmentData = inject[key];\n    fragmentData.sort((a, b) => a.order - b.order);\n    fragments.length = fragmentData.length;\n    for (let i = 0, len = fragmentData.length; i < len; ++i) {\n      fragments[i] = fragmentData[i].injection;\n    }\n    const fragmentString = `${fragments.join('\\n')}\\n`;\n    switch (key) {\n      // declarations are injected before the main function\n      case 'vs:#decl':\n        if (isVertex) {\n          source = source.replace(DECLARATION_INJECT_MARKER, fragmentString);\n        }\n        break;\n      // main code is injected at the end of main function\n      case 'vs:#main-start':\n        if (isVertex) {\n          source = source.replace(REGEX_START_OF_MAIN, match => match + fragmentString);\n        }\n        break;\n      case 'vs:#main-end':\n        if (isVertex) {\n          source = source.replace(REGEX_END_OF_MAIN, match => fragmentString + match);\n        }\n        break;\n      case 'fs:#decl':\n        if (!isVertex) {\n          source = source.replace(DECLARATION_INJECT_MARKER, fragmentString);\n        }\n        break;\n      case 'fs:#main-start':\n        if (!isVertex) {\n          source = source.replace(REGEX_START_OF_MAIN, match => match + fragmentString);\n        }\n        break;\n      case 'fs:#main-end':\n        if (!isVertex) {\n          source = source.replace(REGEX_END_OF_MAIN, match => fragmentString + match);\n        }\n        break;\n\n      default:\n        // TODO(Tarek): I think this usage should be deprecated.\n\n        // inject code after key, leaving key in place\n        source = source.replace(key, match => match + fragmentString);\n    }\n  }\n\n  // Remove if it hasn't already been replaced\n  source = source.replace(DECLARATION_INJECT_MARKER, '');\n\n  // Finally, if requested, insert an automatic module injector chunk\n  if (injectStandardStubs) {\n    source = source.replace(/\\}\\s*$/, match => match + MODULE_INJECTORS[type]);\n  }\n\n  return source;\n}\n\n/* eslint-enable complexity */\n\n// Takes an array of inject objects and combines them into one\nexport function combineInjects(injects) {\n  const result = {};\n  assert(Array.isArray(injects) && injects.length > 1);\n  injects.forEach(inject => {\n    for (const key in inject) {\n      result[key] = result[key] ? `${result[key]}\\n${inject[key]}` : inject[key];\n    }\n  });\n  return result;\n}\n","export const MODULE_INJECTORS_VS = `\\\n#ifdef MODULE_LOGDEPTH\n  logdepth_adjustPosition(gl_Position);\n#endif\n`;\n\nexport const MODULE_INJECTORS_FS = `\\\n#ifdef MODULE_MATERIAL\n  gl_FragColor = material_filterColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_LIGHTING\n  gl_FragColor = lighting_filterColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_FOG\n  gl_FragColor = fog_filterColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_PICKING\n  gl_FragColor = picking_filterHighlightColor(gl_FragColor);\n  gl_FragColor = picking_filterPickingColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_LOGDEPTH\n  logdepth_setFragDepth();\n#endif\n`;\n","export const VERTEX_SHADER = 'vs';\nexport const FRAGMENT_SHADER = 'fs';\n","// shadertools exports\n\n// DEFAULT SHADERS\n// A set of base shaders that leverage the shader module system,\n// dynamically enabling features depending on which modules are included\nimport MODULAR_VS from './shaders/modular-vertex.glsl';\nimport MODULAR_FS from './shaders/modular-fragment.glsl';\n\n// DOCUMENTED APIS\nexport {\n  registerShaderModules,\n  setDefaultShaderModules,\n  getDefaultShaderModules\n} from './lib/resolve-modules';\nexport {assembleShaders, createShaderHook, createModuleInjection} from './lib/assemble-shaders';\n\n// HELPERS\nexport {combineInjects} from './lib/inject-shader';\nexport {normalizeShaderModule} from './lib/shader-module';\n\n// UTILS\nexport {\n  getQualifierDetails,\n  getPassthroughFS,\n  typeToChannelSuffix,\n  typeToChannelCount,\n  convertToVec4\n} from './utils/shader-utils';\n\n// SHADER MODULES\nexport * from './modules';\n\nexport const MODULAR_SHADERS = {\n  vs: MODULAR_VS,\n  fs: MODULAR_FS,\n  uniforms: {}\n};\n","export default `\\\n#define SHADER_NAME luma_modular_vertex\n\n// object attributes\nattribute vec3 positions;\nattribute vec3 normals;\nattribute vec4 colors;\nattribute vec2 texCoords;\nattribute vec3 pickingColors;\n\nvoid main(void) {\n\n  // Set up position\n#ifdef MODULE_GEOMETRY\n  geometry_setPosition(positions);\n  geometry_setNormal(normals);\n#endif\n\n#ifdef MODULE_PROJECT\n  project_setPositionAndNormal_Model(positions, normals);\n  gl_Position = project_model_to_clipspace(positions);\n#endif\n\n  // Set up depth\n#ifdef MODULE_LOGDEPTH\n  logdepth_adjustPosition(gl_Position);\n#endif\n\n#ifdef MODULE_DIFFUSE\n  diffuse_setTextureCoordinate(texCoords);\n#endif\n\n  // Set up color calculations\n#ifdef MODULE_MATERIAL\n  material_setDiffuseColor(colors);\n  material_setDiffuseTextureCoordinates(texCoords);\n#endif\n\n#ifdef MODULE_LIGHTING\n  lighting_setPositionAndNormal(positions, normals);\n  lighting_apply_light(positions);\n  lighting_apply_reflection(positions);\n#endif\n\n#ifdef MODULE_PICKING\n  picking_setPickingColor(pickingColors);\n#endif\n\n}\n`;\n","export default `\\\n#define SHADER_NAME luma-modular-fragment\n\nprecision highp float;\n\n// varyings\nvarying vec4 vColor;\n\nvoid main(){\n  gl_FragColor = vec4(1., 0., 1., 1.);\n\n#ifdef MODULE_DIFFUSE\n  gl_FragColor = diffuse_filterColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_MATERIAL\n  gl_FragColor = material_filterColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_LIGHTING\n  gl_FragColor = lighting_filterColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_FOG\n  gl_FragColor = fog_filterColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_PICKING\n  gl_FragColor = picking_filterHighlightColor(gl_FragColor);\n  gl_FragColor = picking_filterPickingColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_LOGDEPTH\n  logdepth_setFragDepth(gl_Position);\n#endif\n}\n`;\n","// Recommendation is to ignore message but current test suite checks agains the\n// message so keep it for now.\nexport default function assert(condition, message) {\n  if (!condition) {\n    throw new Error(message || 'shadertools: assertion failed.');\n  }\n}\n","import Geometry from '../geometry/geometry';\nimport {uid} from '../utils';\n\nexport default class SphereGeometry extends Geometry {\n  constructor(props = {}) {\n    const {id = uid('sphere-geometry')} = props;\n    const {indices, attributes} = tesselateSphere(props);\n    super({\n      ...props,\n      id,\n      indices,\n      attributes: {...attributes, ...props.attributes}\n    });\n  }\n}\n\n// Primitives inspired by TDL http://code.google.com/p/webglsamples/,\n// copyright 2011 Google Inc. new BSD License\n// (http://www.opensource.org/licenses/bsd-license.php).\n/* eslint-disable max-statements, complexity */\nfunction tesselateSphere(props) {\n  const {nlat = 10, nlong = 10} = props;\n  let {radius = 1} = props;\n\n  const startLat = 0;\n  const endLat = Math.PI;\n  const latRange = endLat - startLat;\n  const startLong = 0;\n  const endLong = 2 * Math.PI;\n  const longRange = endLong - startLong;\n  const numVertices = (nlat + 1) * (nlong + 1);\n\n  if (typeof radius === 'number') {\n    const value = radius;\n    radius = (n1, n2, n3, u, v) => value;\n  }\n\n  const positions = new Float32Array(numVertices * 3);\n  const normals = new Float32Array(numVertices * 3);\n  const texCoords = new Float32Array(numVertices * 2);\n  const indices = new Uint16Array(nlat * nlong * 6);\n\n  // Create positions, normals and texCoords\n  for (let y = 0; y <= nlat; y++) {\n    for (let x = 0; x <= nlong; x++) {\n      const u = x / nlong;\n      const v = y / nlat;\n\n      const index = x + y * (nlong + 1);\n      const i2 = index * 2;\n      const i3 = index * 3;\n\n      const theta = longRange * u;\n      const phi = latRange * v;\n      const sinTheta = Math.sin(theta);\n      const cosTheta = Math.cos(theta);\n      const sinPhi = Math.sin(phi);\n      const cosPhi = Math.cos(phi);\n      const ux = cosTheta * sinPhi;\n      const uy = cosPhi;\n      const uz = sinTheta * sinPhi;\n\n      const r = radius(ux, uy, uz, u, v);\n\n      positions[i3 + 0] = r * ux;\n      positions[i3 + 1] = r * uy;\n      positions[i3 + 2] = r * uz;\n\n      normals[i3 + 0] = ux;\n      normals[i3 + 1] = uy;\n      normals[i3 + 2] = uz;\n\n      texCoords[i2 + 0] = u;\n      texCoords[i2 + 1] = 1 - v;\n    }\n  }\n\n  // Create indices\n  const numVertsAround = nlat + 1;\n  for (let x = 0; x < nlat; x++) {\n    for (let y = 0; y < nlong; y++) {\n      const index = (x * nlong + y) * 6;\n\n      indices[index + 0] = y * numVertsAround + x;\n      indices[index + 1] = y * numVertsAround + x + 1;\n      indices[index + 2] = (y + 1) * numVertsAround + x;\n\n      indices[index + 3] = (y + 1) * numVertsAround + x;\n      indices[index + 4] = y * numVertsAround + x + 1;\n      indices[index + 5] = (y + 1) * numVertsAround + x + 1;\n    }\n  }\n\n  return {\n    indices: {size: 1, value: indices},\n    attributes: {\n      POSITION: {size: 3, value: positions},\n      NORMAL: {size: 3, value: normals},\n      TEXCOORD_0: {size: 2, value: texCoords}\n    }\n  };\n}\n","import GL from '@luma.gl/constants';\nimport Resource from './resource';\nimport Buffer from './buffer';\nimport {isWebGL2, assertWebGL2Context} from '../webgl-utils';\nimport {log, isObjectEmpty} from '../utils';\n\n// NOTE: The `bindOnUse` flag is a major workaround:\n// See https://github.com/KhronosGroup/WebGL/issues/2346\n\nexport default class TransformFeedback extends Resource {\n  static isSupported(gl) {\n    return isWebGL2(gl);\n  }\n\n  constructor(gl, props = {}) {\n    assertWebGL2Context(gl);\n    super(gl, props);\n\n    this.initialize(props);\n    this.stubRemovedMethods('TransformFeedback', 'v6.0', ['pause', 'resume']);\n    Object.seal(this);\n  }\n\n  initialize(props = {}) {\n    this.buffers = {};\n    this.unused = {};\n    this.configuration = null;\n    this.bindOnUse = true;\n\n    // Unbind any currently bound buffers\n    if (!isObjectEmpty(this.buffers)) {\n      this.bind(() => this._unbindBuffers());\n    }\n\n    this.setProps(props);\n    return this;\n  }\n\n  setProps(props) {\n    if ('program' in props) {\n      this.configuration = props.program && props.program.configuration;\n    }\n    if ('configuration' in props) {\n      this.configuration = props.configuration;\n    }\n    if ('bindOnUse' in props) {\n      props = props.bindOnUse;\n    }\n    if ('buffers' in props) {\n      this.setBuffers(props.buffers);\n    }\n  }\n\n  setBuffers(buffers = {}) {\n    this.bind(() => {\n      for (const bufferName in buffers) {\n        this.setBuffer(bufferName, buffers[bufferName]);\n      }\n    });\n    return this;\n  }\n\n  setBuffer(locationOrName, bufferOrParams) {\n    const location = this._getVaryingIndex(locationOrName);\n    const {buffer, byteSize, byteOffset} = this._getBufferParams(bufferOrParams);\n\n    if (location < 0) {\n      this.unused[locationOrName] = buffer;\n      log.warn(() => `${this.id} unused varying buffer ${locationOrName}`)();\n      return this;\n    }\n\n    this.buffers[location] = bufferOrParams;\n\n    // Need to avoid chrome bug where buffer that is already bound to a different target\n    // cannot be bound to 'TRANSFORM_FEEDBACK_BUFFER' target.\n    if (!this.bindOnUse) {\n      this._bindBuffer(location, buffer, byteOffset, byteSize);\n    }\n\n    return this;\n  }\n\n  begin(primitiveMode = GL.POINTS) {\n    this.gl.bindTransformFeedback(GL.TRANSFORM_FEEDBACK, this.handle);\n    this._bindBuffers();\n    this.gl.beginTransformFeedback(primitiveMode);\n    return this;\n  }\n\n  end() {\n    this.gl.endTransformFeedback();\n    this._unbindBuffers();\n    this.gl.bindTransformFeedback(GL.TRANSFORM_FEEDBACK, null);\n    return this;\n  }\n\n  // PRIVATE METHODS\n\n  _getBufferParams(bufferOrParams) {\n    let byteOffset;\n    let byteSize;\n    let buffer;\n    if (bufferOrParams instanceof Buffer === false) {\n      buffer = bufferOrParams.buffer;\n      byteSize = bufferOrParams.byteSize;\n      byteOffset = bufferOrParams.byteOffset;\n    } else {\n      buffer = bufferOrParams;\n    }\n    // to use bindBufferRange, either offset or size must be specified, use default value for the other.\n    if (byteOffset !== undefined || byteSize !== undefined) {\n      byteOffset = byteOffset || 0;\n      byteSize = byteSize || buffer.byteLength - byteOffset;\n    }\n    return {buffer, byteOffset, byteSize};\n  }\n\n  _getVaryingInfo(locationOrName) {\n    return this.configuration && this.configuration.getVaryingInfo(locationOrName);\n  }\n\n  _getVaryingIndex(locationOrName) {\n    if (this.configuration) {\n      return this.configuration.getVaryingInfo(locationOrName).location;\n    }\n    const location = Number(locationOrName);\n    return Number.isFinite(location) ? location : -1;\n  }\n\n  // Need to avoid chrome bug where buffer that is already bound to a different target\n  // cannot be bound to 'TRANSFORM_FEEDBACK_BUFFER' target.\n  _bindBuffers() {\n    if (this.bindOnUse) {\n      for (const bufferIndex in this.buffers) {\n        const {buffer, byteSize, byteOffset} = this._getBufferParams(this.buffers[bufferIndex]);\n        this._bindBuffer(bufferIndex, buffer, byteOffset, byteSize);\n      }\n    }\n  }\n\n  _unbindBuffers() {\n    if (this.bindOnUse) {\n      for (const bufferIndex in this.buffers) {\n        this._bindBuffer(bufferIndex, null);\n      }\n    }\n  }\n\n  _bindBuffer(index, buffer, byteOffset = 0, byteSize) {\n    const handle = buffer && buffer.handle;\n    if (!handle || byteSize === undefined) {\n      this.gl.bindBufferBase(GL.TRANSFORM_FEEDBACK_BUFFER, index, handle);\n    } else {\n      this.gl.bindBufferRange(GL.TRANSFORM_FEEDBACK_BUFFER, index, handle, byteOffset, byteSize);\n    }\n    return this;\n  }\n\n  // RESOURCE METHODS\n\n  _createHandle() {\n    return this.gl.createTransformFeedback();\n  }\n\n  _deleteHandle() {\n    this.gl.deleteTransformFeedback(this.handle);\n  }\n\n  _bindHandle(handle) {\n    this.gl.bindTransformFeedback(GL.TRANSFORM_FEEDBACK, this.handle);\n  }\n}\n"],"sourceRoot":""}