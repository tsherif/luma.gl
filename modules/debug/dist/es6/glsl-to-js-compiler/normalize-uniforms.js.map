{"version":3,"sources":["../../../src/glsl-to-js-compiler/normalize-uniforms.js"],"names":["LENGTH_BY_TYPE","vec2","vec3","vec4","bvec2","bvec3","bvec4","ivec2","ivec3","ivec4","mat2","mat3","mat4","normalizeUniform","value","dimensions","len","dim","length","newValue","i","j","getUniformNormalizer","uniforms","result","name","type","toString"],"mappings":"AAAA,MAAMA,cAAc,GAAG;AACrBC,EAAAA,IAAI,EAAE,CADe;AAErBC,EAAAA,IAAI,EAAE,CAFe;AAGrBC,EAAAA,IAAI,EAAE,CAHe;AAIrBC,EAAAA,KAAK,EAAE,CAJc;AAKrBC,EAAAA,KAAK,EAAE,CALc;AAMrBC,EAAAA,KAAK,EAAE,CANc;AAOrBC,EAAAA,KAAK,EAAE,CAPc;AAQrBC,EAAAA,KAAK,EAAE,CARc;AASrBC,EAAAA,KAAK,EAAE,CATc;AAUrBC,EAAAA,IAAI,EAAE,CAVe;AAWrBC,EAAAA,IAAI,EAAE,CAXe;AAYrBC,EAAAA,IAAI,EAAE;AAZe,CAAvB;AAoBA,OAAO,SAASC,gBAAT,CAA0BC,KAA1B,EAAiCC,UAAjC,EAA6C;AAClD,QAAMC,GAAG,GAAGD,UAAU,CAAC,CAAD,CAAtB;AACA,QAAME,GAAG,GAAGF,UAAU,CAAC,CAAD,CAAtB;;AAEA,MAAID,KAAK,CAACI,MAAN,KAAiBD,GAArB,EAA0B;AACxB,UAAME,QAAQ,GAAG,EAAjB;;AACA,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,GAApB,EAAyBG,CAAC,EAA1B,EAA8B;AAC5BD,MAAAA,QAAQ,CAACC,CAAD,CAAR,GAAc,EAAd;;AACA,WAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGL,GAApB,EAAyBK,CAAC,EAA1B,EAA8B;AAC5BF,QAAAA,QAAQ,CAACC,CAAD,CAAR,CAAYC,CAAZ,IAAiBP,KAAK,CAACM,CAAC,GAAGJ,GAAJ,GAAUK,CAAX,CAAtB;AACD;AACF;;AACD,WAAOF,QAAP;AACD;;AACD,SAAOL,KAAP;AACD;AAKD,OAAO,SAASQ,oBAAT,CAA8BC,QAA9B,EAAwC;AAC7C,MAAIC,MAAM,GAAG,EAAb;;AAEA,OAAK,MAAMC,IAAX,IAAmBF,QAAnB,EAA6B;AAC3B,QAAIA,QAAQ,CAACE,IAAD,CAAR,CAAeV,UAAf,CAA0BG,MAA9B,EAAsC;AACpC,YAAMD,GAAG,GAAGM,QAAQ,CAACE,IAAD,CAAR,CAAeV,UAAf,CAA0B,CAA1B,CAAZ;AACA,YAAMC,GAAG,GAAGhB,cAAc,CAACuB,QAAQ,CAACE,IAAD,CAAR,CAAeC,IAAhB,CAA1B;AACAF,MAAAA,MAAM,uBAAgBC,IAAhB,0CAAoDA,IAApD,gBAA8DR,GAA9D,eAAsED,GAAtE,OAAN;AACD;AACF;;AAED,MAAIQ,MAAJ,EAAY;AACVA,IAAAA,MAAM,aAAMX,gBAAgB,CAACc,QAAjB,EAAN,eAAsCH,MAAtC,CAAN;AACD;;AAED,SAAOA,MAAP;AACD","sourcesContent":["const LENGTH_BY_TYPE = {\n  vec2: 2,\n  vec3: 3,\n  vec4: 4,\n  bvec2: 2,\n  bvec3: 3,\n  bvec4: 4,\n  ivec2: 2,\n  ivec3: 3,\n  ivec4: 4,\n  mat2: 4,\n  mat3: 9,\n  mat4: 16\n};\n\n/**\n * Convert nested uniforms from flat array to expected shape\n * e.g. a vec2[16] uniform can be set with a Float32Array[32] in WebGL\n * but it has to be converted to Array[16] for the transpiled shader code\n */\nexport function normalizeUniform(value, dimensions) {\n  const len = dimensions[1];\n  const dim = dimensions[0];\n\n  if (value.length !== dim) {\n    const newValue = [];\n    for (let i = 0; i < dim; i++) {\n      newValue[i] = [];\n      for (let j = 0; j < len; j++) {\n        newValue[i][j] = value[i * len + j];\n      }\n    }\n    return newValue;\n  }\n  return value;\n}\n\n/**\n * Given a list of uniform definitions, return source code for normalization\n */\nexport function getUniformNormalizer(uniforms) {\n  let result = '';\n\n  for (const name in uniforms) {\n    if (uniforms[name].dimensions.length) {\n      const dim = uniforms[name].dimensions[0];\n      const len = LENGTH_BY_TYPE[uniforms[name].type];\n      result += `uniforms.${name} = normalizeUniform(uniforms.${name}, [${dim}, ${len}])`;\n    }\n  }\n\n  if (result) {\n    result = `${normalizeUniform.toString()}\\n${result}`;\n  }\n\n  return result;\n}\n"],"file":"normalize-uniforms.js"}