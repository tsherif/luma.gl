{"version":3,"sources":["../../../src/blur-filters/lensblur.js"],"names":["random","fsLensBlurPrePass","fsCommon","dependencies","lensBlur","radius","brightness","angle","gl","lensBlurPrePass","Shader","lensBlur0","common","lensBlur1","lensBlur2","textures","texture1","dir","i","a","Math","PI","push","sin","width","cos","height","power","pow","clamp","simpleShader","call","window","_","extraTexture","ensureFormat","texture","delta0","delta1","use"],"mappings":"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","sourcesContent":["// TODO: FIXME\n/* eslint-disable */\n/**\n * @filter           Lens Blur\n * @description      Imitates a camera capturing the image out of focus by using a blur that generates\n *                   the large shapes known as bokeh. The polygonal shape of real bokeh is due to the\n *                   blades of the aperture diaphragm when it isn't fully open. This blur renders\n *                   bokeh from a 6-bladed diaphragm because the computation is more efficient. It\n *                   can be separated into three rhombi, each of which is just a skewed box blur.\n *                   This filter makes use of the floating point texture WebGL extension to implement\n *                   the brightness parameter, so there will be severe visual artifacts if brightness\n *                   is non-zero and the floating point texture extension is not available. The\n *                   idea was from John White's SIGGRAPH 2011 talk but this effect has an additional\n *                   brightness parameter that fakes what would otherwise come from a HDR source.\n * @param radius     the radius of the hexagonal disk convolved with the image\n * @param brightness -1 to 1 (the brightness of the bokeh, negative values will create dark bokeh)\n * @param angle      the rotation of the bokeh in radians\n */\nimport random from '../utils/random';\n\nconst fsLensBlurPrePass = `\\\nuniform sampler2D texture;\nuniform float power;\nvarying vec2 texCoord;\nvoid main() {\n  vec4 color = texture2D(texture, texCoord);\n  color = pow(color, vec4(power));\n  gl_FragColor = vec4(color);\n}\n`;\n\nconst fsCommon = `\\\nuniform sampler2D texture0;\nuniform sampler2D texture1;\nuniform vec2 delta0;\nuniform vec2 delta1;\nuniform float power;\nvarying vec2 texCoord;\n\nvec4 lensBlur_sampleColor(vec2 delta) {\n  /* randomize the lookup values to hide the fixed number of samples */\n  float offset = random(vec3(delta, 151.7182), 0.0);\n\n  vec4 color = vec4(0.0);\n  float total = 0.0;\n  for (float t = 0.0; t <= 30.0; t++) {\n    float percent = (t + offset) / 30.0;\n    color += texture2D(texture0, texCoord + delta * percent);\n    total += 1.0;\n  }\n  return color / total;\n}\n`;\n\nexport default {\n  dependencies: [random],\n  fsLensBlurPrePass,\n  fsCommon\n};\n\nfunction lensBlur(radius, brightness, angle) {\n  // All averaging is done on values raised to a power to make more obvious bokeh\n  // (we will raise the average to the inverse power at the end to compensate).\n  // Without this the image looks almost like a normal blurred image. This hack is\n  // obviously not realistic, but to accurately simulate this we would need a high\n  // dynamic range source photograph which we don't have.\n  gl.lensBlurPrePass = gl.lensBlurPrePass || new Shader(null, '');\n\n  gl.lensBlur0 =\n    gl.lensBlur0 ||\n    new Shader(null, common + '\\\n    void main() {\\\n      gl_FragColor = sample(delta0);\\\n    }\\\n  ');\n  gl.lensBlur1 =\n    gl.lensBlur1 ||\n    new Shader(\n      null,\n      common +\n        '\\\n    void main() {\\\n      gl_FragColor = (sample(delta0) + sample(delta1)) * 0.5;\\\n    }\\\n  '\n    );\n  gl.lensBlur2 =\n    gl.lensBlur2 ||\n    new Shader(\n      null,\n      common +\n        '\\\n    void main() {\\\n      vec4 color = (sample(delta0) + 2.0 * texture2D(texture1, texCoord)) / 3.0;\\\n      gl_FragColor = pow(color, vec4(power));\\\n    }\\\n  '\n    ).textures({texture1: 1});\n\n  // Generate\n  var dir = [];\n  for (var i = 0; i < 3; i++) {\n    var a = angle + (i * Math.PI * 2) / 3;\n    dir.push([(radius * Math.sin(a)) / this.width, (radius * Math.cos(a)) / this.height]);\n  }\n  var power = Math.pow(10, clamp(-1, brightness, 1));\n\n  // Remap the texture values, which will help make the bokeh effect\n  simpleShader.call(this, gl.lensBlurPrePass, {\n    power: power\n  });\n\n  // Blur two rhombi in parallel into extraTexture\n  window._.extraTexture.ensureFormat(window._.texture);\n  simpleShader.call(\n    this,\n    gl.lensBlur0,\n    {\n      delta0: dir[0]\n    },\n    window._.texture,\n    window._.extraTexture\n  );\n  simpleShader.call(\n    this,\n    gl.lensBlur1,\n    {\n      delta0: dir[1],\n      delta1: dir[2]\n    },\n    window._.extraTexture,\n    window._.extraTexture\n  );\n\n  // Blur the last rhombus and combine with extraTexture\n  simpleShader.call(this, gl.lensBlur0, {\n    delta0: dir[1]\n  });\n  window._.extraTexture.use(1);\n  simpleShader.call(this, gl.lensBlur2, {\n    power: 1 / power,\n    delta0: dir[2]\n  });\n\n  return this;\n}\n"],"file":"lensblur.js"}