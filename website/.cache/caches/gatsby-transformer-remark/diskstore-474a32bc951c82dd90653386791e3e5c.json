{"expireTime":9007200809748943000,"key":"transformer-remark-markdown-html-51f447ec3e98c3c4477ec6bdc967708b-gatsby-remark-imagesgatsby-remark-responsive-iframegatsby-remark-prismjsgatsby-remark-copy-linked-filesgatsby-remark-autolink-headers-","val":"<h1 id=\"accessors\"><a href=\"#accessors\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Accessors</h1>\n<p>\"Buffer accessor objects\" (or \"accessor objects\", or just \"accessors\" for short) are used to describe the structure of data contained in WebGL buffers (for more information see <a href=\"developers-guide/buffers.md\"><code class=\"language-text\">Buffers</code></a>).</p>\n<p>When using <code class=\"language-text\">Buffer</code>s as input to shader programs, applications must tell WebGL how the data in the buffer is formatted, so that the GPU knows how to access buffers' memory. To enable applications to specify how the buffer memory should be accessed, luma.gl APIs that set attribute buffers accept buffer \"accessor objects\".</p>\n<h2 id=\"accessor-object-fields\"><a href=\"#accessor-object-fields\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Accessor Object Fields</h2>\n<p>This is an overview of the object accessor fields that are available to applications to define format descriptions. These objects can contain the following fields, this is an excerpt from <a href=\"api-reference/webgl/accessor.md\"><code class=\"language-text\">Accessor</code></a>.</p>\n<table>\n<thead>\n<tr>\n<th>Property</th>\n<th>Auto Deduced</th>\n<th>Default</th>\n<th>Comment</th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code class=\"language-text\">buffer</code></td>\n<td>No</td>\n<td>An accessor can optionally reference a specific buffer. Multiple accessors can point to the same buffer, providing different views or \"slices\" of the buffer's memory.</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><code class=\"language-text\">offset</code></td>\n<td>No</td>\n<td><code class=\"language-text\">0</code></td>\n<td>Byte offset to start of data in buffer</td>\n<td></td>\n</tr>\n<tr>\n<td><code class=\"language-text\">stride</code></td>\n<td>No</td>\n<td><code class=\"language-text\">0</code></td>\n<td>Extra bytes between each successive data element</td>\n<td></td>\n</tr>\n<tr>\n<td><code class=\"language-text\">type</code></td>\n<td>Yes</td>\n<td><code class=\"language-text\">GL.FLOAT</code></td>\n<td>Low level data type (<code class=\"language-text\">GL.BYTE</code>, <code class=\"language-text\">GL.SHORT</code>, ...)</td>\n<td></td>\n</tr>\n<tr>\n<td><code class=\"language-text\">size</code></td>\n<td>Yes</td>\n<td><code class=\"language-text\">1</code></td>\n<td>Components per element (<code class=\"language-text\">1</code>-<code class=\"language-text\">4</code>)</td>\n<td></td>\n</tr>\n<tr>\n<td><code class=\"language-text\">divisor</code></td>\n<td>Yes</td>\n<td><code class=\"language-text\">0</code></td>\n<td>Enables/disables instancing</td>\n<td></td>\n</tr>\n<tr>\n<td><code class=\"language-text\">normalize</code></td>\n<td>N/A</td>\n<td><code class=\"language-text\">false</code></td>\n<td>Normalize integers to [-1,1], or [0,1] if unsigned</td>\n<td></td>\n</tr>\n<tr>\n<td><code class=\"language-text\">integer</code></td>\n<td>N/A</td>\n<td><code class=\"language-text\">false</code></td>\n<td>Disable conversion of integer values to floats <strong>WebGL2</strong></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"combining-accessors-with-buffers\"><a href=\"#combining-accessors-with-buffers\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Combining Accessors with Buffers</h2>\n<p>When setting attributes (e.g. using <code class=\"language-text\">Model.setProps({attributes: {attributeName: value, ...}}))</code>, each attribute value needs to contain both a buffer (a handle to the raw data uploaded to the GPU) and an accessor (describing how that data should be accessed).</p>\n<p>luma.gl provides three methods to specify attribute values so that both a buffer and an accessor are provided:</p>\n<ul>\n<li>As a two-element array: <code class=\"language-text\">[buffer, accessor]</code>.</li>\n<li>As an accessor, in which case the accessor object's <code class=\"language-text\">buffer</code> field should be set to the matching <code class=\"language-text\">Buffer</code>.</li>\n<li>As a <code class=\"language-text\">Buffer</code>, in which case the <code class=\"language-text\">Buffer</code> objects <code class=\"language-text\">accessor</code> field should be set to the mathing <code class=\"language-text\">Accessor</code>.</li>\n</ul>\n<p>All three methods have their uses: the first option gives the applications full freedom to dynamically select combinations of buffers and accessors, the second option is often the natural choice when working with interleaved buffers (see below), and the last choice is often the most convenient when just setting up an ad-hoc buffer for immediate use, as the accessor can be stored directly on the buffer, avoiding the need to manage separate objects.</p>\n<h2 id=\"accessor-class-vs-accessor-objects\"><a href=\"#accessor-class-vs-accessor-objects\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Accessor Class vs Accessor Objects</h2>\n<p>luma.gl provides the <a href=\"api-reference/webgl/accessor.md\"><code class=\"language-text\">Accessor</code></a> helper class to help you work with accessor objects. For instance, the <code class=\"language-text\">Accessor</code> class supports merging of partial accessor objects, see below.</p>\n<p>Note that it is not necessary to use the <code class=\"language-text\">Accessor</code> class, as plain old JavaScript objects with the appropriate fields are also accepted by the various APIs that accept accessors. Use the style that works best for your application.</p>\n<h3 id=\"partial-accessors\"><a href=\"#partial-accessors\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>\"Partial\" Accessors</h3>\n<p>luma.gl allows \"partial\" accessors to be created, and later combined. Usually many accessor fields can be left undefined (e.g. because defaults are sufficient, or because accessor auto-deduction has already deduced the information, see below).</p>\n<p>Partial accessors will be created automatically by <code class=\"language-text\">Program</code> when shaders are compiled and linked, and also by <code class=\"language-text\">Buffer</code> objects when they are created. Any application supplied accessors fields will then be merged in (override) these auto-deduceted fields, that can add any fine-tuning or override of parameters.</p>\n<h3 id=\"accessor-auto-deduction\"><a href=\"#accessor-auto-deduction\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Accessor Auto Deduction</h3>\n<p>luma.gl attempts to \"auto deduce\" as much accessor information as it can, for instance luma.gl can extract fields like <code class=\"language-text\">type</code> and <code class=\"language-text\">size</code> after shaders have been compiled.</p>\n<p>This relieves applications from having to respecify the same thing multiple times. For instance if the application has already declared an attribute as <code class=\"language-text\">in vec2 size</code> in the vertex shader, it does not need to specify <code class=\"language-text\">size:2, type: GL.FLOAT</code> again in the accessor, when it sets the buffer in JavaScript, since this information will have been auto-deduced.</p>\n<p>In many cases, when buffers are not shared between attributes (i.e. interleaved) and default behavior is desired, luma.gl applications often do not need to specify any <code class=\"language-text\">Accessor</code> at all.</p>\n<h3 id=\"merging-resolving-accessors\"><a href=\"#merging-resolving-accessors\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Merging (Resolving) Accessors</h3>\n<p>The <code class=\"language-text\">Accessor</code> API allows for accessors to be merged (or \"resolved\") into a new <code class=\"language-text\">Accessor</code>. Accessor mmerging is mainly used internally in luma.gl to implement support for partial accessors and accessor auto deduction, but can be used by applications if necessary.</p>\n<h3 id=\"data-interleaving\"><a href=\"#data-interleaving\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Data Interleaving</h3>\n<p>Using the<code class=\"language-text\">stride</code> and <code class=\"language-text\">offset</code> fields in accessor objects, it is possible to interleave two arrays so that the first two elements of one array are next to each other, then the next two elements etc.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const interleavedBuffer = new Buffer(gl, accessor: {stride: 12 + 4}}); // Creates a partial accessor with `stride` in buffer.\n\nvertexArray.setAttributes({\n  // These accessors are merged with the `interleavedBuffer` accessor and any\n  // auto-deduced accessors\n  POSITIONS: new Accessor({offset: 0, buffer: interleavedBuffer})\n  COLORS: new Accessor({offset: 12, buffer: interleavedBuffer})\n})</code></pre></div>\n<p>For more information see the article about attributes.</p>\n<h3 id=\"using-different-size-in-buffers-and-shaders\"><a href=\"#using-different-size-in-buffers-and-shaders\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Using Different Size in Buffers and Shaders</h3>\n<p>It is possible to use different size memory attributes than specified by the GLSL shader code, by specifying a different size in the accessor compared to the GLSL shader variable declaration. Extra components in the Buffer memory will be ignored, missing components will be filled in from <code class=\"language-text\">(0.0, 0.0, 0.0, 1.0)</code></p>\n<blockquote>\n<p>Be aware that the headless gl integration does not support this feature due to limitations in headless gl.</p>\n</blockquote>\n<h3 id=\"gltf-format-accessors\"><a href=\"#gltf-format-accessors\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>glTF Format Accessors</h3>\n<p><a href=\"https://www.khronos.org/gltf/\">glTF formatted files</a>. glTF files contain two JSON object arrays (\"bufferViews\" and \"accessors\") that describe how raw memory buffers are organized and should be interpreted.</p>\n<p>The <code class=\"language-text\">Accessor</code> and <code class=\"language-text\">Buffer</code> class APIs have intentionally been designed to be a close representation when converting \"accessors\" and \"bufferViews\" stored in glTF files. Each glTF <code class=\"language-text\">accessor</code> can be mapped to a luma.gl <code class=\"language-text\">Accessor</code> and each glTF <code class=\"language-text\">bufferView</code> can be mapped to a luma.gl <code class=\"language-text\">Buffer</code>. For more details see <a href=\"\">glTF mapping</a>.</p>"}